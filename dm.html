<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rage Space — Direct Message</title>
  <meta name="color-scheme" content="dark" />
  <style>
    :root{
      --green:#39ff14; --ink:#e5ffe5; --bg:#000; --border:#103010; --card:#0a0a0a; --red:#ff0033;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; background:var(--bg); color:var(--green);
      font-family:ui-sans-serif,system-ui,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing:antialiased;
    }

    header{
      position:sticky; top:0; z-index:10;
      background:rgba(0,0,0,.7); backdrop-filter:blur(6px);
      border-bottom:1px solid var(--border);
      padding:12px 16px; display:flex; align-items:center; gap:12px;
    }
    a.back{
      color:var(--green); text-decoration:none; border:1px solid var(--green);
      padding:6px 10px; border-radius:999px; font-weight:700; line-height:1;
    }
    a.back:hover{ background:rgba(57,255,20,.08); }
    .title{
      display:flex; align-items:center; gap:10px; min-width:0;
    }
    .tiny-pfp{
      width:28px; height:28px; border-radius:8px; overflow:hidden; flex:0 0 auto;
      border:1px solid var(--green); background:#111;
    }
    .tiny-pfp img{ width:100%; height:100%; object-fit:cover; display:block; }
    .other-name{
      font-size:16px; font-weight:800; letter-spacing:.2px; color:var(--green);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:60vw;
    }

    .wrap{ max-width:940px; margin:0 auto; padding:12px 16px 90px; }

    /* Chat area */
    #messages{
      display:flex; flex-direction:column; gap:8px;
    }
    .row{
      display:flex; width:100%;
    }
    .row.me{ justify-content:flex-end; }
    .row.them{ justify-content:flex-start; }

    .bubble{
      max-width:70%;
      padding:10px 12px; border-radius:14px;
      background:linear-gradient(180deg,#0c0c0c,#070707);
      border:1px solid var(--border); color:var(--ink);
      box-shadow: inset 0 0 10px rgba(57,255,20,.07);
      word-wrap:break-word; white-space:pre-wrap;
      line-height:1.25;
    }
    .row.me .bubble{
      border-color:#1d401d; box-shadow: inset 0 0 10px rgba(57,255,20,.14);
    }
    .meta-line{
      font-size:11px; opacity:.7; margin-top:4px; color:var(--ink);
    }

    /* Composer */
    .composer{
      position:fixed; left:0; right:0; bottom:0; z-index:9;
      background:rgba(0,0,0,.78); backdrop-filter:blur(6px);
      border-top:1px solid var(--border);
    }
    .composer-inner{
      max-width:940px; margin:0 auto; padding:10px 16px; display:flex; gap:8px;
    }
    .composer input{
      flex:1; padding:12px 12px; border-radius:10px; border:1px solid var(--border);
      background:linear-gradient(180deg,#0b0b0b,#060606); color:var(--ink);
      outline:none;
    }
    .send{
      padding:10px 14px; border-radius:10px; border:1px solid var(--green);
      background:#031803; color:var(--green); font-weight:800; cursor:pointer;
    }
    .send:hover{ filter:brightness(1.1); }
    .empty{
      text-align:center; padding:28px; color:var(--ink); opacity:.75;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <header>
    <a class="back" href="./inbox.html">← Inbox</a>
    <div class="title">
      <div class="tiny-pfp" id="otherPfp"></div>
      <div class="other-name" id="otherName">Loading…</div>
    </div>
  </header>

  <main class="wrap">
    <div id="messages"></div>
    <div id="noMsgs" class="empty" style="display:none;">No messages yet — say hi.</div>
  </main>

  <div class="composer">
    <form id="composerForm" class="composer-inner">
      <input id="msgInput" type="text" placeholder="Type a message…" autocomplete="off" />
      <button class="send" type="submit">Send</button>
    </form>
  </div>

  <script>
    // --- Supabase init ---
    const sb = supabase.createClient(
      "https://tuqvpcevrhciursxrgav.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y"
    );

    // --- Elements ---
    const messagesEl = document.getElementById('messages');
    const noMsgsEl = document.getElementById('noMsgs');
    const inputEl = document.getElementById('msgInput');
    const formEl = document.getElementById('composerForm');
    const otherNameEl = document.getElementById('otherName');
    const otherPfpEl = document.getElementById('otherPfp');

    // --- URL param: thread ---
    const url = new URL(location.href);
    const threadId = url.searchParams.get('thread');

    // Guard: if no thread provided, bounce back.
    if(!threadId){
      alert('Missing thread id');
      location.href = './inbox.html';
    }

    // Key used by inbox unread logic
    const lastReadKey = `dm_last_read_${threadId}`;

    let me = null;
    let thread = null;
    let otherProfile = null;
    let sub = null;

    function markThreadRead(){
      // Store "last read" as *now* in ms since epoch
      localStorage.setItem(lastReadKey, Date.now());
    }

    function scrollToBottom(){
      // After DOM update, scroll to bottom
      requestAnimationFrame(() => {
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      });
    }

    function msgRow(m){
      const mine = m.sender === me.id;
      const row = document.createElement('div');
      row.className = 'row ' + (mine ? 'me' : 'them');
      const time = new Date(m.created_at);
      const hh = String(time.getHours()).padStart(2,'0');
      const mm = String(time.getMinutes()).padStart(2,'0');
      const ss = String(time.getSeconds()).padStart(2,'0');

      row.innerHTML = `
        <div class="bubble">
          <div>${m.body ? m.body.replace(/</g,'&lt;').replace(/>/g,'&gt;') : ''}</div>
          <div class="meta-line">${hh}:${mm}:${ss}</div>
        </div>
      `;
      return row;
    }

    async function loadThreadAndHeader(){
      // load thread so we can figure out the "other" user id
      const { data: t, error } = await sb
        .from('dm_threads')
        .select('id,a,b')
        .eq('id', threadId)
        .maybeSingle();
      if(error || !t){ console.error(error); return; }
      thread = t;

      const otherId = (t.a === me.id) ? t.b : t.a;
      const { data: p } = await sb
        .from('profiles')
        .select('id,display_name,username,avatar_url')
        .eq('id', otherId)
        .maybeSingle();
      otherProfile = p;

      otherNameEl.textContent = p?.display_name || ('@' + (p?.username || 'user'));
      if(p?.avatar_url){
        otherPfpEl.innerHTML = `<img src="${p.avatar_url}" alt="">`;
      } else {
        otherPfpEl.innerHTML = '';
      }
    }

    async function loadMessages(){
      const { data: msgs, error } = await sb
        .from('dm_messages')
        .select('id,body,created_at,sender')
        .eq('thread_id', threadId)
        .order('created_at', { ascending:true });
      if(error){ console.error(error); return; }

      messagesEl.innerHTML = '';
      if(!msgs || msgs.length === 0){
        noMsgsEl.style.display = '';
      } else {
        noMsgsEl.style.display = 'none';
        for(const m of msgs){
          messagesEl.appendChild(msgRow(m));
        }
      }
      scrollToBottom();

      // We’re viewing the thread -> mark read
      markThreadRead();
    }

    function setupRealtime(){
      // Clean previous channel if any
      if(sub){ sb.removeChannel(sub); sub = null; }

      sub = sb.channel('dm_thread_' + threadId)
        .on('postgres_changes',
          { event: 'INSERT', schema: 'public', table: 'dm_messages', filter: `thread_id=eq.${threadId}` },
          (payload) => {
            const m = payload.new;
            messagesEl.appendChild(msgRow(m));
            scrollToBottom();

            // We’re actively in this thread; count as read
            markThreadRead();
          }
        )
        .subscribe((status) => {
          // optional: console.log('realtime status', status);
        });
    }

    async function sendMessage(body){
      if(!body.trim()) return;
      const { error } = await sb
        .from('dm_messages')
        .insert({
          thread_id: threadId,
          sender: me.id,
          body: body.trim()
        });
      if(error){ console.error(error); return; }
      inputEl.value = '';
      // After send, mark as read too (you’ve seen the latest state)
      markThreadRead();
    }

    async function boot(){
      // Require auth
      const { data: { session } } = await sb.auth.getSession();
      if(!session){ location.href = './login.html'; return; }
      me = session.user;

      await loadThreadAndHeader();
      await loadMessages();
      setupRealtime();

      // Also mark read when user focuses/returns
      window.addEventListener('focus', markThreadRead);
      document.addEventListener('visibilitychange', () => {
        if(document.visibilityState === 'visible') markThreadRead();
      });
    }

    formEl.addEventListener('submit', (e) => {
      e.preventDefault();
      sendMessage(inputEl.value);
    });

    document.addEventListener('DOMContentLoaded', boot);
    // Defensive: mark read right away on initial open too
    markThreadRead();
  </script>
</body>
</html>