<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — City Proto</title>

  <style>
    :root {
      --green: #39ff14;
      --red: #ff0033;
    }

    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .home-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      right: 16px;
      padding: 8px 14px;
      border: 1px solid var(--green);
      border-radius: 8px;
      text-decoration: none;
      color: var(--green);
      background: transparent;
      font-weight: bold;
      text-shadow: 0 0 6px var(--green);
      z-index: 9999;
      pointer-events: auto;
    }
    .home-btn:hover {
      color: var(--red);
      border-color: var(--red);
      text-shadow: 0 0 6px var(--red);
    }

    .fullscreen-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(57, 255, 20, 0.8);
      background: rgba(0, 0, 0, 0.85);
      color: var(--green);
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.7);
      z-index: 9999;
      pointer-events: auto;
    }
    .fullscreen-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
    }

    #game-container {
      margin-top: 80px;
      margin-bottom: 8px;
      width: calc(100% - 24px);
      max-width: 720px;
      position: relative;
      height: 520px;
      border: 2px solid rgba(57, 255, 20, 0.9);
      box-shadow: 0 0 16px rgba(57, 255, 20, 0.8);
      background: #020202;
      overflow: hidden;
      margin-left: auto;
      margin-right: auto;
    }

    #game-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: rgba(57, 255, 20, 0.7);
      z-index: 1;
    }

    #art-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5;
      flex-direction: column;
    }

    #art-overlay-img {
      max-width: 90%;
      max-height: 80%;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(57, 255, 20, 0.8);
    }

    #art-overlay-msg {
      width: 100%;
      text-align: center;
      font-size: 18px;
      color: var(--green);
      text-shadow: 0 0 8px var(--green);
      margin-bottom: 12px;
      display: block;
    }

    .controls-overlay {
      position: fixed;
      left: 0;
      right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      z-index: 999;
      pointer-events: none;
    }

    .controls-inner {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 12px;
    }

    .dpad,
    .ab-buttons {
      pointer-events: auto;
    }

    .dpad {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 4px;
      opacity: 0.9;
    }

    .dpad button,
    .ab-buttons button {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid rgba(57, 255, 20, 0.8);
      border-radius: 12px;
      color: var(--green);
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(57, 255, 20, 0.9);
      touch-action: none;
    }

    .dpad button:active,
    .ab-buttons button:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
      background: #000;
    }

    .dpad .empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .ab-buttons {
      position: relative;
      width: 180px;
      height: 140px;
      opacity: 0.9;
    }

    .ab-buttons button {
      position: absolute;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      font-size: 1.1rem;
    }

    .ab-buttons .btn-a::after,
    .ab-buttons .btn-b::after {
      display: block;
      font-size: 0.65rem;
      margin-top: 2px;
      letter-spacing: 2px;
    }
    .ab-buttons .btn-a::after {
      content: "A";
    }
    .ab-buttons .btn-b::after {
      content: "B";
    }

    .ab-buttons .btn-b {
      bottom: 10px;
      left: 30px;
    }
    .ab-buttons .btn-a {
      bottom: 40px;
      right: 25px;
    }

    @media (max-width: 600px) {
      #game-container {
        height: 480px;
      }
      .dpad {
        grid-template-columns: 52px 52px 52px;
        grid-template-rows: 52px 52px 52px;
      }
      .ab-buttons button {
        width: 56px;
        height: 56px;
      }
    }
  </style>
</head>
<body>
  <a class="home-btn" href="./menu.html">← Menu</a>

  <button id="btn-fullscreen" class="fullscreen-btn">⛶ Fullscreen</button>

  <div id="game-container">
    <div id="game-fallback">Loading Rage City…</div>

    <div id="art-overlay">
      <div id="art-overlay-msg">Press "A" for fullscreen</div>
      <img
        id="art-overlay-img"
        src="https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=2000&q=80"
        alt="Gallery art"
      />
    </div>
  </div>

  <div class="controls-overlay">
    <div class="controls-inner">
      <div class="dpad">
        <button class="empty" disabled></button>
        <button id="btn-up">▲</button>
        <button class="empty" disabled></button>

        <button id="btn-left">◀</button>
        <button class="empty" disabled></button>
        <button id="btn-right">▶</button>

        <button class="empty" disabled></button>
        <button id="btn-down">▼</button>
        <button class="empty" disabled></button>
      </div>

      <div class="ab-buttons">
        <button id="btn-b" class="btn-b">●</button>
        <button id="btn-a" class="btn-a">●</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <script>
    const inputState = {
      left: false,
      right: false,
      up: false,
      down: false,
      A: false,
      B: false
    };

    const PAINTING_FULL_URL =
      "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=2000&q=80";
    const SCULPTURE_FULL_URL =
      "https://images.unsplash.com/photo-1582719478250-c89cae4dc85b?auto=format&fit=crop&w=2000&q=80";

    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      parent: "game-container",
      pixelArt: false,
      backgroundColor: "#111122",
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      scene: { preload, create, update }
    };

    let player;
    let promptText;
    let artOpen = false;
    let prevA = false;
    let prevB = false;

    let galleryFrames = [];
    let sculptureSpot = null;

    const artOverlayEl = document.getElementById("art-overlay");
    const artImg = document.getElementById("art-overlay-img");
    const artMsg = document.getElementById("art-overlay-msg");

    function preload() {
      this.load.image(
        "artThumb",
        "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=1000&q=80"
      );
    }

    function create() {
      const fb = document.getElementById("game-fallback");
      if (fb) fb.style.display = "none";

      const w = this.scale.width;
      const h = this.scale.height;

      // ==== ROOM GEOMETRY (walls & LEFT-SIDE door) ====
      const marginX = 60;
      const marginY = 90;

      const leftOuter = marginX;
      const rightOuter = w - marginX;
      const topOuter = marginY;
      const bottomOuter = h - marginY;

      const corridorWidth = 32;
      const leftInner = leftOuter + corridorWidth;
      const rightInner = rightOuter - corridorWidth;
      const topInner = topOuter + corridorWidth;
      const bottomInner = bottomOuter - corridorWidth;

      const doorWidth = 90;

      // door on the LEFT wall, a bit below center
      const doorCenterY = topInner + (bottomInner - topInner) * 0.65;
      const gapOuterTopY = doorCenterY - doorWidth / 2;
      const gapOuterBotY = doorCenterY + doorWidth / 2;

      const gapInnerTopY = doorCenterY - doorWidth / 2;
      const gapInnerBotY = doorCenterY + doorWidth / 2;

      // Outer wall with opening on the left
      const wallOuter = this.add.graphics();
      wallOuter.lineStyle(4, 0xffffff, 1);
      wallOuter.beginPath();
      wallOuter.moveTo(leftOuter, topOuter);
      wallOuter.lineTo(rightOuter, topOuter);
      wallOuter.lineTo(rightOuter, bottomOuter);
      wallOuter.lineTo(leftOuter, bottomOuter);
      wallOuter.lineTo(leftOuter, gapOuterBotY);      // up to bottom of doorway
      wallOuter.moveTo(leftOuter, gapOuterTopY);      // skip gap
      wallOuter.lineTo(leftOuter, topOuter);
      wallOuter.strokePath();

      // Inner wall with matching opening
      const wallInner = this.add.graphics();
      wallInner.lineStyle(4, 0xffffff, 1);
      wallInner.beginPath();
      wallInner.moveTo(leftInner, topInner);
      wallInner.lineTo(rightInner, topInner);
      wallInner.lineTo(rightInner, bottomInner);
      wallInner.lineTo(leftInner, bottomInner);
      wallInner.lineTo(leftInner, gapInnerBotY);
      wallInner.moveTo(leftInner, gapInnerTopY);
      wallInner.lineTo(leftInner, topInner);
      wallInner.strokePath();

      // Player starts just outside that left opening
      player = this.add.rectangle(leftOuter - 20, doorCenterY, 20, 20, 0x39ff14);

      // ===== TRAPEZOID PAINTING FRAMES (inside corridor) =====
      const tex = this.textures.get("artThumb").getSourceImage();
      const natW = tex.width;
      const natH = tex.height;
      const imgMaxW = 26;
      const imgMaxH = 26;
      const imgScale = Math.min(imgMaxW / natW, imgMaxH / natH);

      galleryFrames = [];

      function addTrapezoidFrame(scene, x, y, side) {
        const g = scene.add.graphics();
        g.lineStyle(3, 0x39ff14, 1);

        const wTop = 18;
        const wBottom = 28;
        const h = 26;
        const skew = 5;

        let points;

        if (side === "left") {
          points = [
            { x: -wBottom / 2, y: -h / 2 },
            { x:  wTop / 2,    y: -h / 2 + skew },
            { x:  wTop / 2,    y:  h / 2 - skew },
            { x: -wBottom / 2, y:  h / 2 }
          ];
        } else if (side === "right") {
          points = [
            { x: -wTop / 2,    y: -h / 2 + skew },
            { x:  wBottom / 2, y: -h / 2 },
            { x:  wBottom / 2, y:  h / 2 },
            { x: -wTop / 2,    y:  h / 2 - skew }
          ];
        } else if (side === "top") {
          // flipped vs bottom
          points = [
            { x: -wBottom / 2, y: -h / 2 },
            { x:  wBottom / 2, y: -h / 2 },
            { x:  wTop / 2,    y:  h / 2 },
            { x: -wTop / 2,    y:  h / 2 }
          ];
        } else {
          // bottom
          points = [
            { x: -wTop / 2,    y: -h / 2 },
            { x:  wTop / 2,    y: -h / 2 },
            { x:  wBottom / 2, y:  h / 2 },
            { x: -wBottom / 2, y:  h / 2 }
          ];
        }

        g.beginPath();
        g.moveTo(x + points[0].x, y + points[0].y);
        for (let i = 1; i < points.length; i++) {
          g.lineTo(x + points[i].x, y + points[i].y);
        }
        g.closePath();
        g.strokePath();

        const gMat = scene.add.graphics();
        gMat.lineStyle(2, 0x1a8f3a, 1);
        gMat.fillStyle(0x000000, 1);

        const matScale = 0.78;
        gMat.beginPath();
        gMat.moveTo(
          x + points[0].x * matScale,
          y + points[0].y * matScale
        );
        for (let i = 1; i < points.length; i++) {
          gMat.lineTo(
            x + points[i].x * matScale,
            y + points[i].y * matScale
          );
        }
        gMat.closePath();
        gMat.fillPath();
        gMat.strokePath();

        const img = scene.add.image(x, y, "artThumb");
        img.setScale(imgScale * 0.9);

        galleryFrames.push({
          x,
          y,
          side,
          frameGfx: g,
          matGfx: gMat,
          img,
          fullUrl: PAINTING_FULL_URL
        });
      }

      // centers between inner and outer walls
      const midLeftX   = (leftOuter  + leftInner)  / 2;
      const midRightX  = (rightOuter + rightInner) / 2;
      const midTopY    = (topOuter   + topInner)   / 2;
      const midBottomY = (bottomOuter+ bottomInner)/ 2;

      // ----- TOP ROW: spaced paintings -----
      const topCount = 4;
      const topStartX = leftInner + 35;
      const topEndX   = rightInner - 35;
      for (let i = 0; i < topCount; i++) {
        const t = topCount === 1 ? 0.5 : i / (topCount - 1);
        const x = Phaser.Math.Linear(topStartX, topEndX, t);
        addTrapezoidFrame(this, x, midTopY, "top");
      }

      // ----- RIGHT WALL -----
      const rightCount = 4;
      for (let i = 0; i < rightCount; i++) {
        const t = i / (rightCount - 1);
        const y = Phaser.Math.Linear(topInner + 40, bottomInner - 40, t);
        addTrapezoidFrame(this, midRightX, y, "right");
      }

      // ----- LEFT WALL: now 2 (we “moved” the middle one) -----
      const leftYPositions = [
        topInner + 55,         // high
        gapInnerTopY - 22      // just above doorway
      ];
      leftYPositions.forEach((y) => {
        addTrapezoidFrame(this, midLeftX, y, "left");
      });

      // ----- BOTTOM ROW: now 5, more spaced -----
      const bottomCount = 5;
      const bottomStartX = leftInner + 40;
      const bottomEndX   = rightInner - 40;
      for (let i = 0; i < bottomCount; i++) {
        const t = bottomCount === 1 ? 0.5 : i / (bottomCount - 1);
        const x = Phaser.Math.Linear(bottomStartX, bottomEndX, t);
        addTrapezoidFrame(this, x, midBottomY, "bottom");
      }

      // ===== Center pedestal =====
      const centerX = (leftOuter + rightOuter) / 2;
      const centerY = (topOuter + bottomOuter) / 2;

      const pedestalBase = this.add.rectangle(centerX, centerY, 80, 80, 0x000000);
      pedestalBase.setStrokeStyle(3, 0xffffff, 1);

      const pedestalTop = this.add.rectangle(centerX, centerY, 40, 40, 0x111111);
      pedestalTop.setStrokeStyle(2, 0x39ff14, 1);

      sculptureSpot = {
        x: centerX,
        y: centerY,
        fullUrl: SCULPTURE_FULL_URL,
        type: "sculpture"
      };

      // prompt text
      promptText = this.add.text(w / 2, h - 40, "", {
        fontFamily:
          "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
        fontSize: "14px",
        color: "#39ff14"
      });
      promptText.setOrigin(0.5);
      promptText.setVisible(false);

      this.scale.on("resize", (gameSize) => {
        promptText.setPosition(gameSize.width / 2, gameSize.height - 40);
      });

      setupKeyboard(this);
      setupTouchButton("btn-left", "left");
      setupTouchButton("btn-right", "right");
      setupTouchButton("btn-up", "up");
      setupTouchButton("btn-down", "down");
      setupTouchButton("btn-a", "A");
      setupTouchButton("btn-b", "B");
      setupFullscreenButton();

      artOverlayEl.addEventListener("click", () => {
        if (artOpen) closeArtOverlay();
      });
    }

    function setupKeyboard(scene) {
      scene.input.keyboard.on("keydown", (event) => {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = true;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = true;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = true;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = true;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = true;
            break;
          case "KeyX":
            inputState.B = true;
            break;
        }
      });

      scene.input.keyboard.on("keyup", (event) => {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = false;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = false;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = false;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = false;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = false;
            break;
          case "KeyX":
            inputState.B = false;
            break;
        }
      });
    }

    function setupTouchButton(id, key) {
      const el = document.getElementById(id);
      if (!el) return;

      function setPressed(pressed) {
        inputState[key] = pressed;
      }

      function start(e) {
        e.preventDefault();
        setPressed(true);
      }
      function end(e) {
        e.preventDefault();
        setPressed(false);
      }

      el.addEventListener("mousedown", start);
      el.addEventListener("mouseup", end);
      el.addEventListener("mouseleave", end);

      el.addEventListener("touchstart", start, { passive: false });
      el.addEventListener("touchend", end, { passive: false });
      el.addEventListener("touchcancel", end, { passive: false });
    }

    function setupFullscreenButton() {
      const btn = document.getElementById("btn-fullscreen");
      if (!btn) return;

      btn.addEventListener("click", () => {
        const elem = document.documentElement;
        if (!document.fullscreenElement) {
          if (elem.requestFullscreen) elem.requestFullscreen();
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      });

      document.addEventListener("fullscreenchange", () => {
        if (!btn) return;
        btn.textContent = document.fullscreenElement
          ? "⛶ Exit Fullscreen"
          : "⛶ Fullscreen";
      });
    }

    function update(time, delta) {
      if (!player) return;

      const justPressedA = inputState.A && !prevA;
      const justPressedB = inputState.B && !prevB;

      if (artOpen) {
        if (justPressedA) toggleArtFullscreen();
        if (justPressedB) closeArtOverlay();
        prevA = inputState.A;
        prevB = inputState.B;
        return;
      }

      const speed = 90;
      const dt = delta / 1000;

      let dx = 0,
        dy = 0;
      if (inputState.left) dx -= 1;
      if (inputState.right) dx += 1;
      if (inputState.up) dy -= 1;
      if (inputState.down) dy += 1;

      if (dx !== 0 && dy !== 0) {
        const inv = 1 / Math.sqrt(2);
        dx *= inv;
        dy *= inv;
      }

      player.x += dx * speed * dt;
      player.y += dy * speed * dt;

      const margin = 40;
      const w = this.scale.width;
      const h = this.scale.height;
      player.x = Phaser.Math.Clamp(player.x, margin, w - margin);
      player.y = Phaser.Math.Clamp(player.y, margin, h - margin);

      let nearestItem = null;
      let nearestDist = Infinity;

      galleryFrames.forEach((f) => {
        const d = Phaser.Math.Distance.Between(player.x, player.y, f.x, f.y);
        if (d < nearestDist) {
          nearestDist = d;
          nearestItem = { type: "painting", fullUrl: f.fullUrl };
        }
      });

      if (sculptureSpot) {
        const d = Phaser.Math.Distance.Between(
          player.x,
          player.y,
          sculptureSpot.x,
          sculptureSpot.y
        );
        if (d < nearestDist) {
          nearestDist = d;
          nearestItem = { type: "sculpture", fullUrl: sculptureSpot.fullUrl };
        }
      }

      if (promptText) {
        if (nearestItem && nearestDist < 80) {
          promptText.setVisible(true);
          promptText.setText(
            nearestItem.type === "sculpture"
              ? "Press A to inspect sculpture"
              : "Press A to view art"
          );
        } else {
          promptText.setVisible(false);
        }
      }

      if (nearestItem && nearestDist < 60 && justPressedA) {
        openArtOverlay(nearestItem.fullUrl);
      }

      prevA = inputState.A;
      prevB = inputState.B;
    }

    function openArtOverlay(imageUrl) {
      artOpen = true;
      if (imageUrl && artImg) artImg.src = imageUrl;
      if (artOverlayEl) artOverlayEl.style.display = "flex";
      if (promptText) promptText.setVisible(false);
      if (artMsg) artMsg.style.display = "block";
    }

    function closeArtOverlay() {
      artOpen = false;
      if (artOverlayEl) artOverlayEl.style.display = "none";
      if (artMsg) artMsg.style.display = "none";

      if (
        (document.fullscreenElement === artImg ||
          document.webkitFullscreenElement === artImg) &&
        document.exitFullscreen
      ) {
        document.exitFullscreen();
      }
    }

    function toggleArtFullscreen() {
      if (artMsg) artMsg.style.display = "none";
      if (
        document.fullscreenElement === artImg ||
        document.webkitFullscreenElement === artImg
      ) {
        if (document.exitFullscreen) document.exitFullscreen();
      } else {
        if (artImg.requestFullscreen) {
          artImg.requestFullscreen();
        }
      }
    }

    new Phaser.Game(config);
  </script>
</body>
</html>