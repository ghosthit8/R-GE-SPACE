<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — City Proto</title>

  <!-- No global style.css here on purpose -->

  <style>
    :root {
      --green: #39ff14;
      --red: #ff0033;
    }

    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* Menu button (top-right) */
    .home-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      right: 16px;
      padding: 8px 14px;
      border: 1px solid var(--green);
      border-radius: 8px;
      text-decoration: none;
      color: var(--green);
      background: transparent;
      font-weight: bold;
      text-shadow: 0 0 6px var(--green);
      z-index: 9999;
      pointer-events: auto;
    }
    .home-btn:hover {
      color: var(--red);
      border-color: var(--red);
      text-shadow: 0 0 6px var(--red);
    }

    /* Fullscreen button (top-left) */
    .fullscreen-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(57, 255, 20, 0.8);
      background: rgba(0, 0, 0, 0.85);
      color: var(--green);
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.7);
      z-index: 9999;
      pointer-events: auto;
    }
    .fullscreen-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
    }

    /* GAME BOX – big viewer with margin so border shows on all sides */
    #game-container {
      margin-top: 80px;             /* room for top buttons */
      margin-bottom: 8px;
      width: calc(100% - 24px);     /* small side margins */
      max-width: 720px;
      position: relative;
      height: 520px;                /* TALL viewer */
      border: 2px solid rgba(57, 255, 20, 0.9);
      box-shadow: 0 0 16px rgba(57, 255, 20, 0.8);
      background: #020202;
      overflow: hidden;
      margin-left: auto;
      margin-right: auto;
    }

    #game-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: rgba(57, 255, 20, 0.7);
    }

    /* CONTROLS */
    .controls-overlay {
      position: fixed;
      left: 0;
      right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      z-index: 999;
      pointer-events: none;
    }

    .controls-inner {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 12px;
    }

    .dpad,
    .ab-buttons {
      pointer-events: auto;
    }

    .dpad {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 4px;
      opacity: 0.9;
    }

    .dpad button,
    .ab-buttons button {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid rgba(57, 255, 20, 0.8);
      border-radius: 12px;
      color: var(--green);
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(57, 255, 20, 0.9);
      touch-action: none;
    }

    .dpad button:active,
    .ab-buttons button:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
      background: #000;
    }

    .dpad .empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    /* A/B buttons – repositioned to match your circled spots */
    .ab-buttons {
      position: relative;
      width: 180px;    /* area to place A/B inside */
      height: 140px;
      opacity: 0.9;
    }

    .ab-buttons button {
      position: absolute;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      font-size: 1.1rem;
    }

    .ab-buttons .btn-a::after,
    .ab-buttons .btn-b::after {
      display: block;
      font-size: 0.65rem;
      margin-top: 2px;
      letter-spacing: 2px;
    }
    .ab-buttons .btn-a::after {
      content: "A";
    }
    .ab-buttons .btn-b::after {
      content: "B";
    }

    /* Positions: B lower-left, A upper-right in the cluster */
    .ab-buttons .btn-b {
      bottom: 10px;
      left: 30px;
    }
    .ab-buttons .btn-a {
      bottom: 40px;
      right: 25px;
    }

    @media (max-width: 600px) {
      /* On smaller phones, still big but slightly shorter */
      #game-container {
        height: 480px;
      }

      .dpad {
        grid-template-columns: 52px 52px 52px;
        grid-template-rows: 52px 52px 52px;
      }
      .ab-buttons button {
        width: 56px;
        height: 56px;
      }
    }
  </style>
</head>
<body>
  <a class="home-btn" href="./menu.html">← Menu</a>

  <button id="btn-fullscreen" class="fullscreen-btn">⛶ Fullscreen</button>

  <div id="game-container">
    <div id="game-fallback">Loading Rage City…</div>
  </div>

  <!-- On-screen controls -->
  <div class="controls-overlay">
    <div class="controls-inner">
      <div class="dpad">
        <button class="empty" disabled></button>
        <button id="btn-up">▲</button>
        <button class="empty" disabled></button>

        <button id="btn-left">◀</button>
        <button class="empty" disabled></button>
        <button id="btn-right">▶</button>

        <button class="empty" disabled></button>
        <button id="btn-down">▼</button>
        <button class="empty" disabled></button>
      </div>

      <div class="ab-buttons">
        <button id="btn-b" class="btn-b">●</button>
        <button id="btn-a" class="btn-a">●</button>
      </div>
    </div>
  </div>

  <!-- Phaser 3 engine -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <!-- Game logic INLINE -->
  <script>
    const inputState = {
      left: false,
      right: false,
      up: false,
      down: false,
      A: false,
      B: false
    };

    const config = {
      type: Phaser.AUTO,
      width: 480,   // base resolution (will be overridden by RESIZE)
      height: 320,
      parent: "game-container",
      pixelArt: true,
      backgroundColor: "#111122",
      scale: {
        mode: Phaser.Scale.RESIZE,          // canvas always matches viewer size
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      scene: {
        preload,
        create,
        update
      }
    };

    let player;
    let frameRect;
    let frameOutline;
    let promptText;
    let artOverlayBg;
    let artOverlayImage;
    let artOpen = false;
    let prevA = false;

    function preload() {
      // Placeholder art image – replace this URL with any image you want
      this.load.image(
        "artImage",
        "https://images.pexels.com/photos/2837009/pexels-photo-2837009.jpeg?auto=compress&cs=tinysrgb&w=800"
      );
    }

    function create() {
      const fb = document.getElementById("game-fallback");
      if (fb) fb.style.display = "none";

      // Place player in the center of the current viewer size
      player = this.add.rectangle(
        this.scale.width / 2,
        this.scale.height / 2,
        32,
        32,
        0x39ff14
      );

      // --- Picture frame on the "map" ---
      // Position it somewhere on the right side of the viewer
      const frameX = this.scale.width * 0.75;
      const frameY = this.scale.height * 0.4;

      // Inner filled rect (like a screen)
      frameRect = this.add.rectangle(
        frameX,
        frameY,
        48,
        36,
        0x111111
      );
      // Neon outline
      frameOutline = this.add.rectangle(
        frameX,
        frameY,
        52,
        40
      );
      frameOutline.setStrokeStyle(2, 0x39ff14, 1);

      // Prompt text for interaction
      promptText = this.add.text(
        this.scale.width / 2,
        this.scale.height - 40,
        "Press A to view art",
        {
          fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
          fontSize: "14px",
          color: "#39ff14"
        }
      );
      promptText.setOrigin(0.5);
      promptText.setVisible(false);

      // Overlay for expanded image
      artOverlayBg = this.add.rectangle(
        this.scale.width / 2,
        this.scale.height / 2,
        this.scale.width,
        this.scale.height,
        0x000000,
        0.9
      );
      artOverlayImage = this.add.image(
        this.scale.width / 2,
        this.scale.height / 2,
        "artImage"
      );

      // Scale the image to fit nicely inside
      resizeArtOverlay(this);

      artOverlayBg.setVisible(false);
      artOverlayImage.setVisible(false);

      // Update overlay sizes if the game is resized
      this.scale.on("resize", (gameSize) => {
        const width = gameSize.width;
        const height = gameSize.height;

        artOverlayBg.setPosition(width / 2, height / 2);
        artOverlayBg.setSize(width, height);

        artOverlayImage.setPosition(width / 2, height / 2);
        resizeArtOverlay(this);

        promptText.setPosition(width / 2, height - 40);
      });

      setupKeyboard(this);
      setupTouchButton("btn-left", "left");
      setupTouchButton("btn-right", "right");
      setupTouchButton("btn-up", "up");
      setupTouchButton("btn-down", "down");
      setupTouchButton("btn-a", "A");
      setupTouchButton("btn-b", "B");

      setupFullscreenButton();
    }

    function resizeArtOverlay(scene) {
      if (!artOverlayImage) return;
      const maxW = scene.scale.width * 0.8;
      const maxH = scene.scale.height * 0.8;
      const tex = artOverlayImage.texture;
      if (!tex || !tex.source[0]) return;

      const natW = tex.source[0].width;
      const natH = tex.source[0].height;

      const scale = Math.min(maxW / natW, maxH / natH, 1);
      artOverlayImage.setDisplaySize(natW * scale, natH * scale);
    }

    function setupKeyboard(scene) {
      scene.input.keyboard.on("keydown", function (event) {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = true;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = true;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = true;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = true;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = true;
            break;
          case "KeyX":
            inputState.B = true;
            break;
        }
      });

      scene.input.keyboard.on("keyup", function (event) {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = false;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = false;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = false;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = false;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = false;
            break;
          case "KeyX":
            inputState.B = false;
            break;
        }
      });
    }

    function setupTouchButton(id, key) {
      const el = document.getElementById(id);
      if (!el) return;

      function setPressed(pressed) {
        inputState[key] = pressed;
      }

      function start(e) {
        e.preventDefault();
        setPressed(true);
      }
      function end(e) {
        e.preventDefault();
        setPressed(false);
      }

      el.addEventListener("mousedown", start);
      el.addEventListener("mouseup", end);
      el.addEventListener("mouseleave", end);

      el.addEventListener("touchstart", start, { passive: false });
      el.addEventListener("touchend", end, { passive: false });
      el.addEventListener("touchcancel", end, { passive: false });
    }

    function setupFullscreenButton() {
      const btn = document.getElementById("btn-fullscreen");
      if (!btn) return;

      btn.addEventListener("click", () => {
        // Fullscreen the whole page so controls stay visible
        const elem = document.documentElement;

        if (!document.fullscreenElement) {
          if (elem.requestFullscreen) elem.requestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
        }
      });

      document.addEventListener("fullscreenchange", () => {
        if (document.fullscreenElement) {
          btn.textContent = "⛶ Exit Fullscreen";
        } else {
          btn.textContent = "⛶ Fullscreen";
        }
      });
    }

    function update(time, delta) {
      if (!player) return;

      // Detect just-pressed A
      const justPressedA = inputState.A && !prevA;

      // If art overlay is open, ignore movement & only listen for A to close
      if (artOpen) {
        if (justPressedA) {
          closeArtOverlay();
        }
        prevA = inputState.A;
        return;
      }

      const speed = 90;
      const dt = delta / 1000;

      let dx = 0;
      let dy = 0;

      if (inputState.left) dx -= 1;
      if (inputState.right) dx += 1;
      if (inputState.up) dy -= 1;
      if (inputState.down) dy += 1;

      if (dx !== 0 && dy !== 0) {
        const inv = 1 / Math.sqrt(2);
        dx *= inv;
        dy *= inv;
      }

      player.x += dx * speed * dt;
      player.y += dy * speed * dt;

      // Bounds use the CURRENT viewer size so the square can reach all edges
      const margin = 40;
      const w = this.scale.width;
      const h = this.scale.height;

      player.x = Phaser.Math.Clamp(player.x, margin, w - margin);
      player.y = Phaser.Math.Clamp(player.y, margin, h - margin);

      // --- Interaction with frame ---
      if (frameRect) {
        const dist = Phaser.Math.Distance.Between(
          player.x,
          player.y,
          frameRect.x,
          frameRect.y
        );

        // Show prompt if close enough
        if (promptText) {
          promptText.setVisible(dist < 70);
        }

        // If close and A is pressed, open art overlay
        if (dist < 50 && justPressedA) {
          openArtOverlay();
        }
      }

      prevA = inputState.A;
    }

    function openArtOverlay() {
      artOpen = true;
      if (artOverlayBg) artOverlayBg.setVisible(true);
      if (artOverlayImage) artOverlayImage.setVisible(true);
      if (promptText) promptText.setVisible(false);
    }

    function closeArtOverlay() {
      artOpen = false;
      if (artOverlayBg) artOverlayBg.setVisible(false);
      if (artOverlayImage) artOverlayImage.setVisible(false);
    }

    new Phaser.Game(config);
  </script>
</body>
</html>