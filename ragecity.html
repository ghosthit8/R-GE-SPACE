<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — City Proto</title>

  <style>
    :root {
      --green: #39ff14;
      --red: #ff0033;
    }

    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* Menu button (top-right) */
    .home-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      right: 16px;
      padding: 8px 14px;
      border: 1px solid var(--green);
      border-radius: 8px;
      text-decoration: none;
      color: var(--green);
      background: transparent;
      font-weight: bold;
      text-shadow: 0 0 6px var(--green);
      z-index: 9999;
      pointer-events: auto;
    }
    .home-btn:hover {
      color: var(--red);
      border-color: var(--red);
      text-shadow: 0 0 6px var(--red);
    }

    /* Fullscreen button (top-left) */
    .fullscreen-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(57, 255, 20, 0.8);
      background: rgba(0, 0, 0, 0.85);
      color: var(--green);
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.7);
      z-index: 9999;
      pointer-events: auto;
    }
    .fullscreen-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
    }

    /* GAME BOX */
    #game-container {
      margin-top: 80px;
      margin-bottom: 8px;
      width: calc(100% - 24px);
      max-width: 720px;
      position: relative;
      height: 520px;
      border: 2px solid rgba(57, 255, 20, 0.9);
      box-shadow: 0 0 16px rgba(57, 255, 20, 0.8);
      background: #020202;
      overflow: hidden;
      margin-left: auto;
      margin-right: auto;
    }

    #game-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: rgba(57, 255, 20, 0.7);
      z-index: 1;
    }

    /* HTML overlay for image (super crisp) */
    #art-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;           /* shown when A pressed */
      align-items: center;
      justify-content: center;
      z-index: 5;              /* above game canvas, below UI buttons */
      flex-direction: column;
    }

    #art-overlay-img {
      max-width: 90%;
      max-height: 80%;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(57, 255, 20, 0.8);
    }

    #art-overlay-msg {
      width: 100%;
      text-align: center;
      font-size: 18px;
      color: var(--green);
      text-shadow: 0 0 8px var(--green);
      margin-bottom: 12px;
      display: block;
    }

    /* CONTROLS */
    .controls-overlay {
      position: fixed;
      left: 0;
      right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      z-index: 999;
      pointer-events: none;
    }

    .controls-inner {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 12px;
    }

    .dpad,
    .ab-buttons {
      pointer-events: auto;
    }

    .dpad {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 4px;
      opacity: 0.9;
    }

    .dpad button,
    .ab-buttons button {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid rgba(57, 255, 20, 0.8);
      border-radius: 12px;
      color: var(--green);
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(57, 255, 20, 0.9);
      touch-action: none;
    }

    .dpad button:active,
    .ab-buttons button:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
      background: #000;
    }

    .dpad .empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    /* A/B buttons – positioned how you wanted */
    .ab-buttons {
      position: relative;
      width: 180px;
      height: 140px;
      opacity: 0.9;
    }

    .ab-buttons button {
      position: absolute;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      font-size: 1.1rem;
    }

    .ab-buttons .btn-a::after,
    .ab-buttons .btn-b::after {
      display: block;
      font-size: 0.65rem;
      margin-top: 2px;
      letter-spacing: 2px;
    }
    .ab-buttons .btn-a::after {
      content: "A";
    }
    .ab-buttons .btn-b::after {
      content: "B";
    }

    .ab-buttons .btn-b {
      bottom: 10px;
      left: 30px;
    }
    .ab-buttons .btn-a {
      bottom: 40px;
      right: 25px;
    }

    @media (max-width: 600px) {
      #game-container {
        height: 480px;
      }
      .dpad {
        grid-template-columns: 52px 52px 52px;
        grid-template-rows: 52px 52px 52px;
      }
      .ab-buttons button {
        width: 56px;
        height: 56px;
      }
    }
  </style>
</head>
<body>
  <a class="home-btn" href="./menu.html">← Menu</a>

  <button id="btn-fullscreen" class="fullscreen-btn">⛶ Fullscreen</button>

  <div id="game-container">
    <div id="game-fallback">Loading Rage City…</div>

    <!-- HTML overlay for big, sharp image -->
    <div id="art-overlay">
      <div id="art-overlay-msg">Press "A" for fullscreen</div>
      <img
        id="art-overlay-img"
        src="https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=2000&q=80"
        alt="Gallery art"
      />
    </div>
  </div>

  <!-- On-screen controls -->
  <div class="controls-overlay">
    <div class="controls-inner">
      <div class="dpad">
        <button class="empty" disabled></button>
        <button id="btn-up">▲</button>
        <button class="empty" disabled></button>

        <button id="btn-left">◀</button>
        <button class="empty" disabled></button>
        <button id="btn-right">▶</button>

        <button class="empty" disabled></button>
        <button id="btn-down">▼</button>
        <button class="empty" disabled></button>
      </div>

      <div class="ab-buttons">
        <button id="btn-b" class="btn-b">●</button>
        <button id="btn-a" class="btn-a">●</button>
      </div>
    </div>
  </div>

  <!-- Phaser 3 engine -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <script>
    const inputState = {
      left: false,
      right: false,
      up: false,
      down: false,
      A: false,
      B: false
    };

    const PAINTING_FULL_URL =
      "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=2000&q=80";
    const SCULPTURE_FULL_URL =
      "https://images.unsplash.com/photo-1582719478250-c89cae4dc85b?auto=format&fit=crop&w=2000&q=80";

    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      parent: "game-container",
      pixelArt: false,
      backgroundColor: "#111122",
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      scene: {
        preload,
        create,
        update
      }
    };

    let player;
    let promptText;
    let artOpen = false;
    let prevA = false;
    let prevB = false;

    let galleryFrames = [];   // all wall paintings
    let sculptureSpot = null; // center pedestal interaction

    const artOverlayEl = document.getElementById("art-overlay");
    const artImg = document.getElementById("art-overlay-img");
    const artMsg = document.getElementById("art-overlay-msg");

    function preload() {
      // load a small thumbnail for the in-world frames
      this.load.image(
        "artThumb",
        "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=1000&q=80"
      );
    }

    function create() {
      const fb = document.getElementById("game-fallback");
      if (fb) fb.style.display = "none";

      // Smaller player
      player = this.add.rectangle(
        this.scale.width / 2,
        this.scale.height / 2 + 80,
        20,
        20,
        0x39ff14
      );

      // GALLERY ROOM LAYOUT
      const roomMarginX = 120;
      const roomMarginY = 80;
      const leftX = roomMarginX;
      const rightX = this.scale.width - roomMarginX;
      const topY = roomMarginY;
      const bottomY = this.scale.height - roomMarginY;

      // Draw white walls with a "door" gap at bottom-left
      const walls = this.add.graphics();
      walls.lineStyle(4, 0xffffff, 1);

      walls.beginPath();
      // top wall
      walls.moveTo(leftX, topY);
      walls.lineTo(rightX, topY);
      // right wall
      walls.lineTo(rightX, bottomY);
      // bottom wall (right part, leave gap near left)
      const doorGap = 100;
      walls.lineTo(leftX + doorGap, bottomY);
      // left wall (upper part, leave gap at bottom)
      walls.moveTo(leftX, bottomY - doorGap);
      walls.lineTo(leftX, topY);
      walls.strokePath();

      // Compute common thumbnail scale once
      const tex = this.textures.get("artThumb").getSourceImage();
      const natW = tex.width;
      const natH = tex.height;
      const maxThumbW = 52;
      const maxThumbH = 38;
      const thumbScale = Math.min(maxThumbW / natW, maxThumbH / natH);

      galleryFrames = [];

      const addPaintingFrame = (x, y) => {
        // outer frame (blue-ish via green glow + dark fill)
        const rect = this.add.rectangle(x, y, 70, 52);
        rect.setStrokeStyle(4, 0x39ff14, 1);

        // inner mat
        const mat = this.add.rectangle(x, y, 60, 44, 0x000000);
        mat.setStrokeStyle(2, 0x1a8f3a, 1);

        // thumbnail
        const img = this.add.image(x, y, "artThumb");
        img.setScale(thumbScale);

        galleryFrames.push({
          x,
          y,
          rect,
          mat,
          img,
          fullUrl: PAINTING_FULL_URL
        });
      };

      // TOP wall paintings
      addPaintingFrame(leftX + 40, topY + 40);
      addPaintingFrame((leftX + rightX) / 2, topY + 40);
      addPaintingFrame(rightX - 40, topY + 40);

      // RIGHT wall paintings
      addPaintingFrame(rightX - 40, (topY + bottomY) / 2 - 60);
      addPaintingFrame(rightX - 40, (topY + bottomY) / 2);
      addPaintingFrame(rightX - 40, (topY + bottomY) / 2 + 60);
      addPaintingFrame(rightX - 40, bottomY - 40);

      // LEFT wall paintings (skip lower-left gap for "door")
      addPaintingFrame(leftX + 40, (topY + bottomY) / 2 - 60);
      addPaintingFrame(leftX + 40, (topY + bottomY) / 2);
      addPaintingFrame(leftX + 40, topY + 40);

      // BOTTOM wall paintings (centered, leaving door gap to the left)
      addPaintingFrame((leftX + rightX) / 2, bottomY - 40);

      // CENTER PEDESTAL FOR SCULPTURE
      const pedestalX = (leftX + rightX) / 2;
      const pedestalY = (topY + bottomY) / 2;

      const pedestalBase = this.add.rectangle(
        pedestalX,
        pedestalY,
        80,
        80,
        0x000000
      );
      pedestalBase.setStrokeStyle(3, 0xffffff, 1);

      const pedestalTop = this.add.rectangle(
        pedestalX,
        pedestalY,
        40,
        40,
        0x111111
      );
      pedestalTop.setStrokeStyle(2, 0x39ff14, 1);

      sculptureSpot = {
        x: pedestalX,
        y: pedestalY,
        fullUrl: SCULPTURE_FULL_URL,
        type: "sculpture"
      };

      // Prompt text
      promptText = this.add.text(
        this.scale.width / 2,
        this.scale.height - 40,
        "",
        {
          fontFamily:
            "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
          fontSize: "14px",
          color: "#39ff14"
        }
      );
      promptText.setOrigin(0.5);
      promptText.setVisible(false);

      this.scale.on("resize", (gameSize) => {
        const width = gameSize.width;
        const height = gameSize.height;
        promptText.setPosition(width / 2, height - 40);
      });

      setupKeyboard(this);
      setupTouchButton("btn-left", "left");
      setupTouchButton("btn-right", "right");
      setupTouchButton("btn-up", "up");
      setupTouchButton("btn-down", "down");
      setupTouchButton("btn-a", "A");
      setupTouchButton("btn-b", "B");
      setupFullscreenButton();

      // tap anywhere on overlay to close
      artOverlayEl.addEventListener("click", () => {
        if (artOpen) closeArtOverlay();
      });
    }

    function setupKeyboard(scene) {
      scene.input.keyboard.on("keydown", function (event) {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = true;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = true;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = true;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = true;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = true;
            break;
          case "KeyX":
            inputState.B = true;
            break;
        }
      });

      scene.input.keyboard.on("keyup", function (event) {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = false;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = false;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = false;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = false;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = false;
            break;
          case "KeyX":
            inputState.B = false;
            break;
        }
      });
    }

    function setupTouchButton(id, key) {
      const el = document.getElementById(id);
      if (!el) return;

      function setPressed(pressed) {
        inputState[key] = pressed;
      }

      function start(e) {
        e.preventDefault();
        setPressed(true);
      }
      function end(e) {
        e.preventDefault();
        setPressed(false);
      }

      el.addEventListener("mousedown", start);
      el.addEventListener("mouseup", end);
      el.addEventListener("mouseleave", end);

      el.addEventListener("touchstart", start, { passive: false });
      el.addEventListener("touchend", end, { passive: false });
      el.addEventListener("touchcancel", end, { passive: false });
    }

    function setupFullscreenButton() {
      const btn = document.getElementById("btn-fullscreen");
      if (!btn) return;

      btn.addEventListener("click", () => {
        const elem = document.documentElement;
        if (!document.fullscreenElement) {
          if (elem.requestFullscreen) elem.requestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
        }
      });

      document.addEventListener("fullscreenchange", () => {
        if (document.fullscreenElement) {
          btn.textContent = "⛶ Exit Fullscreen";
        } else {
          btn.textContent = "⛶ Fullscreen";
        }
      });
    }

    function update(time, delta) {
      if (!player) return;

      const justPressedA = inputState.A && !prevA;
      const justPressedB = inputState.B && !prevB;

      // Overlay open:
      //  - A toggles fullscreen on the image
      //  - B closes the overlay (and exits fullscreen if needed)
      if (artOpen) {
        if (justPressedA) {
          toggleArtFullscreen();
        }
        if (justPressedB) {
          closeArtOverlay();
        }
        prevA = inputState.A;
        prevB = inputState.B;
        return;
      }

      const speed = 90;
      const dt = delta / 1000;

      let dx = 0;
      let dy = 0;

      if (inputState.left) dx -= 1;
      if (inputState.right) dx += 1;
      if (inputState.up) dy -= 1;
      if (inputState.down) dy += 1;

      if (dx !== 0 && dy !== 0) {
        const inv = 1 / Math.sqrt(2);
        dx *= inv;
        dy *= inv;
      }

      player.x += dx * speed * dt;
      player.y += dy * speed * dt;

      const margin = 40;
      const w = this.scale.width;
      const h = this.scale.height;

      player.x = Phaser.Math.Clamp(player.x, margin, w - margin);
      player.y = Phaser.Math.Clamp(player.y, margin, h - margin);

      // Find nearest interactive item (painting or sculpture)
      let nearestItem = null;
      let nearestDist = Infinity;

      galleryFrames.forEach((f) => {
        const d = Phaser.Math.Distance.Between(player.x, player.y, f.x, f.y);
        if (d < nearestDist) {
          nearestDist = d;
          nearestItem = {
            type: "painting",
            fullUrl: f.fullUrl
          };
        }
      });

      if (sculptureSpot) {
        const d = Phaser.Math.Distance.Between(
          player.x,
          player.y,
          sculptureSpot.x,
          sculptureSpot.y
        );
        if (d < nearestDist) {
          nearestDist = d;
          nearestItem = {
            type: "sculpture",
            fullUrl: sculptureSpot.fullUrl
          };
        }
      }

      if (promptText) {
        if (nearestItem && nearestDist < 80) {
          promptText.setVisible(true);
          if (nearestItem.type === "sculpture") {
            promptText.setText("Press A to inspect sculpture");
          } else {
            promptText.setText("Press A to view art");
          }
        } else {
          promptText.setVisible(false);
        }
      }

      if (nearestItem && nearestDist < 60 && justPressedA) {
        openArtOverlay(nearestItem.fullUrl);
      }

      prevA = inputState.A;
      prevB = inputState.B;
    }

    function openArtOverlay(imageUrl) {
      artOpen = true;
      if (imageUrl && artImg) {
        artImg.src = imageUrl;
      }
      if (artOverlayEl) artOverlayEl.style.display = "flex";
      if (promptText) promptText.setVisible(false);
      if (artMsg) artMsg.style.display = "block";
    }

    function closeArtOverlay() {
      artOpen = false;
      if (artOverlayEl) artOverlayEl.style.display = "none";
      if (artMsg) artMsg.style.display = "none";

      // if the image is currently fullscreen, exit it
      if (
        (document.fullscreenElement === artImg ||
          document.webkitFullscreenElement === artImg) &&
        (document.exitFullscreen || document.webkitExitFullscreen)
      ) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }

    function toggleArtFullscreen() {
      // hide the hint once user goes fullscreen / toggles
      if (artMsg) artMsg.style.display = "none";

      // already fullscreen → exit
      if (
        document.fullscreenElement === artImg ||
        document.webkitFullscreenElement === artImg
      ) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      } else {
        // not fullscreen → request fullscreen on the image
        if (artImg.requestFullscreen) {
          artImg.requestFullscreen();
        } else if (artImg.webkitRequestFullscreen) {
          artImg.webkitRequestFullscreen();
        }
      }
    }

    new Phaser.Game(config);
  </script>
</body>
</html>