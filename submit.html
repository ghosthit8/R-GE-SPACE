<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Rage Space ‚Äî Submit Art</title>

<link rel="preconnect" href="https://tuqvpcevrhciursxrgav.supabase.co">
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>

<style>
:root{
  --green:#39ff14; --bg:#000; --ink:#e5e5e5; --border:#153b16; --muted:#8aff8a; --card:#0b0b0b;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:760px;margin:20px auto 80px;padding:0 16px}
h1{letter-spacing:2px;text-transform:uppercase;font-size:28px;margin:24px 0 8px}
p{color:var(--muted)}
a.btn, button.btn{
  border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;
  padding:10px 14px;cursor:pointer;text-decoration:none;display:inline-block;text-align:center
}
.card{border:1px solid var(--border);border-radius:14px;background:rgba(7,7,7,.6);padding:16px;margin-top:16px}
.label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
.input, .textarea{
  width:100%;border:1px solid var(--border);border-radius:10px;background:#0b0b0b;color:var(--ink);
  padding:10px 12px;font-size:14px
}
.row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.help{font-size:12px;color:#9adf9a}
.badge{display:inline-block;border:1px solid var(--border);border-radius:8px;padding:4px 8px;margin-left:8px}
.note{font-size:12px;color:var(--muted)}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071c07;color:var(--green);border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:none;box-shadow:0 0 18px rgba(57,255,20,.18);z-index:50}
.toast.show{display:block}
.preview{margin-top:10px; display:flex; align-items:center; gap:10px;}
.preview img{max-height:90px; border-radius:10px; border:1px solid var(--border);}
.hint{font-size:12px; color:#a9f0a9}
hr.sep{border:0;border-top:1px dashed var(--border); margin:12px 0}

/* Drag & drop */
.dropzone{
  margin-top:6px; border:1.5px dashed var(--border); border-radius:14px; padding:16px;
  display:flex; align-items:center; justify-content:center; text-align:center;
  background:rgba(10,10,10,.35);
}
.dropzone strong{color:var(--ink)}
.dropzone.dragover{border-color:var(--green); box-shadow:0 0 16px rgba(57,255,20,.25);}
.dropnote{font-size:12px; color:#var(--muted); margin-top:6px}

/* Progress bar */
.progress{
  margin-top:12px; width:100%; height:10px; border-radius:999px; border:1px solid var(--border);
  background:#0a0a0a; overflow:hidden; display:none;
}
.progress .bar{
  height:100%; width:0%;
  background:linear-gradient(90deg, rgba(57,255,20,.35), rgba(57,255,20,.85));
  box-shadow:0 0 10px rgba(57,255,20,.25) inset;
  transition:width .25s ease;
}
.progress.indeterminate .bar{
  width:30%;
  animation:indet 1.2s linear infinite;
}
@keyframes indet{
  0% {transform:translateX(-100%);}
  100% {transform:translateX(300%);}
}

/* ===== Queue Modal ===== */
.modal-overlay{
  position:fixed;top:0;left:0;width:100%;height:100%;
  background:rgba(0,0,0,.8);
  display:none;align-items:center;justify-content:center;
  z-index:1000;
}
.modal{
  position:relative;
  background:rgba(10,10,10,.95);
  border:1px solid var(--border);
  border-radius:16px;
  max-width:90%;max-height:80%;
  overflow:auto;padding:20px;
}
.modal h2{margin:0 0 8px 0;font-size:20px;text-align:center}
.modal-sub{color:var(--muted);font-size:12px;text-align:center;margin-bottom:8px}
.queue-grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
  gap:12px;
  margin-top:12px;
}
.queue-item{display:flex;flex-direction:column}
.queue-item img{
  width:100%;border-radius:8px;border:1px solid var(--border);
  display:block;aspect-ratio:1/1;object-fit:cover;
}
.queue-item span{
  display:block;text-align:center;font-size:12px;margin-top:4px;word-break:break-all;
}
.modal-close{
  position:absolute;top:16px;right:20px;
  font-size:22px;cursor:pointer;color:var(--green);
}
.modal-close:hover{color:#7dff62}
</style>
</head>
<body>
  <div class="wrap">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
      <h1>Submit Art <span id="loginBadge" class="badge">checking auth‚Ä¶</span></h1>
      <div style="display:flex;gap:8px;flex-wrap:wrap;">
        <button id="viewQueueBtn" class="btn">üìú View Queue</button>
        <a class="btn" href="./menu.html">‚Üê Menu</a>
      </div>
    </div>
    <p>Upload a file (drag & drop) or paste a link to your artwork. It will be added to the queue and automatically inserted into the next tournament cycle at the Round of 32. After you submit, you‚Äôll see a confirmation message.</p>

    <div class="card">
      <!-- Dropzone + file input -->
      <div id="dropzone" class="dropzone">
        <div>
          <div><strong>Drag & drop</strong> an image here</div>
          <div class="dropnote">or click to choose a file</div>
        </div>
      </div>
      <input class="input" id="fileInput" type="file" accept="image/*" style="display:none;">
      <div class="preview" id="filePreview" style="display:none;">
        <img id="previewImg" alt="preview"/>
        <span class="hint" id="fileInfo"></span>
      </div>

      <div class="progress" id="progress"><div class="bar" id="progressBar"></div></div>

      <hr class="sep">

      <!-- URL fallback -->
      <label class="label" for="imageUrl">OR paste an Image URL</label>
      <input class="input" id="imageUrl" type="url" placeholder="https://... (jpg, png, webp, etc.)">

      <div class="row" style="margin-top:12px;">
        <div>
          <label class="label" for="title">Title (optional)</label>
          <input class="input" id="title" type="text" placeholder="Title of your piece">
        </div>
        <div>
          <label class="label" for="artist">Artist (optional)</label>
          <input class="input" id="artist" type="text" placeholder="Your name / alias">
        </div>
      </div>

      <div style="margin-top:12px;">
        <label style="display:flex;gap:10px;align-items:flex-start;">
          <input id="agree" type="checkbox">
          <span class="note">I confirm I have the rights to share this image and it follows Rage Space rules (18+, no real-death gore, no doxxing, no organized hate propaganda).</span>
        </label>
      </div>

      <div style="display:flex;gap:10px;align-items:center;margin-top:14px;">
        <button class="btn" id="btnSubmit">Submit to Queue</button>
        <span id="status" class="help"></span>
      </div>
      <div class="hint" style="margin-top:8px;">If a file is selected/dropped, we‚Äôll upload it and use that. If not, we‚Äôll use the URL.</div>
    </div>

    <div class="card" style="margin-top:18px;">
      <div style="font-weight:700;margin-bottom:6px/">How it works</div>
      <ol class="note" style="margin:0;padding-left:18px;line-height:1.5">
        <li>Your image (uploaded or linked) is stored in the queue.</li>
        <li>When the next tournament cycle begins (R32), queued pieces are randomly mapped onto the default seeds.</li>
        <li>You‚Äôll see your piece appear in the bracket thumbnails when the new cycle starts.</li>
      </ol>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <!-- Queue Modal -->
  <div class="modal-overlay" id="queueModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="queueTitle">
      <div class="modal-close" id="queueClose" title="Close">‚úñ</div>
      <h2 id="queueTitle">üñºÔ∏è Images in Queue</h2>
      <div class="modal-sub">Oldest files first ‚Üí next to be added to the tournament</div>
      <div id="queueGrid" class="queue-grid"></div>
    </div>
  </div>

<script>
/* ---------- Supabase ---------- */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* ---------- UI refs ---------- */
const loginBadge = document.getElementById('loginBadge');
const toastEl = document.getElementById('toast');
const imageUrl = document.getElementById('imageUrl');
const titleEl  = document.getElementById('title');
const artistEl = document.getElementById('artist');
const agree    = document.getElementById('agree');
const btn      = document.getElementById('btnSubmit');
const statusEl = document.getElementById('status');
const fileInput = document.getElementById('fileInput');
const filePreview = document.getElementById('filePreview');
const previewImg = document.getElementById('previewImg');
const fileInfo = document.getElementById('fileInfo');
const dropzone = document.getElementById('dropzone');
const progress = document.getElementById('progress');
const progressBar = document.getElementById('progressBar');
const viewQueueBtn = document.getElementById('viewQueueBtn');
const queueModal   = document.getElementById('queueModal');
const queueClose   = document.getElementById('queueClose');
const queueGrid    = document.getElementById('queueGrid');

/* ---------- helpers ---------- */
function toast(msg, ms=1800){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); }
async function getUid(){ const { data:{ session } } = await supabase.auth.getSession(); return session?.user?.id || null; }
function paintLoginBadge(uid){
  if (uid) { loginBadge.textContent = 'logged in'; loginBadge.style.borderColor = '#153b16'; loginBadge.style.color = 'var(--green)'; }
  else { loginBadge.textContent = 'login required'; loginBadge.style.borderColor = 'red'; loginBadge.style.color = 'red'; }
}
function bytesToMB(n){ return (n/(1024*1024)).toFixed(2); }

/* ---------- file selection & preview ---------- */
function setFile(f){
  if (!f){ fileInput.value=''; filePreview.style.display='none'; return; }
  if (!f.type.startsWith('image/')){ toast('File must be an image'); return; }
  if (f.size > 10 * 1024 * 1024){ toast('Max 10MB'); return; }

  const dt = new DataTransfer();
  dt.items.add(f);
  fileInput.files = dt.files;

  const url = URL.createObjectURL(f);
  previewImg.src = url;
  fileInfo.textContent = `${f.name} ‚Äî ${bytesToMB(f.size)} MB`;
  filePreview.style.display='flex';
}
fileInput.addEventListener('change', ()=> setFile(fileInput.files?.[0]||null));

/* ---------- drag & drop ---------- */
;['dragenter','dragover'].forEach(ev=>dropzone.addEventListener(ev, e=>{
  e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover');
}));
;['dragleave','drop'].forEach(ev=>dropzone.addEventListener(ev, e=>{
  e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover');
}));
dropzone.addEventListener('drop', e=>{
  const f = e.dataTransfer?.files?.[0];
  if (f) setFile(f);
});
dropzone.addEventListener('click', ()=> fileInput.click());

/* ---------- init ---------- */
(async()=>{
  paintLoginBadge(await getUid());
  supabase.auth.onAuthStateChange((_evt, session)=> paintLoginBadge(session?.user?.id || null));
})();

/* ---------- storage upload helper (with indeterminate progress bar) ---------- */
function showProgressIndeterminate(){
  progress.style.display='block';
  progress.classList.add('indeterminate');
  progressBar.style.width='30%';
}
function snapProgress100(){
  progress.classList.remove('indeterminate');
  progressBar.style.width='100%';
  setTimeout(()=>{ progress.style.display='none'; progressBar.style.width='0%'; }, 700);
}
async function uploadToStorage(uid, file){
  const today = new Date();
  const yyyy = today.getUTCFullYear();
  const mm = String(today.getUTCMonth()+1).padStart(2,'0');
  const dd = String(today.getUTCDate()).padStart(2,'0');
  const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g,'_');
  const path = `${uid}/${yyyy}/${mm}/${dd}/${crypto.randomUUID()}-${safeName}`;

  showProgressIndeterminate();

  const { error:upErr } = await supabase.storage.from('art-uploads').upload(path, file, {
    contentType: file.type || 'application/octet-stream',
    cacheControl: '3600',
    upsert: false
  });
  if (upErr) { progress.style.display='none'; throw upErr; }

  const { data } = supabase.storage.from('art-uploads').getPublicUrl(path);
  if (!data?.publicUrl) { progress.style.display='none'; throw new Error('No public URL returned'); }

  snapProgress100();
  return data.publicUrl;
}

/* ---------- submit ---------- */
btn.addEventListener('click', async ()=>{
  statusEl.textContent = '';

  const uid = await getUid();
  if (!uid){
    toast('You must be logged in to submit art');
    statusEl.textContent = 'Login required.';
    return;
  }
  if (!agree.checked){ return toast('Please confirm rights & rules'); }

  let finalUrl = (imageUrl.value||'').trim();
  const file = fileInput.files?.[0];

  try{
    if (file){
      if (!file.type.startsWith('image/')){ return toast('File must be an image'); }
      if (file.size > 10*1024*1024){ return toast('Max 10MB'); }
      toast('Uploading image‚Ä¶');
      finalUrl = await uploadToStorage(uid, file);
    }

    if (!finalUrl){ return toast('Select a file or paste an image URL'); }
    if (!/^https?:\/\//i.test(finalUrl)){ return toast('URL must start with http(s)://'); }

    const title = (titleEl.value||'').trim();
    const artist = (artistEl.value||'').trim();

    /* user_id removed ‚Äî DB trigger stamps auth.uid() */
    const { error } = await supabase.from('art_queue').insert({
      image_url: finalUrl,
      title,
      artist,
      status: 'pending'
    });
    if (error) throw error;

    imageUrl.value=''; titleEl.value=''; artistEl.value=''; agree.checked=false;
    if (fileInput.value) fileInput.value='';
    filePreview.style.display='none';

    toast('Your art is added to the queue ‚úÖ');
    statusEl.textContent = 'Submitted!';
  }catch(e){
    console.error('Submit error:', e);
    const msg = e?.message || e?.error_description || 'Submit failed';
    toast(msg);
    statusEl.textContent = msg;
  }
});

/* =========================
   üìú View Queue (Storage)
   ========================= */
const BUCKET = 'art-uploads';

// Get a URL for a file (public if possible, otherwise signed)
async function fileUrl(path){
  // Try public URL
  const pub = supabase.storage.from(BUCKET).getPublicUrl(path);
  if (pub?.data?.publicUrl) return pub.data.publicUrl;

  // Fallback: signed URL for 1 hour
  const { data, error } = await supabase.storage.from(BUCKET).createSignedUrl(path, 3600);
  if (error) throw error;
  return data.signedUrl;
}

// List files at a prefix, sorted by updated_at asc
async function listAt(prefix=""){
  const { data, error } = await supabase
    .storage
    .from(BUCKET)
    .list(prefix, {
      limit: 1000,
      sortBy: { column: 'updated_at', order: 'asc' }
    });
  if (error) throw error;
  return (data || []).filter(item => !item.metadata?.isDirectory && item.name);
}

// Load from root and optional "queue/" folder, merge & sort by updated_at
async function loadQueueFiles(){
  const [root, queue] = await Promise.allSettled([listAt(""), listAt("queue")]);
  const files = []
    .concat(root.status === 'fulfilled' ? root.value : [])
    .concat(queue.status === 'fulfilled' ? queue.value : []);

  // Deduplicate by (prefix + name) if possible
  const seen = new Set();
  const deduped = [];
  for (const f of files){
    const key = f.id || f.name;
    if (seen.has(key)) continue;
    seen.add(key);
    deduped.push(f);
  }

  // Build display objects; try both root and queue/ as candidates
  const out = [];
  for (const f of deduped){
    const candidates = [f.name, `queue/${f.name}`];
    let url = null, used = null;
    for (const p of candidates){
      try { url = await fileUrl(p); used = p; break; } catch(_) {}
    }
    if (!url) continue;
    out.push({
      path: used,
      name: f.name,
      updated_at: f.updated_at || '',
      url
    });
  }

  out.sort((a,b)=> new Date(a.updated_at||0) - new Date(b.updated_at||0));
  return out;
}

viewQueueBtn.addEventListener('click', async ()=>{
  queueModal.style.display = 'flex';
  queueModal.setAttribute('aria-hidden','false');
  queueGrid.innerHTML = '<div class="note" style="grid-column:1/-1;text-align:center;">Loading‚Ä¶</div>';

  try {
    const items = await loadQueueFiles();
    if (!items.length){
      queueGrid.innerHTML = '<div class="note" style="grid-column:1/-1;text-align:center;">No images in queue.</div>';
      return;
    }
    queueGrid.innerHTML = items.map((img, i)=>`
      <div class="queue-item" title="${img.path}">
        <img src="${img.url}" alt="${img.name}"/>
        <span>#${i+1} ‚Äî ${img.name}</span>
      </div>
    `).join('');
  } catch (e) {
    console.error(e);
    queueGrid.innerHTML = '<div class="note" style="grid-column:1/-1;text-align:center;">Failed to load queue.</div>';
  }
});

queueClose.addEventListener('click', ()=>{
  queueModal.style.display = 'none';
  queueModal.setAttribute('aria-hidden','true');
});
</script>

<!--
Storage bucket must exist: art-uploads (public read or signed URLs).
DB must have: trigger that sets user_id := auth.uid() on art_queue inserts,
and the authenticated INSERT policy with a non-null WITH CHECK expression.
-->
<style>
  .rs-debug {
    position: fixed; right: 10px; bottom: 10px; z-index: 99999;
    background: rgba(0,0,0,.85); border: 1px solid #153b16; border-radius: 12px;
    padding: 10px 12px; color: #39ff14; font: 12px/1.2 system-ui, Arial, sans-serif;
    box-shadow: 0 0 16px rgba(57,255,20,.15);
  }
  .rs-debug b { color: #b3ffb3 }
  .rs-debug button {
    margin-top: 6px; width: 100%; border: 1px solid #39ff14; background: transparent;
    color: #39ff14; border-radius: 10px; padding: 6px 8px; cursor: pointer;
  }
</style>

<div class="rs-debug">
  <div>BASE: <b id="rsBaseKey">‚Ä¶</b></div>
  <div>STAGE: <b id="rsStage">‚Ä¶</b></div>
  <button id="rsForce">Force Inject R32</button>
  <div id="rsMsg" style="margin-top:6px;opacity:.9"></div>
</div>

<script>
(function(){
  const msg = (t)=>{ document.getElementById('rsMsg').textContent = t; };

  function showKeys(){
    try {
      document.getElementById('rsBaseKey').textContent = window.currentPhaseKey || '(unknown)';
      document.getElementById('rsStage').textContent   = window.currentStage || '(unknown)';
    } catch(e){ console.warn(e); }
  }

  // Safety: warm injections & repaint if we‚Äôre already in R32 when the page loads
  async function warmIfR32(){
    try{
      if (typeof currentStage !== 'undefined' &&
          currentStage === 'r32' &&
          typeof currentPhaseKey !== 'undefined' &&
          typeof ensureR32InjectionsFor === 'function') {
        await ensureR32InjectionsFor(currentPhaseKey);
        if (typeof paintImagesForActive === 'function') await paintImagesForActive();
        if (typeof renderBracket === 'function') await renderBracket();
      }
    }catch(e){ console.error('warmIfR32 failed', e); }
  }

  // Force-inject handler (skips claim; just assigns now)
  async function forceInject(){
    try{
      if (typeof currentPhaseKey === 'undefined') return msg('No base key yet.');
      // If your integrator functions exist, use them
      if (typeof assignQueuedToR32 === 'function') {
        msg('Assigning from queue‚Ä¶');
        await assignQueuedToR32(currentPhaseKey);
        await ensureR32InjectionsFor(currentPhaseKey);
        if (typeof paintImagesForActive === 'function') await paintImagesForActive();
        if (typeof renderBracket === 'function') await renderBracket();
        msg('Done. Check R32.');
        return;
      }
      // Fallback: do a minimal inline assignment (oldest pending -> r32_1)
      if (typeof supabase === 'undefined') return msg('Supabase not ready.');
      msg('Assigning (fallback)‚Ä¶');
      const { data: q } = await supabase.from('art_queue')
        .select('id,image_url').eq('status','pending').order('created_at',{ascending:true}).limit(1);
      if (!q || !q.length) return msg('Queue empty.');
      const row = q[0];
      await supabase.from('art_injections').upsert({
        base_iso: currentPhaseKey, slot: 'r32_1',
        submission_id: row.id, image_url: row.image_url
      });
      await supabase.from('art_queue').update({ status:'used', used_at: new Date().toISOString() }).eq('id', row.id);
      if (typeof paintImagesForActive === 'function') await paintImagesForActive();
      if (typeof renderBracket === 'function') await renderBracket();
      msg('Injected into r32_1.');
    }catch(e){
      console.error(e);
      msg(e?.message || 'Failed.');
    }
  }

  document.getElementById('rsForce').addEventListener('click', forceInject);
  showKeys();
  warmIfR32();

  // If your app updates stage/base later, keep badge fresh
  setInterval(showKeys, 1500);
})();
</script>
</body>
</html>