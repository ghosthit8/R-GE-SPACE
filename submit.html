<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RAGE SPACE — Submit</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-main: #05060a;
      --bg-panel: #0b0d13;
      --accent: #39ff14;
      --accent-soft: rgba(57, 255, 20, 0.18);
      --accent-strong: rgba(57, 255, 20, 0.45);
      --accent-red: #ff0033;
      --border-subtle: #1b1e2a;
      --text-main: #e3e7ff;
      --text-soft: #9ba0c2;
      --danger: #ff2757;
      --danger-soft: rgba(255, 39, 87, 0.18);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111322 0, #020308 55%);
      color: var(--text-main);
      -webkit-font-smoothing: antialiased;
    }

    .page {
      max-width: 1080px;
      margin: 0 auto;
      padding: 16px 12px 32px;
    }

    @media (min-width: 768px) {
      .page {
        padding: 24px 16px 40px;
      }
    }

    .headline {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 12px;
    }

    .headline-row {
      display: flex;
      align-items: baseline;
      gap: 8px;
      flex-wrap: wrap;
    }

    .headline-title {
      font-size: 1.4rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .headline-pill {
      font-size: 0.7rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      color: var(--accent);
      background: radial-gradient(circle at top, var(--accent-soft), transparent);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .headline-sub {
      font-size: 0.8rem;
      color: var(--text-soft);
      letter-spacing: 0.04em;
      max-width: 520px;
    }

    .layout {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (min-width: 880px) {
      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
        gap: 18px;
        align-items: flex-start;
      }
    }

    .panel {
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background:
        linear-gradient(to bottom, rgba(255, 255, 255, 0.02), transparent 140px),
        radial-gradient(circle at top left, rgba(57, 255, 20, 0.08), transparent 55%),
        radial-gradient(circle at bottom right, rgba(255, 0, 51, 0.08), transparent 55%),
        var(--bg-panel);
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image: linear-gradient(
        rgba(255, 255, 255, 0.05) 1px,
        transparent 1px
      );
      background-size: 100% 24px;
      mix-blend-mode: soft-light;
      opacity: 0.16;
      pointer-events: none;
    }

    .panel-body {
      position: relative;
      padding: 14px 12px 14px;
    }

    @media (min-width: 768px) {
      .panel-body {
        padding: 16px 14px 16px;
      }
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
    }

    .panel-title-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .panel-kicker {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--accent);
      opacity: 0.95;
    }

    .panel-title {
      font-size: 0.95rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
    }

    .panel-caption {
      font-size: 0.7rem;
      color: var(--text-soft);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .timer-pill {
      font-size: 0.8rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid rgba(57, 255, 20, 0.5);
      color: var(--accent);
      background: radial-gradient(circle at top, rgba(57, 255, 20, 0.21), transparent);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .timer-pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 6px rgba(57, 255, 20, 0.9);
    }

    .timer-pill-value {
      font-feature-settings: "tnum" 1, "lnum" 1;
    }

    .timer-pill-label {
      opacity: 0.8;
    }

    .form-grid {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    @media (min-width: 720px) {
      .form-grid {
        gap: 12px;
      }
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .field-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .field-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-soft);
    }

    .field-tag {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(155, 160, 194, 0.6);
      color: var(--text-soft);
      opacity: 0.9;
    }

    .field-help {
      font-size: 0.7rem;
      color: var(--text-soft);
      opacity: 0.9;
    }

    .input-shell {
      position: relative;
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top left, rgba(57, 255, 20, 0.12), transparent 60%);
      padding: 8px 9px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-shell.danger {
      border-color: var(--danger);
      box-shadow: 0 0 0 1px var(--danger-soft);
    }

    .input-shell.danger .field-help-inline {
      color: var(--danger);
    }

    .input-shell input[type="text"],
    .input-shell textarea {
      flex: 1;
      min-width: 0;
      border: none;
      background: transparent;
      color: var(--text-main);
      font-size: 0.85rem;
      font-family: inherit;
      outline: none;
    }

    .input-shell textarea {
      resize: vertical;
      min-height: 52px;
      max-height: 160px;
    }

    .input-prefix {
      font-size: 0.75rem;
      color: var(--text-soft);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .input-suffix {
      font-size: 0.75rem;
      color: var(--text-soft);
      white-space: nowrap;
    }

    .input-shell input::placeholder,
    .input-shell textarea::placeholder {
      color: rgba(155, 160, 194, 0.7);
    }

    .file-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .file-input {
      position: relative;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border-radius: 999px;
      padding: 6px 12px;
      border: 1px solid rgba(57, 255, 20, 0.8);
      background: radial-gradient(circle at top, rgba(57, 255, 20, 0.2), transparent 65%);
      color: var(--accent);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      cursor: pointer;
    }

    .file-input input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .file-meta {
      font-size: 0.7rem;
      color: var(--text-soft);
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .file-chip {
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(155, 160, 194, 0.6);
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    .file-name {
      font-size: 0.7rem;
      color: var(--text-main);
    }

    .file-size-badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      color: var(--text-soft);
    }

    .file-size-badge.too-big {
      border-color: var(--danger);
      color: var(--danger);
      background: var(--danger-soft);
    }

    .field-help-inline {
      font-size: 0.7rem;
      color: var(--text-soft);
    }

    .field-help-inline strong {
      color: var(--accent);
      font-weight: 600;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .btn-primary {
      border-radius: 999px;
      padding: 8px 18px;
      font-size: 0.8rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      border: 1px solid rgba(57, 255, 20, 0.8);
      background: radial-gradient(circle at top, rgba(57, 255, 20, 0.4), transparent 70%), #050707;
      color: var(--accent);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .btn-primary::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        120deg,
        transparent 0%,
        rgba(255, 255, 255, 0.25) 35%,
        rgba(255, 255, 255, 0.18) 50%,
        transparent 75%
      );
      transform: translateX(-120%);
      transition: transform 0.6s ease-out;
      pointer-events: none;
    }

    .btn-primary:hover::before {
      transform: translateX(25%);
    }

    .btn-primary[disabled] {
      opacity: 0.45;
      cursor: default;
    }

    .btn-primary .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.9);
    }

    .btn-primary-label {
      font-weight: 600;
    }

    .btn-secondary {
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.75rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      border: 1px dashed rgba(155, 160, 194, 0.7);
      background: rgba(2, 3, 8, 0.9);
      color: var(--text-soft);
      cursor: pointer;
    }

    .status-line {
      margin-top: 8px;
      font-size: 0.7rem;
      color: var(--text-soft);
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .status-chip {
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.65rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      border: 1px solid var(--border-subtle);
      color: var(--text-soft);
    }

    .status-chip.good {
      border-color: rgba(57, 255, 20, 0.8);
      color: var(--accent);
      background: var(--accent-soft);
    }

    .status-chip.bad {
      border-color: var(--danger);
      color: var(--danger);
      background: var(--danger-soft);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(155, 160, 194, 0.9);
    }

    .status-dot.good {
      background: var(--accent);
      box-shadow: 0 0 6px rgba(57, 255, 20, 0.9);
    }

    .status-dot.bad {
      background: var(--danger);
      box-shadow: 0 0 6px rgba(255, 39, 87, 0.9);
    }

    .queue-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
    }

    .queue-title-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .queue-kicker {
      font-size: 0.65rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .queue-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
    }

    .queue-meta {
      font-size: 0.7rem;
      color: var(--text-soft);
    }

    .queue-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    @media (min-width: 520px) {
      .queue-grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    @media (min-width: 992px) {
      .queue-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    .queue-tile {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(155, 160, 194, 0.25);
      background: #05060a;
      aspect-ratio: 3 / 4;
    }

    .queue-thumb {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .queue-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(
        to top,
        rgba(0, 0, 0, 0.85),
        rgba(0, 0, 0, 0.2),
        transparent
      );
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding: 4px 5px;
      gap: 2px;
    }

    .queue-meta-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 2px;
    }

    .queue-username {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--accent);
      max-width: 66%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .queue-age {
      font-size: 0.7rem;
      color: var(--text-soft);
      font-feature-settings: "tnum" 1, "lnum" 1;
      white-space: nowrap;
    }

    .queue-title-text {
      font-size: 0.7rem;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .queue-empty {
      font-size: 0.75rem;
      color: var(--text-soft);
      padding: 6px 2px 2px;
    }

    .queue-empty strong {
      color: var(--accent);
      font-weight: 600;
    }

    .queue-count-chip {
      border-radius: 999px;
      border: 1px solid rgba(155, 160, 194, 0.6);
      font-size: 0.7rem;
      padding: 2px 8px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .queue-count-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(57, 255, 20, 0.9);
      box-shadow: 0 0 6px rgba(57, 255, 20, 0.9);
    }

    .queue-footer {
      margin-top: 7px;
      font-size: 0.7rem;
      color: var(--text-soft);
      display: flex;
      flex-wrap: wrap;
      gap: 4px 10px;
      align-items: center;
      justify-content: space-between;
    }

    .queue-footer small {
      opacity: 0.9;
    }

    .queue-footer strong {
      color: var(--accent);
      font-weight: 600;
    }

    .marquee {
      margin-top: 6px;
      border-radius: 999px;
      border: 1px solid rgba(155, 160, 194, 0.6);
      padding: 4px 8px;
      font-size: 0.7rem;
      color: var(--text-soft);
      text-transform: uppercase;
      letter-spacing: 0.16em;
      display: flex;
      align-items: center;
      gap: 8px;
      overflow: hidden;
      position: relative;
    }

    .marquee-glow {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(57, 255, 20, 0.9);
      flex: 0 0 auto;
    }

    .marquee-track {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .marquee strong {
      color: var(--accent);
      font-weight: 600;
    }

    .hint {
      margin-top: 6px;
      font-size: 0.7rem;
      color: var(--text-soft);
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .danger-text {
      color: var(--danger);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="headline">
      <div class="headline-row">
        <div class="headline-title">RAGE SPACE</div>
        <div class="headline-pill">
          <span>Queue Upload Node</span>
        </div>
      </div>
      <div class="headline-sub">
        Drop a piece into the global bracket machine. Submissions that clear the gate
        will be fed into the next RAGE SPACE tournament cycle.
      </div>
    </header>

    <main class="layout">
      <section class="panel">
        <div class="panel-body">
          <div class="panel-header">
            <div class="panel-title-group">
              <div class="panel-kicker">Submission Gate</div>
              <div class="panel-title">Feed the Machine</div>
            </div>
            <div class="timer-pill" id="phaseTimerPill">
              <span class="timer-pill-dot"></span>
              <span class="timer-pill-label">Next Tournament In</span>
              <span class="timer-pill-value" id="clock">--</span>
            </div>
          </div>

          <form id="submitForm" class="form-grid">
            <div class="field">
              <div class="field-row">
                <label class="field-label" for="pieceTitle">Piece Title</label>
                <span class="field-tag">Shown on Winners</span>
              </div>
              <div class="input-shell">
                <span class="input-prefix">Title</span>
                <input
                  id="pieceTitle"
                  type="text"
                  name="pieceTitle"
                  maxlength="120"
                  placeholder="Fine / cursed / unhinged… give it a name."
                  autocomplete="off"
                />
              </div>
              <div class="field-help">
                Optional, but recommended. Max 120 characters.
              </div>
            </div>

            <div class="field">
              <div class="field-row">
                <label class="field-label" for="pieceDescription">Piece Description</label>
                <span class="field-tag">Shown on Winners</span>
              </div>
              <div class="input-shell">
                <span class="input-prefix">Lore</span>
                <textarea
                  id="pieceDescription"
                  name="pieceDescription"
                  maxlength="500"
                  placeholder="Backstory, process, or threats to rival artists. Keep it under 500 characters."
                ></textarea>
              </div>
              <div class="field-help">
                Optional. Show up on the winners page if your art survives the bracket.
              </div>
            </div>

            <div class="field">
              <div class="field-row">
                <span class="field-label">File</span>
                <span class="field-tag">50 MB Max</span>
              </div>
              <div class="input-shell" id="fileShell">
                <div class="file-row">
                  <label class="file-input">
                    <span>Attach File</span>
                    <input
                      id="fileInput"
                      name="file"
                      type="file"
                      accept="image/*,video/*"
                      required
                    />
                  </label>
                  <div class="file-meta">
                    <span class="file-chip">Images + Video</span>
                    <span class="file-name" id="fileName">No file selected</span>
                    <span class="file-size-badge" id="fileSizeBadge">Max 50MB</span>
                  </div>
                </div>
              </div>
              <div class="field-help">
                Images or video up to 50 MB. If your connection is slow, the upload may take a bit.
              </div>
            </div>

            <div class="field">
              <div class="field-row">
                <span class="field-label">Direct URL (Optional)</span>
                <span class="field-tag">Bypass Upload</span>
              </div>
              <div class="input-shell">
                <span class="input-prefix">URL</span>
                <input
                  id="directUrl"
                  type="text"
                  name="directUrl"
                  placeholder="https://… (use if your piece already lives online)"
                  autocomplete="off"
                />
              </div>
              <div class="field-help">
                If set, this URL will be used instead of the uploaded file. Make sure it's a direct image or video URL.
              </div>
            </div>

            <div class="btn-row">
              <button
                type="submit"
                id="submitBtn"
                class="btn-primary"
              >
                <span class="dot"></span>
                <span class="btn-primary-label">Submit to Queue</span>
              </button>
              <button
                type="button"
                id="resetBtn"
                class="btn-secondary"
              >
                Reset Fields
              </button>
            </div>

            <div class="status-line">
              <span class="status-dot" id="statusDot"></span>
              <span id="statusText">Idle. File not yet staged.</span>
              <span id="statusChip" class="status-chip">
                Waiting for input
              </span>
            </div>
          </form>

          <div class="hint">
            Your submission is tied to your RAGE SPACE profile. If your piece wins a tournament,
            your username, title, and description are immortalized on the winners page.
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panel-body">
          <div class="queue-header">
            <div class="queue-title-group">
              <div class="queue-kicker">Global Queue</div>
              <div class="queue-title">Loaded Into The Machine</div>
            </div>
            <div class="queue-count-chip" id="queueCountChip">
              <span class="queue-count-dot"></span>
              <span id="queueCountLabel">0 in queue</span>
            </div>
          </div>

          <div class="queue-meta" id="queueMeta">
            Showing the next batch of pending pieces waiting to be drafted into the bracket.
          </div>

          <div id="queueGrid" class="queue-grid"></div>
          <div id="queueEmpty" class="queue-empty">
            No pending pieces yet. <strong>Submit something cursed.</strong>
          </div>

          <div class="queue-footer">
            <small>
              Tiles are approximate; final cropping happens inside the bracket itself.
            </small>
            <small>
              <strong>Queue refreshes every tournament cycle.</strong>
            </small>
          </div>

          <div class="marquee">
            <div class="marquee-glow"></div>
            <div class="marquee-track" id="marqueeText">
              RAGE SPACE IS AN EXPERIMENTAL ART ARENA · QUEUE IS SUBJECT TO MODERATION · NO MINORS, REAL-DEATH GORE, OR DOXXING · VIOLATIONS ARE PURGED
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    import {
      createClient
    } from "https://esm.sh/@supabase/supabase-js@2.48.0";

    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
      },
    });

    const MAX_MB = 50;
    const MAX_BYTES = MAX_MB * 1024 * 1024;

    const formEl = document.getElementById("submitForm");
    const fileInput = document.getElementById("fileInput");
    const directUrlInput = document.getElementById("directUrl");
    const fileNameEl = document.getElementById("fileName");
    const fileSizeBadge = document.getElementById("fileSizeBadge");
    const fileShell = document.getElementById("fileShell");
    const submitBtn = document.getElementById("submitBtn");
    const resetBtn = document.getElementById("resetBtn");

    const pieceTitleEl = document.getElementById("pieceTitle");
    const pieceDescEl = document.getElementById("pieceDescription");

    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const statusChip = document.getElementById("statusChip");

    const clockEl = document.getElementById("clock");
    const timerPill = document.getElementById("phaseTimerPill");

    const queueGrid = document.getElementById("queueGrid");
    const queueEmpty = document.getElementById("queueEmpty");
    const queueCountChip = document.getElementById("queueCountChip");
    const queueCountLabel = document.getElementById("queueCountLabel");
    const queueMeta = document.getElementById("queueMeta");

    let currentFile = null;
    let fileTooBig = false;
    let currentUser = null;

    function setStatus(mode, text) {
      statusText.textContent = text;

      if (mode === "idle") {
        statusDot.className = "status-dot";
        statusChip.className = "status-chip";
        statusChip.textContent = "Waiting for input";
      } else if (mode === "ready") {
        statusDot.className = "status-dot good";
        statusChip.className = "status-chip good";
        statusChip.textContent = "Ready to submit";
      } else if (mode === "uploading") {
        statusDot.className = "status-dot good";
        statusChip.className = "status-chip";
        statusChip.textContent = "Uploading…";
      } else if (mode === "error") {
        statusDot.className = "status-dot bad";
        statusChip.className = "status-chip bad";
        statusChip.textContent = "Error";
      } else if (mode === "success") {
        statusDot.className = "status-dot good";
        statusChip.className = "status-chip good";
        statusChip.textContent = "Submitted";
      }
    }

    setStatus("idle", "Idle. File not yet staged.");

    function formatBytes(bytes) {
      if (!Number.isFinite(bytes)) return "";
      if (bytes >= 1024 * 1024 * 0.5) {
        const mb = bytes / (1024 * 1024);
        return mb.toFixed(mb >= 10 ? 0 : 1) + " MB";
      }
      const kb = bytes / 1024;
      return kb.toFixed(0) + " KB";
    }

    function handleFileChange() {
      const file = fileInput.files[0] || null;
      currentFile = file;
      fileTooBig = false;
      fileShell.classList.remove("danger");

      if (!file) {
        fileNameEl.textContent = "No file selected";
        fileSizeBadge.textContent = `Max ${MAX_MB}MB`;
        fileSizeBadge.classList.remove("too-big");
        setStatus("idle", "Idle. File not yet staged.");
        return;
      }

      fileNameEl.textContent = file.name;
      const sizeText = formatBytes(file.size);
      fileSizeBadge.textContent = sizeText || "";
      fileTooBig = file.size > MAX_BYTES;

      if (fileTooBig) {
        fileSizeBadge.classList.add("too-big");
        fileShell.classList.add("danger");
        setStatus(
          "error",
          `File is too large (${sizeText}). Max size is ${MAX_MB}MB.`
        );
      } else {
        fileSizeBadge.classList.remove("too-big");
        setStatus(
          "ready",
          `File staged: ${file.type || "unknown type"} (${sizeText}).`
        );
      }
    }

    fileInput.addEventListener("change", handleFileChange);

    resetBtn.addEventListener("click", () => {
      formEl.reset();
      currentFile = null;
      fileTooBig = false;
      fileShell.classList.remove("danger");
      fileNameEl.textContent = "No file selected";
      fileSizeBadge.textContent = `Max ${MAX_MB}MB`;
      fileSizeBadge.classList.remove("too-big");
      setStatus("idle", "Idle. File not yet staged.");
    });

    async function ensureAuth() {
      const { data, error } = await supabase.auth.getUser();
      if (error || !data?.user) {
        setStatus("error", "You must be signed in to submit.");
        throw new Error("Not authenticated");
      }
      currentUser = data.user;
      return data.user;
    }

    async function fetchUsername(userId) {
      try {
        const { data, error } = await supabase
          .from("profiles")
          .select("username")
          .eq("id", userId)
          .maybeSingle();

        if (error) {
          console.warn("[SUBMIT] Failed to fetch username:", error);
          return null;
        }

        return data?.username ?? null;
      } catch (err) {
        console.warn("[SUBMIT] Username lookup threw:", err);
        return null;
      }
    }

    async function uploadToStorage(file, user) {
      if (!file) return null;

      const safeName = file.name.replace(/[^a-zA-Z0-9.\-_]/g, "_");
      const ext = safeName.split(".").pop() || "bin";
      const timestamp = Date.now();
      const userId = user?.id || "anon";
      const path = `${userId}/${timestamp}-${Math.random()
        .toString(36)
        .slice(2)}.${ext}`;

      const { data, error } = await supabase.storage
        .from("art-uploads")
        .upload(path, file, {
          cacheControl: "3600",
          upsert: false,
        });

      if (error) {
        console.error("[SUBMIT] storage.upload error:", error);
        throw error;
      }

      const { data: publicData } = supabase.storage
        .from("art-uploads")
        .getPublicUrl(data?.path || path);

      return {
        publicUrl: publicData?.publicUrl || null,
        path: data?.path || path,
      };
    }

    async function handleSubmit(evt) {
      evt.preventDefault();

      try {
        const user = await ensureAuth();
        if (!user) return;

        if (!currentFile && !directUrlInput.value.trim()) {
          setStatus("error", "You need to attach a file or set a direct URL.");
          return;
        }

        if (fileTooBig) {
          setStatus(
            "error",
            `File is too large. Max size is ${MAX_MB}MB.`
          );
          return;
        }

        submitBtn.disabled = true;
        setStatus("uploading", "Uploading / registering your piece…");

        let publicData = null;
        let pickedUrl = directUrlInput.value.trim() || null;

        if (!pickedUrl) {
          publicData = await uploadToStorage(currentFile, user);
          pickedUrl = publicData?.publicUrl || null;
        }

        if (!pickedUrl) {
          throw new Error("Failed to determine final URL for piece.");
        }

        const finalUrl =
          pickedUrl ||
          publicData?.publicUrl ||
          publicData?.path ||
          null;

        if (!finalUrl) {
          throw new Error("Final URL is empty after upload.");
        }

        const pieceTitle = pieceTitleEl.value.trim() || null;
        const pieceDesc = pieceDescEl.value.trim() || null;

        let artistName = await fetchUsername(user.id);
        if (!artistName) {
          artistName = user.user_metadata?.username || null;
        }
        if (!artistName) {
          const email = user.email || "";
          artistName = email.includes("@") ? email.split("@")[0] : "unknown";
        }

        const payload = {
          image_url: finalUrl,
          status: "pending",
          created_by: user.id,
          artist_name: artistName,
          piece_title: pieceTitle,
          piece_description: pieceDesc,
        };

        console.log("[SUBMIT] inserting into art_queue:", payload);

        const { data: insertData, error: insertError } = await supabase
          .from("art_queue")
          .insert(payload)
          .select("id, image_url, status, created_at, artist_name, piece_title");

        if (insertError) {
          console.error("[SUBMIT] art_queue insert error:", insertError);
          throw insertError;
        }

        console.log("[SUBMIT] art_queue insert success:", insertData);

        setStatus(
          "success",
          "Submitted to queue. Watch the tournament to see it get drafted."
        );

        if (insertData && insertData[0]) {
          renderQueueItems([insertData[0]], queueGrid);
          queueEmpty.style.display = "none";
        }

        formEl.reset();
        currentFile = null;
        fileTooBig = false;
        fileShell.classList.remove("danger");
        fileNameEl.textContent = "No file selected";
        fileSizeBadge.textContent = `Max ${MAX_MB}MB`;
        fileSizeBadge.classList.remove("too-big");
      } catch (err) {
        console.error("[SUBMIT] handleSubmit error:", err);
        setStatus("error", err.message || "Failed to submit piece.");
      } finally {
        submitBtn.disabled = false;
      }
    }

    formEl.addEventListener("submit", handleSubmit);

    function formatRemaining(sec) {
      if (!Number.isFinite(sec) || sec < 0) return "--";
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      const mm = m.toString().padStart(2, "0");
      const ss = s.toString().padStart(2, "0");
      return `${mm}:${ss}`;
    }

    let lastClockValue = null;

    async function fetchTimerState() {
      try {
        const res = await fetch(
          `${SUPABASE_URL}/functions/v1/global-timer-v2`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
            },
          }
        );

        const raw = await res.json();
        console.log("[TIMER] raw edge payload", raw);

        const normalized = raw?.normalized || raw;
        const remaining = normalized?.remaining_sec ?? null;

        clockEl.textContent = formatRemaining(remaining);

        if (typeof remaining === "number") {
          if (remaining <= 15) {
            timerPill.style.borderColor = "var(--accent-red)";
            timerPill.style.color = "var(--accent-red)";
          } else {
            timerPill.style.borderColor = "rgba(57, 255, 20, 0.5)";
            timerPill.style.color = "var(--accent)";
          }

          if (lastClockValue != null && remaining > lastClockValue && remaining > 5) {
            console.log("[QUEUE] round start detected — refreshing queue");
            await renderQueue();
          }

          lastClockValue = remaining;
        } else {
          clockEl.textContent = "--";
        }
      } catch (err) {
        console.error("[TIMER] fetchTimerState error:", err);
        clockEl.textContent = "--";
      }
    }

    setInterval(fetchTimerState, 1000);
    fetchTimerState();

    function renderQueueItems(items, gridEl) {
      if (!Array.isArray(items) || !gridEl) return;
      if (!items.length) return;

      for (const item of items) {
        const existing = gridEl.querySelector(`[data-id="${item.id}"]`);
        if (existing) existing.remove();
      }

      for (const row of items) {
        if (!row?.image_url) continue;

        const host = document.createElement("div");
        host.className = "queue-tile";
        host.dataset.id = row.id;

        const img = document.createElement("img");
        img.className = "queue-thumb";
        img.src = row.image_url;

        img.addEventListener("error", () => {
          console.warn("[QUEUE] image failed to load, dropping tile", row);
          host.remove();
        });

        const overlay = document.createElement("div");
        overlay.className = "queue-overlay";

        const metaLine = document.createElement("div");
        metaLine.className = "queue-meta-line";

        const username = document.createElement("div");
        username.className = "queue-username";
        username.textContent = row.artist_name || "unknown";

        const age = document.createElement("div");
        age.className = "queue-age";
        const createdAt = row.created_at ? new Date(row.created_at) : null;
        if (createdAt) {
          const diffMs = Date.now() - createdAt.getTime();
          const diffMin = Math.max(diffMs / 60000, 0);
          if (diffMin < 1) {
            age.textContent = "just now";
          } else if (diffMin < 60) {
            age.textContent = `${Math.floor(diffMin)} min`;
          } else {
            const diffHr = diffMin / 60;
            if (diffHr < 24) {
              age.textContent = `${Math.floor(diffHr)} hr`;
            } else {
              const diffDay = diffHr / 24;
              age.textContent = `${Math.floor(diffDay)} d`;
            }
          }
        } else {
          age.textContent = "";
        }

        metaLine.appendChild(username);
        metaLine.appendChild(age);

        const titleLine = document.createElement("div");
        titleLine.className = "queue-title-text";
        titleLine.textContent = row.piece_title || "Untitled";

        overlay.appendChild(metaLine);
        overlay.appendChild(titleLine);

        host.appendChild(img);
        host.appendChild(overlay);

        gridEl.insertBefore(host, gridEl.firstChild);
      }

      if (gridEl.children.length > 0) {
        queueEmpty.style.display = "none";
      } else {
        queueEmpty.style.display = "block";
      }

      queueCountLabel.textContent = `${gridEl.children.length} in queue`;
    }

    async function renderQueue() {
      try {
        const { data, error } = await supabase
          .from("art_queue")
          .select(
            "id, image_url, created_at, status, artist_name, piece_title"
          )
          .eq("status", "pending")
          .order("created_at", { ascending: true })
          .limit(36);

        if (error) {
          console.error("[QUEUE] fetch error:", error);
          queueMeta.textContent =
            "Unable to load queue right now. It might be recalibrating.";
          return;
        }

        queueGrid.innerHTML = "";

        if (!data || data.length === 0) {
          queueEmpty.style.display = "block";
          queueCountLabel.textContent = "0 in queue";
          queueMeta.textContent =
            "No pending pieces right now. Your submission will likely go straight into the next cycle.";
          return;
        }

        renderQueueItems(data, queueGrid);
        queueEmpty.style.display = "none";
        queueCountLabel.textContent = `${queueGrid.children.length} in queue`;
        queueMeta.textContent =
          "Pending pieces waiting for the next draft into the bracket.";
      } catch (err) {
        console.error("[QUEUE] renderQueue error:", err);
        queueMeta.textContent =
          "Queue visuals are down, but submissions are still being recorded.";
      }
    }

    renderQueue();

    const queueChannel = supabase
      .channel("queue-changes")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "art_queue",
        },
        (payload) => {
          try {
            console.log("[QUEUE] realtime payload:", payload);
            const row = payload.new ?? payload.old;
            if (!row) return;

            if (payload.eventType === "INSERT") {
              if (row.status === "pending") {
                renderQueueItems([row], queueGrid);
              }
            } else if (payload.eventType === "UPDATE") {
              const newS = payload.new?.status;
              const oldS = payload.old?.status;
              console.log("[QUEUE] status change:", oldS, "→", newS);

              if (newS === "pending") {
                renderQueueItems([payload.new], queueGrid);
              } else {
                const el = queueGrid.querySelector(
                  `[data-id="${row.id}"]`
                );
                if (el) {
                  el.remove();
                  const count = queueGrid.children.length;
                  queueCountLabel.textContent = `${count} in queue`;
                  if (!count) {
                    queueEmpty.style.display = "block";
                  }
                }
              }
            } else if (payload.eventType === "DELETE") {
              const el = queueGrid.querySelector(
                `[data-id="${row.id}"]`
              );
              if (el) {
                el.remove();
                const count = queueGrid.children.length;
                queueCountLabel.textContent = `${count} in queue`;
                if (!count) {
                  queueEmpty.style.display = "block";
                }
              }
            }
          } catch (err) {
            console.error("[QUEUE] realtime handler error:", err);
          }
        }
      )
      .subscribe((status) => {
        console.log("[QUEUE] channel status:", status);
      });

    const statusChannel = supabase
      .channel("status-change")
      .on("broadcast", { event: "queue_status" }, (payload) => {
        try {
          console.log("[QUEUE] status broadcast:", payload);
          const id = payload.new?.id;
          const newS = payload.new?.status;
          if (!id) return;
          if (newS === "used") {
            const el = queueGrid.querySelector(
              `[data-id="${id}"]`
            );
            if (el) {
              el.remove();
              const count = queueGrid.children.length;
              queueCountLabel.textContent = `${count} in queue`;
              if (!count) {
                queueEmpty.style.display = "block";
              }
            }
          }
        } catch (err) {
          console.error("[QUEUE] broadcast handler error:", err);
        }
      })
      .subscribe((status) => {
        console.log("[QUEUE] status-change channel:", status);
      });

    window.addEventListener("beforeunload", () => {
      if (queueChannel) supabase.removeChannel(queueChannel);
      if (statusChannel) supabase.removeChannel(statusChannel);
    });
  </script>
</body>
</html>