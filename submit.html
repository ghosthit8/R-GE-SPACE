<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Rage Space — Submit</title>
<link rel="preconnect" href="https://tuqvpcevrhciursxrgav.supabase.co">
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
:root{
  --green:#39ff14; --green2:#7dff62; --ink:#e5e5e5;
  --bg:#000; --card:#090909; --border:#153b16; --muted:#8aff8a;
  --maxw:860px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; padding:0;
  font-family:system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", Roboto, sans-serif;
  background:
    repeating-linear-gradient(transparent 0 1px,rgba(0,0,0,.7) 1px 2px),
    radial-gradient(circle at top left,#0b3b24 0,transparent 55%),
    radial-gradient(circle at bottom right,#1b2f3f 0,transparent 55%),
    #000;
  color:var(--ink);
}
.wrap{
  max-width:var(--maxw);
  margin:0 auto;
  padding:16px 12px 96px;
}
h1{margin:0;font-size:26px;letter-spacing:.05em}
small{font-size:11px;opacity:.8}
a{color:var(--green)}
.row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.header{
  display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap
}
.badge{
  border-radius:999px;
  padding:4px 10px;
  border:1px solid rgba(57,255,20,.35);
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:.12em;
  color:var(--green);
}
.badge.small{font-size:10px;padding:3px 8px}
.card{
  margin-top:12px;
  border-radius:16px;
  background:rgba(0,0,0,.85);
  border:1px solid rgba(57,255,20,.25);
  box-shadow:0 0 0 1px rgba(0,0,0,.6);
  padding:12px 12px 14px;
}
.card h2{
  margin:0 0 6px;
  font-size:16px;
  letter-spacing:.08em;
  text-transform:uppercase;
}
.card p{
  margin:0 0 8px;
  font-size:13px;
  color:#b9f6c2;
}
label{font-size:13px}
.input{
  width:100%;
  padding:8px 10px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#020402;
  color:var(--ink);
  font-size:14px;
}
.input::placeholder{color:#3c6941}
textarea.input{
  min-height:60px;
  resize:vertical;
}
.btn{
  appearance:none;
  border-radius:12px;
  border:1px solid rgba(57,255,20,.5);
  padding:8px 14px;
  background:radial-gradient(circle at top left,#062a12,#020302);
  color:var(--ink);
  font-weight:700;
  font-size:14px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:6px;
}
.btn.big{width:100%;justify-content:center;padding:12px 16px;font-size:15px}
.btn.ghost{
  border-color:rgba(57,255,20,.25);
  background:rgba(0,0,0,.4);
  color:#a4b9a7;
}
.btn:disabled{opacity:.6;cursor:default}
.small{font-size:11px}
.mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
.checkRow{
  display:flex;
  align-items:flex-start;
  gap:8px;
  margin-top:6px;
}
.checkRow input[type="checkbox"]{
  margin-top:2px;
}
.queue-grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(90px,1fr));
  gap:8px;
  margin-top:10px;
}
.thumb{
  position:relative;
  border-radius:10px;
  overflow:hidden;
  background:#050505;
  border:1px solid rgba(57,255,20,.2);
}
.thumb video,
.thumb img{
  width:100%;
  height:120px;
  object-fit:cover;
  display:block;
}
.thumb .idx{
  position:absolute;
  top:4px; left:6px;
  font-size:11px;
  padding:2px 6px;
  border-radius:999px;
  background:rgba(0,0,0,.7);
  color:var(--green2);
}
.hidden{display:none!important}
.toast{
  position:fixed;
  left:50%; bottom:18px;
  transform:translateX(-50%);
  padding:8px 14px;
  border-radius:999px;
  background:rgba(0,0,0,.9);
  color:var(--ink);
  border:1px solid rgba(57,255,20,.4);
  font-size:13px;
  opacity:0;
  pointer-events:none;
  transition:opacity .18s ease-out, transform .18s ease-out;
}
.toast.show{
  opacity:1;
  transform:translateX(-50%) translateY(-4px);
}
.drop{
  border-radius:12px;
  border:1px dashed rgba(57,255,20,.4);
  padding:12px 10px;
  background:radial-gradient(circle at top left,rgba(57,255,20,.07),rgba(0,0,0,.5));
  text-align:center;
}
.drop.drag{background:rgba(57,255,20,.08)}
.preview{
  margin-top:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;
}
.preview img{max-height:120px; border-radius:10px; border:1px solid var(--border)}
.authRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
</style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1 style="color:var(--green)">SUBMIT ART</h1>
      <div class="row">
        <span id="authBadge" class="badge small">not logged in</span>
        <a class="btn ghost" href="./menu.html">← Menu</a>
      </div>
    </div>

    <!-- Minimal uploader -->
    <div class="card" style="margin-top:16px">
      <div id="pickZone" class="drop">
        <button id="btnPick" class="btn big">⬆️ Upload or Paste Art</button>
        <div id="fileName" class="small">jpg / png / webp / mp4 / webm — 50MB max. Tip: drag & drop or paste (Ctrl/⌘+V)</div>
        <input id="fileInput" type="file" accept="image/*,video/*" class="hidden">
        <input id="urlInput" type="url" class="input hidden" placeholder="https://image.example/your-art.jpg">
        <div class="preview">
          <img id="imgPreview" alt="" class="hidden">
          <div class="small mono" id="previewHint"></div>
        </div>
      </div>
      <p class="small" style="margin-top:6px;color:#9be8a7">
        Your art battles through R32 → R16 → QF → SF → Final. Losers are nuked from storage at each step.
      </p>
    </div>

    <!-- Piece meta -->
    <div class="card">
      <h2>Piece Info</h2>
      <p>Optional but recommended — helps people know what they’re voting on.</p>
      <div style="display:flex;flex-direction:column;gap:8px">
        <label>
          <span class="small mono" style="text-transform:uppercase;letter-spacing:.15em">Title</span>
          <input id="pieceTitle" class="input" maxlength="120" placeholder="Ex: &quot;Glitch Summer&quot;"/>
        </label>
        <label>
          <span class="small mono" style="text-transform:uppercase;letter-spacing:.15em">Description</span>
          <textarea id="pieceDesc" class="input" maxlength="1000" placeholder="Ex: Collage from my last Dallas walk — shot on phone, edited in Procreate."></textarea>
        </label>
      </div>
      <div class="checkRow">
        <input id="consent" type="checkbox">
        <label for="consent" class="small">
          I confirm this is my art, not AI spam, and I’m okay with it being shown in public tournaments. No minors / real gore / doxxing / hate propaganda.
        </label>
      </div>
      <div class="row" style="margin-top:10px;justify-content:space-between">
        <button id="btnSubmit" class="btn">Submit to Queue</button>
        <div id="submitMsg" class="small mono" style="opacity:.7"></div>
      </div>
    </div>

    <!-- Queue snapshot -->
    <div class="card" id="queuePanel">
      <div class="row" style="justify-content:space-between">
        <div>
          <h2 style="margin-bottom:0">Queue</h2>
          <div class="small" id="queueHint">Live look at pending pieces.</div>
        </div>
        <button id="queueToggle" class="btn ghost small">refresh</button>
      </div>
      <div class="small mono" style="margin-top:4px;color:#7ed68a">
        <span id="clock">--:--</span> • next tournament auto-cycles every 150s
      </div>
      <div id="queueEmpty" class="small" style="margin-top:10px;color:#8cae8f">
        Nothing in queue yet. Once you submit, you’ll see it here until it’s used.
      </div>
      <div id="queueCount" class="small mono" style="margin-top:4px;opacity:.8"></div>
      <div id="queue" class="queue-grid"></div>
    </div>

    <div class="toast" id="toast"></div>
  </div>

<script>
(function(){
  const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
  const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer-v2`;

  const MAX_MB = 200; // client-side cap
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  /* ---------- Elements ---------- */
  const authBadge = document.getElementById('authBadge');
  const toastEl = document.getElementById('toast');

  const pickZone = document.getElementById('pickZone');
  const btnPick = document.getElementById('btnPick');
  const fileInput = document.getElementById('fileInput');
  const urlInput = document.getElementById('urlInput');
  const fileName = document.getElementById('fileName');
  const previewHint = document.getElementById('previewHint');
  const imgPreview = document.getElementById('imgPreview');

  const titleInput = document.getElementById('pieceTitle');
  const descInput  = document.getElementById('pieceDesc');

  const consent = document.getElementById('consent');
  const btnSubmit = document.getElementById('btnSubmit');
  const submitMsg = document.getElementById('submitMsg');

  const queuePanel = document.getElementById('queuePanel');
  const queueToggle = document.getElementById('queueToggle');
  const queueCount = document.getElementById('queueCount');
  const queueGrid = document.getElementById('queue');
  const queueEmpty = document.getElementById('queueEmpty');

  const clockEl = document.getElementById('clock');

  const picked = { file:null, url:'' };

  function log(...a){ try{ console.log('[SUBMIT]',...a); }catch{} }
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=> toastEl.classList.remove('show'), 2200);
  }

  async function currentUser(){
    const { data:{user}, error } = await supabase.auth.getUser();
    if (error) return null;
    return user;
  }

  async function currentUsername(){
    try{
      const user = await currentUser();
      if (!user) return null;
      const { data, error } = await supabase
        .from('profiles')
        .select('username')
        .eq('id', user.id)
        .maybeSingle();
      if (error) return null;
      return data?.username || null;
    }catch(e){
      return null;
    }
  }

  async function uid(){
    const user = await currentUser();
    if (!user) return null;
    return user.id;
  }

  async function syncAuth(){
    const user = await currentUser();
    if (!user){
      authBadge.textContent = 'not logged in';
      authBadge.style.color = '#ff6b6b';
      authBadge.style.borderColor = 'rgba(255,107,107,.6)';
      return;
    }
    const name = await currentUsername();
    authBadge.textContent = name ? `@${name}` : (user.email || 'logged in');
    authBadge.style.color = 'var(--green)';
    authBadge.style.borderColor = 'rgba(57,255,20,.7)';
  }

  syncAuth().catch(()=>{});

  /* ---------- File picking / drag / paste ---------- */

  btnPick.addEventListener('click', ()=>{
    fileInput.click();
  });

  function setPreview(src){
    if (!src){
      imgPreview.classList.add('hidden');
      imgPreview.src = '';
      return;
    }
    imgPreview.src = src;
    imgPreview.classList.remove('hidden');
  }

  function bytesToMB(bytes){
    return (bytes/1024/1024).toFixed(1);
  }

  fileInput.addEventListener('change', ()=>{
    const f = fileInput.files && fileInput.files[0];
    if (!f) return;
    if (f.size > MAX_MB*1024*1024){
      toast(`Max ${MAX_MB}MB`);
      fileInput.value='';
      return;
    }
    picked.file = f; picked.url = '';
    urlInput.value = ''; urlInput.classList.add('hidden');
    fileName.textContent = `${f.name} — ${bytesToMB(f.size)} MB`;
    updatePreviewForFile(f);
  });

  urlInput.addEventListener('input', ()=>{
    picked.url = urlInput.value.trim();
    if (picked.url) {
      picked.file = null; fileInput.value='';
      fileName.textContent = 'Using pasted URL';
      const isVideo = /\.(mp4|webm|mov)(\?|$)/i.test(picked.url);
      if (isVideo){
        setPreview('');
        previewHint.textContent = `Video URL: ${picked.url}`;
      } else {
        previewHint.textContent = picked.url;
        const im = new Image();
        im.onload = ()=> setPreview(picked.url);
        im.onerror = ()=> { setPreview(''); toast('URL is not an image'); };
        im.src = picked.url;
      }
    } else {
      previewHint.textContent='';
      setPreview('');
    }
  });

  function updatePreviewForFile(f){
    const isVideo = f && f.type && f.type.startsWith('video/');
    if (!isVideo){
      const url = URL.createObjectURL(f);
      setPreview(url);
      previewHint.textContent = `${f.type || 'image'} • ${bytesToMB(f.size)}MB`;
    } else {
      setPreview('');
      previewHint.textContent = `Video • ${bytesToMB(f.size)}MB (preview on matchup)`;
    }
  }

  pickZone.addEventListener('dragover', (e)=>{
    e.preventDefault();
    pickZone.classList.add('drag');
  });
  pickZone.addEventListener('dragleave', (e)=>{
    e.preventDefault();
    pickZone.classList.remove('drag');
  });
  pickZone.addEventListener('drop', (e)=>{
    e.preventDefault();
    pickZone.classList.remove('drag');
    const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    if (f.size > MAX_MB*1024*1024){
      toast(`Max ${MAX_MB}MB`);
      return;
    }
    picked.file = f; picked.url='';
    urlInput.value=''; urlInput.classList.add('hidden');
    fileName.textContent = `${f.name} — ${bytesToMB(f.size)} MB`;
    updatePreviewForFile(f);
  });

  document.addEventListener('paste', (e)=>{
    if (!e.clipboardData) return;
    const items = e.clipboardData.items;
    if (!items || !items.length) return;

    let file = null;
    for (const it of items){
      if (it.kind==='file'){
        const f = it.getAsFile();
        if (f){
          file = f; break;
        }
      }
    }
    if (file){
      if (file.size > MAX_MB*1024*1024){
        toast(`Max ${MAX_MB}MB`);
        return;
      }
      picked.file = file; picked.url='';
      urlInput.value=''; urlInput.classList.add('hidden');
      fileName.textContent = `${file.name} — ${bytesToMB(file.size)} MB (pasted)`;
      updatePreviewForFile(file);
    } else {
      const text = e.clipboardData.getData('text');
      if (text && /^https?:\/\//i.test(text)){
        urlInput.classList.remove('hidden');
        urlInput.value = text.trim();
        urlInput.dispatchEvent(new Event('input'));
      }
    }
  });

  /* ---------- Upload to Supabase storage ---------- */

  async function uploadToStorage(id, file){
    const t0 = performance.now();
    const ext = file.name.split('.').pop() || 'bin';
    const folder = new Date().toISOString().slice(0,10);
    const path = `${id}/${folder}/${Date.now()}-${file.name}`;
    log('UPLOAD', path, file.size, 'bytes');

    const { data, error } = await supabase
      .storage
      .from('art-uploads')
      .upload(path, file, {
        cacheControl:'3600',
        upsert:false
      });

    if (error) throw error;
    const { data:publicData } = supabase
      .storage
      .from('art-uploads')
      .getPublicUrl(data.path);

    const url = publicData.publicUrl;
    const dt = (performance.now() - t0).toFixed(0);
    log('IMG: uploaded ', url, `(${dt}ms)`);
    return url;
  }

  /* ---------- Edge call + timer normalize ---------- */
  async function callEdge(){
    const t0 = performance.now();
    log('EDGE: GET', EDGE_URL);
    const res = await fetch(EDGE_URL, {
      method:'GET',
      headers:{ 'Content-Type':'application/json', 'Authorization':`Bearer ${SUPABASE_ANON_KEY}`, 'apikey':SUPABASE_ANON_KEY }
    });
    const raw = await res.text();
    const dt = (performance.now()-t0).toFixed(0);
    log(`EDGE: GET ${EDGE_URL} → ${res.status} (${dt}ms)`);
    const preview = raw.length>200 ? raw.slice(0,200)+'…' : raw;
    log('EDGE: body ~200b =', preview);

    let j=null; try{ j=JSON.parse(raw); }catch(e){ log('EDGE: JSON parse error', String(e)); }
    if (!res.ok) throw new Error((j&&j.error)||raw||'edge error');
    return j?.state || j || {};
  }

  function normalize(s){
    try { log('[EDGE] raw state', JSON.stringify(s)); } catch {}

    const phaseEnd =
      s.ends_at || s.endsAt || s.phase_end_at || s.phaseEndAt || s.next_at || s.next_iso || s.base_iso || null;

    return {
      base_iso: s.base_iso || null,
      ends_at: phaseEnd,
      period_sec: s.period_sec || 150
    };
  }

  async function syncState(){
    try{
      const raw = await callEdge();
      const st = normalize(raw);
      if (st.ends_at){
        const ms = Math.max(0, new Date(st.ends_at).getTime() - Date.now());
        const sec = Math.floor(ms/1000);
        const m = String(Math.floor(sec/60)).padStart(2,'0');
        const s = String(sec%60).padStart(2,'0');
        clockEl.textContent = `${m}:${s}`;
      } else {
        clockEl.textContent = '--:--';
      }
    }catch(e){
      clockEl.textContent = '--:--';
      log('syncState error', e);
    }
  }

  syncState().catch(()=>{});
  setInterval(()=> syncState().catch(()=>{}), 15000);

  /* ---------- Submit handler ---------- */

  btnSubmit.addEventListener('click', async ()=>{
    submitMsg.textContent='';
    const id = await uid();
    if (!id) return toast('Log in to submit');
    if (!consent.checked) return toast('Please consent to the rules');

    // Still read these fields in case we wire them later
    const pieceName = (titleInput?.value || '').trim();
    const pieceDesc = (descInput?.value || '').trim();

    // Optional: username lookup (for future use)
    const artistName = await currentUsername();

    let finalUrl = (picked.url||'').trim();
    try{
      if (picked.file){
        if (picked.file.size > MAX_MB*1024*1024) {
          return toast(`Max ${MAX_MB}MB`);
        }
        toast('Uploading…');
        finalUrl = await uploadToStorage(id, picked.file);
      }
      if (!finalUrl) return toast('Pick a file or paste a URL');

      // Payload with metadata so matchup can show title / artist / description
      const payload = {
        image_url: finalUrl,
        status: 'pending',
        piece_name: pieceName || null,
        piece_description: pieceDesc || null,
        artist_name: artistName || null
      };

      const { error } = await supabase.from('art_queue').insert(payload);
      if (error) {
        console.error('[SUBMIT] insert error', error);
        throw error;
      }

      picked.file = null;
      picked.url = '';
      fileInput.value = '';
      urlInput.value = '';
      urlInput.classList.add('hidden');
      fileName.textContent = 'jpg / png / webp / mp4 / webm — 50MB max. Tip: drag & drop or paste (Ctrl/⌘+V)';
      previewHint.textContent='';
      setPreview('');
      titleInput.value='';
      descInput.value='';
      consent.checked=false;

      submitMsg.textContent = 'Queued!';
      toast('Submitted to queue');
      renderQueue().catch(()=>{});
    } catch(e){
      console.error(e);
      toast('Upload failed — try again');
    }
  });

  /* ---------- Queue render ---------- */

  async function renderQueue(){
    try{
      const { data, error } = await supabase
        .from('art_queue')
        .select('id,image_url,status,created_at')
        .eq('status','pending')
        .order('created_at',{ascending:true})
        .limit(120);

      if (error) throw error;
      queueGrid.innerHTML = '';
      const rows = data || [];
      if (!rows.length){
        queueEmpty.style.display = 'block';
        queueCount.textContent = '(0)';
        return;
      }
      queueEmpty.style.display = 'none';
      queueCount.textContent = `(${rows.length})`;
      rows.forEach((row,idx)=>{
        const div = document.createElement('div');
        div.className = 'thumb';
        div.dataset.id = row.id;
        const url = row.image_url || '';
        div.title = url;
        const isVideo = /\.(mp4|webm|mov)(\?|$)/i.test(url);
        const media =
          isVideo
            ? `<video src="${url}#t=0.1" muted playsinline loop></video>`
            : `<img src="${url}" alt="queued art"/>`;
        div.innerHTML = `<span class="idx">#${idx+1}</span>${media}`;
        queueGrid.appendChild(div);
      });
    }catch(e){
      console.error('renderQueue error', e);
    }
  }

  queueToggle.addEventListener('click', ()=>{
    renderQueue().catch(()=>{});
  });

  renderQueue().catch(()=>{});

  /* ---------- Realtime queue watch ---------- */
  const queueChannel = supabase.channel('queue-watch')
    // NOTE: only listening for INSERT now, so we don't insta-delete tiles on locked/used
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'art_queue' }, (payload) => {
      const row = payload.new;
      if (row?.status !== 'pending') return;
      const div = document.createElement('div');
      div.className = 'thumb';
      div.dataset.id = row.id;
      const url = row.image_url || '';
      div.title = url;
      const isVideo = /\.(mp4|webm|mov)(\?|$)/i.test(url);
      const media =
        isVideo
          ? `<video src="${url}#t=0.1" muted playsinline loop></video>`
          : `<img src="${url}" alt="queued art"/>`;
      div.innerHTML = `<span class="idx">#?</span>${media}`;

      const img = div.querySelector('img');
      if (img) {
        img.addEventListener('load', ()=> log('IMG: loaded  ', img.src));
        img.addEventListener('error', ()=> {
          console.warn('IMG: error   ', img.src);
          const host = img.closest('[data-id], .thumb, .item');
          if (host) {
            host.remove();
            const count = queueGrid.children.length;
            if (queueCount) queueCount.textContent = `(${count})`;
            if (count === 0) queueEmpty.style.display = 'block';
          }
        });
      }

      queueGrid.appendChild(div);
      const count = queueGrid.children.length;
      if (queueCount) queueCount.textContent = `(${count})`;
      if (count > 0) queueEmpty.style.display = 'none';
    })
    .subscribe();

  // Periodic refresh for sanity
  setInterval(()=> renderQueue().catch(()=>{}), 5000);

  // Refresh on visibility regain
  document.addEventListener('visibilitychange', ()=>{
    if (document.visibilityState === 'visible') {
      renderQueue().catch(()=>{});
      syncState().catch(()=>{});
    }
  });
})();
</script>
<script src="js/auth-guard.js" type="module"></script>

</body>
</html>