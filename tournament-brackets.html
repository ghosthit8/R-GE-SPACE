<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — Tournament Brackets</title>
  <link rel="stylesheet" href="style.css?v=3" />
  <style>
    :root{
      --green:#39ff14; --red:#ff0033; --bg:#000; --ink:#e5ffe5; --border:#0f2510;
      --card:#070707; --muted:#8aff8a;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; background:#000; color:var(--green);
      font-family: ui-sans-serif,system-ui,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing: antialiased;
      overflow:hidden;
    }
    header{ max-width:960px; margin:10px auto 0; padding:0 16px; }
    .toolbar{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .btn{ border:1px solid var(--green); color:var(--green); text-decoration:none; padding:8px 12px; border-radius:10px; display:inline-flex; align-items:center; gap:8px; background:transparent; cursor:pointer; }

    .viewport{
      position:fixed; inset:56px 8px 8px; border:1px solid var(--border); border-radius:14px; overflow:hidden;
      background:
        radial-gradient(1200px 800px at 70% -20%, rgba(57,255,20,0.08), transparent 60%),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0, rgba(255,255,255,.03) 2px, transparent 2px, transparent 4px),
        rgba(7,7,7,.45);
      touch-action: none;
    }

    .layer{ position:absolute; top:0; left:0; width:3600px; height:2600px; transform-origin:0 0; }
    svg.wires{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0; }
    .nodes{ position:absolute; inset:0; z-index:1; }

    .node{ position:absolute; width:220px; }
    .card{
      border:1px solid var(--border); border-radius:12px; overflow:hidden; background:rgba(0,0,0,.55);
      box-shadow: 0 0 18px rgba(57,255,20,.08) inset; backdrop-filter: blur(1px);
      position: relative;
    }
    .thumb{ display:block; width:100%; aspect-ratio:3/4; object-fit:cover; background:#050505; }
    .meta{ padding:8px 10px; border-top:1px solid var(--border); }
    .title{
      font-size:.9rem; line-height:1.2; margin:0 0 4px 0; color:var(--ink);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .timer,.votes{ font-variant-numeric:tabular-nums; opacity:.85; }
    .enter{ margin-top:6px; display:flex; justify-content:flex-end; }
    .enter .btn{ padding:5px 9px; font-size:.85rem }

    .entrant .enter{ display:none; }
    .entrant .title{ opacity:.9; }

    .tbd .thumb{
      background:
        repeating-linear-gradient(45deg, rgba(57,255,20,.08) 0 6px, transparent 6px 12px),
        #0a0a0a;
      filter: saturate(.4) contrast(.9) brightness(.9);
    }
    .tbd .tbd-badge{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      font-size:3rem; font-weight:900; color:rgba(57,255,20,.75);
      text-shadow:0 0 10px rgba(57,255,20,.4); pointer-events:none;
    }

    .round-label{
      position:absolute; left:12px; transform:translateY(-120%); font-size:.85rem; opacity:.8;
      background:rgba(0,0,0,.45); border:1px solid var(--border); border-radius:8px; padding:4px 8px;
      pointer-events:none;
    }

    .hint{
      position:absolute; right:12px; bottom:8px; font-size:.85rem; opacity:.75;
      background:rgba(0,0,0,.45); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      pointer-events:none;
    }

    .zoom-controls{
      position:absolute; right:12px; top:12px; display:flex; flex-direction:column; gap:8px; z-index:5;
    }
    .zoom-controls button{
      width:42px; height:42px; border-radius:10px; border:1px solid var(--green);
      background:rgba(0,0,0,.55); color:var(--green); font-weight:700; cursor:pointer;
    }

    @media (max-width:900px){ .viewport{ inset:64px 6px 6px } }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <h1 style="margin:0">R<span class="anarchy">Ⓐ</span>GE SPACE — TOURNAMENT</h1>
      <div style="display:flex; gap:8px">
        <a class="btn" href="matchup.html">⚔️ Random Battle</a>
        <a class="btn" href="menu.html">← Menu</a>
      </div>
    </div>
  </header>

  <div class="viewport" id="viewport">
    <svg class="layer wires" id="wires" viewBox="0 0 3600 2600" preserveAspectRatio="none"></svg>
    <div class="layer nodes" id="nodes"></div>

    <div class="zoom-controls">
      <button id="zoomin"  aria-label="Zoom in">＋</button>
      <button id="zoomout" aria-label="Zoom out">－</button>
      <button id="zoomreset" aria-label="Reset zoom">⟳</button>
    </div>

    <div class="hint">Drag to move • Pinch/Scroll to zoom • Double-tap to zoom in</div>
  </div>

  <script type="module">
    /************* SUPABASE *************/
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
    const TOURNAMENT_ID = "682da23f-6e32-4782-8b8a-8e59527d6b58";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /************* LAYOUT CONSTANTS (auto-fit) *************/
    const CARD_W = 220;
    let   CARD_H = 320;       // corrected after render
    const X_START = 100;
    const X_GAP   = 260;      // spacing between cards in a row
    const ROW_GAP = 420;      // spacing between rows

    const viewport = document.getElementById('viewport');
    const nodesEl  = document.getElementById('nodes');
    const wiresEl  = document.getElementById('wires');

    const BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

    /************* FETCH + BUILD *************/
    async function fetchMatches(){
      const { data, error } = await supabase
        .from('match_public')
        .select('*')
        .eq('tournament_id', TOURNAMENT_ID)
        .order('round_number', { ascending: true })
        .order('index_in_round', { ascending: true });

      if (error){ console.error(error); throw error; }
      return data || [];
    }

    // Build DOM using your original structure (entrant row + match rows)
    async function build(){
      const rows = await fetchMatches();
      if (!rows.length){
        nodesEl.innerHTML = `<div style="position:absolute;left:20px;top:20px;color:#f66">No matches found.</div>`;
        return;
      }

      // Group by round
      const byRound = new Map();
      for (const m of rows){
        if (!byRound.has(m.round_number)) byRound.set(m.round_number, []);
        byRound.get(m.round_number).push(m);
      }
      const rounds = Array.from(byRound.keys()).sort((a,b)=>a-b); // 1..N
      const maxRound = rounds[rounds.length-1];
      const r1 = byRound.get(1) || [];
      const r1Count = r1.length;                // e.g., 16 for 32 entrants
      const entrantCount = r1Count * 2;         // e.g., 32

      // Compute Y positions: row 0 = entrants, row 1..N = match rounds
      const rowY = (i)=> 200 + i*ROW_GAP;

      // Compute entrant centers left→right: [A1, B1, A2, B2, ...]
      const entrantCenters = [];
      for (let i=0;i<r1Count;i++){
        const xa = X_START + (2*i)*X_GAP;
        const xb = X_START + (2*i+1)*X_GAP;
        entrantCenters.push(xa + CARD_W/2, xb + CARD_W/2);
      }

      // Map for x centers of each match id
      const centerX = new Map();

      nodesEl.innerHTML = ''; // reset
      // Round label helpers
      const ROUND_NAMES = (total)=>({
        1: total>=6?'ROUND OF 64': total>=5?'ROUND OF 32': total>=4?'ROUND OF 16': total>=3?'QUARTERFINALS': total>=2?'SEMIFINALS': 'FINAL'
      });

      // --- Entrants row (derived from Round 1 A/B) ---
      let entrantHTML = '';
      for (let i=0;i<r1Count;i++){
        const m = r1[i];
        const xa = entrantCenters[2*i]   - CARD_W/2;
        const xb = entrantCenters[2*i+1] - CARD_W/2;

        entrantHTML += nodeHTML({
          id: `E${m.id}-A`, x: xa, y: rowY(0),
          title: m.a_name || 'TBD', img: m.a_image || BLANK,
          votes: (m.votes_a ?? 0), ends: m.end_time, isEntrant:true
        });
        entrantHTML += nodeHTML({
          id: `E${m.id}-B`, x: xb, y: rowY(0),
          title: m.b_name || 'TBD', img: m.b_image || BLANK,
          votes: (m.votes_b ?? 0), ends: m.end_time, isEntrant:true
        });
      }
      nodesEl.insertAdjacentHTML('beforeend', entrantHTML);

      // After first paint, get exact card height
      const anyCard = nodesEl.querySelector('.card');
      if (anyCard) CARD_H = anyCard.getBoundingClientRect().height;

      // --- Round 1 matches (centered under their entrants) ---
      for (let i=0;i<r1Count;i++){
        const m = r1[i];
        const cx = (entrantCenters[2*i] + entrantCenters[2*i+1]) / 2 - CARD_W/2;
        centerX.set(m.id, cx + CARD_W/2);

        nodesEl.insertAdjacentHTML('beforeend', matchHTML({
          id: m.id, x: cx, y: rowY(1),
          a_name: m.a_name, a_img: m.a_image,
          b_name: m.b_name, b_img: m.b_image,
          votes_a: m.votes_a, votes_b: m.votes_b,
          end_time: m.end_time
        }));
      }

      // Build parent→children map for higher rounds
      const children = new Map(); // parentId -> [childMatchIds]
      for (const m of rows){
        if (m.parent_match_id){
          if (!children.has(m.parent_match_id)) children.set(m.parent_match_id, []);
          children.get(m.parent_match_id).push(m.id);
        }
      }

      // --- Higher rounds (2..maxRound) ---
      for (let r=2; r<=maxRound; r++){
        const list = byRound.get(r) || [];
        for (const m of list){
          // Center = average of children centers if present, else place by order
          let cx;
          const kids = children.get(m.id);
          if (kids && kids.length === 2 && centerX.has(kids[0]) && centerX.has(kids[1])){
            cx = (centerX.get(kids[0]) + centerX.get(kids[1]))/2 - CARD_W/2;
          }else{
            // fallback by index_in_round
            cx = X_START + (m.index_in_round-1) * (2**(maxRound - r + 1)) * X_GAP - CARD_W/2;
          }
          centerX.set(m.id, cx + CARD_W/2);

          nodesEl.insertAdjacentHTML('beforeend', matchHTML({
            id: m.id, x: cx, y: rowY(r),
            a_name: m.a_name, a_img: m.a_image,
            b_name: m.b_name, b_img: m.b_image,
            votes_a: m.votes_a, votes_b: m.votes_b,
            end_time: m.end_time
          }));

          // Round label only once at the left for each row
          if (m.index_in_round === 1){
            const lbl = document.createElement('div');
            lbl.className = 'round-label';
            lbl.style.left = '12px';
            lbl.style.top  = (rowY(r)) + 'px';
            lbl.textContent = nameForRound(r, maxRound);
            nodesEl.appendChild(lbl);
          }
        }
      }

      // Add single label for entrants row
      const lbl0 = document.createElement('div');
      lbl0.className = 'round-label';
      lbl0.style.left = '12px';
      lbl0.style.top  = (rowY(0)) + 'px';
      lbl0.textContent = nameForRound(0, maxRound); // Entrants/First round label
      nodesEl.appendChild(lbl0);

      drawAllWires(r1, rows, entrantCenters, centerX, rowY);
      startClocks();
    }

    function nameForRound(rIndex, maxRound){
      // rIndex 0 = entrants (above round 1)
      const left = (maxRound - (rIndex||1) + 1);
      if (rIndex === 0){
        if (maxRound >= 6) return 'ENTRANTS (64)';
        if (maxRound >= 5) return 'ENTRANTS (32)';
        if (maxRound >= 4) return 'ENTRANTS (16)';
        if (maxRound >= 3) return 'ENTRANTS (8)';
        return 'ENTRANTS';
      }
      if (left === 1) return 'FINAL';
      if (left === 2) return 'SEMIFINALS';
      if (left === 3) return 'QUARTERFINALS';
      if (left === 4) return 'ROUND OF 16';
      if (left === 5) return 'ROUND OF 32';
      if (left === 6) return 'ROUND OF 64';
      return `ROUND ${rIndex}`;
    }

    /************* CARD TEMPLATES *************/
    function nodeHTML({id,x,y,title,img,votes,ends,isEntrant}){
      const tbd = !img || img===BLANK;
      return `
        <div class="node ${isEntrant?'entrant':''} ${tbd?'tbd':''}" data-id="${id}" style="left:${x}px; top:${y}px">
          <article class="card" title="${tbd?'TBD':'Entrant'}">
            <img class="thumb" src="${img||BLANK}" alt="">
            ${tbd?'<div class="tbd-badge">?</div>':''}
            <div class="meta">
              <h3 class="title">${title||'TBD'}</h3>
              <div class="row">
                <span class="timer" data-ends="${ends?Date.parse(ends):''}"></span>
                <span class="votes">${Number.isFinite(votes)? votes : '—'}</span>
              </div>
              <div class="enter"></div>
            </div>
          </article>
        </div>`;
    }

    function matchHTML({id,x,y,a_name,a_img,b_name,b_img,votes_a,votes_b,end_time}){
      const haveA = !!a_img, haveB = !!b_img;
      const tbd = !(haveA || haveB);
      const label = `${clip(a_name)||'TBD'} vs ${clip(b_name)||'TBD'}`;
      const art = a_img || b_img || BLANK;
      const votes = `${Number.isFinite(votes_a)?votes_a:0} - ${Number.isFinite(votes_b)?votes_b:0}`;

      return `
        <div class="node ${tbd?'tbd':''}" data-id="${id}" style="left:${x}px; top:${y}px">
          <article class="card" title="${tbd?'TBD match':'Match'}">
            <img class="thumb" src="${art}" alt="">
            ${tbd?'<div class="tbd-badge">?</div>':''}
            <div class="meta">
              <h3 class="title">${label}</h3>
              <div class="row">
                <span class="timer" data-ends="${end_time?Date.parse(end_time):''}"></span>
                <span class="votes">${votes}</span>
              </div>
              <div class="enter"><a class="btn" href="matchup.html?battle=${id}">Enter</a></div>
            </div>
          </article>
        </div>`;
    }

    function clip(s){ if(!s) return s; return s.length>24 ? s.slice(0,22)+'…' : s; }

    /************* WIRES *************/
    function drawAllWires(r1, all, entrantCenters, centerX, rowY){
      wiresEl.innerHTML='';

      // Entrants -> Round 1
      for (let i=0;i<r1.length;i++){
        const m = r1[i];
        // from entrant A
        drawElbow(
          {x: entrantCenters[2*i]   - CARD_W/2, y: rowY(0)},
          {x: centerX.get(m.id) - CARD_W/2,     y: rowY(1)}
        );
        // from entrant B
        drawElbow(
          {x: entrantCenters[2*i+1] - CARD_W/2, y: rowY(0)},
          {x: centerX.get(m.id) - CARD_W/2,     y: rowY(1)}
        );
      }

      // Matches -> parent matches
      const byId = new Map(all.map(m=>[m.id,m]));
      for (const m of all){
        if (!m.parent_match_id) continue;
        const childX = centerX.get(m.id);
        const parentX = centerX.get(m.parent_match_id);
        if (!childX || !parentX) continue;

        const yChild  = rowY(m.round_number);
        const yParent = rowY(m.round_number + 1);
        drawElbow(
          {x: childX - CARD_W/2,  y: yChild},
          {x: parentX - CARD_W/2, y: yParent}
        );
      }
    }

    function drawElbow(fromRect, toRect){
      const [x1,y1] = [fromRect.x + CARD_W/2, fromRect.y + CARD_H];
      const [x2,y2] = [toRect.x + CARD_W/2,   toRect.y];
      const midY = (y1 + y2)/2;

      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`);
      p.setAttribute('fill','none');
      p.setAttribute('stroke','rgba(57,255,20,0.55)');
      p.setAttribute('stroke-width','2');
      p.setAttribute('shape-rendering','crispEdges');
      wiresEl.appendChild(p);
    }

    /************* TIMERS *************/
    function fmt(ms){
      if(!ms || ms<=0) return '00:00:00';
      const s=Math.floor(ms/1000);
      const hh=String(Math.floor(s/3600)).padStart(2,'0');
      const mm=String(Math.floor((s%3600)/60)).padStart(2,'0');
      const ss=String(s%60).padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    }
    function startClocks(){
      const upd = ()=>{
        document.querySelectorAll('.timer').forEach(el=>{
          const ends = +el.dataset.ends || 0;
          const left = ends - Date.now();
          el.textContent = fmt(left);
        });
      };
      upd();
      clearInterval(startClocks._t);
      startClocks._t = setInterval(upd, 1000);
    }

    /************* PAN & ZOOM (your original UX) *************/
    const layers=[wiresEl,nodesEl];
    let scale=0.95, minS=0.10, maxS=3.0, tx=40, ty=12;

    function apply(){
      layers.forEach(el=>{
        el.style.transform=`translate(${tx}px,${ty}px) scale(${scale})`;
        el.style.transformOrigin='0 0';
      });
    }
    apply();

    function centerOnLoad(totalEntrants){
      const totalWidth = X_START + (totalEntrants-1)*X_GAP + CARD_W + X_START;
      const totalHeight = 200 + (/* entrants + rounds */ 6) * ROW_GAP + CARD_H + 80;
      const view = viewport.getBoundingClientRect();
      const sx = (view.width - 40) / totalWidth;
      const sy = (view.height - 80) / totalHeight;
      scale = Math.max(minS, Math.min(maxS, Math.min(sx, sy)*0.95));
      tx = (view.width - totalWidth*scale)/2;
      ty = 12;
      apply();
    }

    viewport.addEventListener('wheel',(e)=>{
      e.preventDefault();
      const r=viewport.getBoundingClientRect();
      const mx=(e.clientX-r.left-tx)/scale, my=(e.clientY-r.top-ty)/scale;
      const ds=e.deltaY<0?1.12:0.9;
      const ns=Math.min(maxS,Math.max(minS,scale*ds));
      tx = e.clientX-r.left - mx*ns; ty = e.clientY-r.top - my*ns; scale=ns; apply();
    },{passive:false});

    let dragging=false, lx=0, ly=0;
    const activePointers = new Map();
    let isPinching=false, pinchStartDist=0, pinchStartScale=1, pinchCenter=[0,0];

    viewport.addEventListener('pointerdown',e=>{
      viewport.setPointerCapture(e.pointerId);
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activePointers.size===1){ dragging=true; lx=e.clientX; ly=e.clientY; }
    });
    viewport.addEventListener('pointermove',e=>{
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activePointers.size===2){
        pinchUpdate();
      } else if (dragging){
        tx += e.clientX - lx; ty += e.clientY - ly; lx=e.clientX; ly=e.clientY; apply();
      }
    });
    viewport.addEventListener('pointerup',e=>{
      activePointers.delete(e.pointerId);
      if (activePointers.size<2) isPinching=false;
      if (activePointers.size===0) dragging=false;
    });
    viewport.addEventListener('pointercancel',e=>{
      activePointers.delete(e.pointerId);
      isPinching=false; dragging=false;
    });

    viewport.addEventListener('dblclick',(e)=>{
      const r=viewport.getBoundingClientRect();
      const mx=(e.clientX-r.left-tx)/scale, my=(e.clientY-r.top-ty)/scale;
      const factor = e.shiftKey ? 0.74 : 1.35;
      const ns=Math.min(maxS,Math.max(minS,scale*factor));
      tx = e.clientX-r.left - mx*ns; ty = e.clientY-r.top - my*ns; scale=ns; apply();
    });

    function distance(p1,p2){ const dx=p1.x-p2.x, dy=p1.y-p2.y; return Math.hypot(dx,dy); }
    function pinchUpdate(){
      const pts = [...activePointers.values()]; if (pts.length!==2) return;
      const p1=pts[0], p2=pts[1];
      if (!isPinching){
        isPinching=true; pinchStartDist = distance(p1,p2); pinchStartScale = scale;
        const r=viewport.getBoundingClientRect();
        pinchCenter = [(p1.x+p2.x)/2, (p1.y+p2.y)/2];
        return;
      }
      const r=viewport.getBoundingClientRect();
      const centerX = (pinchCenter[0]-r.left - tx)/scale;
      const centerY = (pinchCenter[1]-r.top  - ty)/scale;
      const dist = distance(p1,p2);
      const ns = Math.min(maxS, Math.max(minS, pinchStartScale * (dist/pinchStartDist)));
      tx = pinchCenter[0]-r.left - centerX*ns; ty = pinchCenter[1]-r.top - centerY*ns; scale = ns; apply();
    }

    // Buttons
    document.getElementById('zoomin').addEventListener('click', ()=> zoomBy(1.2));
    document.getElementById('zoomout').addEventListener('click', ()=> zoomBy(1/1.2));
    document.getElementById('zoomreset').addEventListener('click', ()=> centerOnLoad(_lastEntrants));
    function zoomBy(f){
      const r=viewport.getBoundingClientRect();
      const cx=r.width/2, cy=r.height/2;
      const mx=(cx-tx)/scale, my=(cy-ty)/scale;
      const ns=Math.min(maxS,Math.max(minS,scale*f));
      tx = cx - mx*ns; ty = cy - my*ns; scale=ns; apply();
    }

    /************* REFRESH (poll) *************/
    let _lastEntrants = 32;
    async function refresh(){
      try{
        await build();
        // derive current entrants count from DOM (top row)
        const topNodes = [...nodesEl.querySelectorAll('.node')].filter(n => parseFloat(n.style.top) === 200);
        _lastEntrants = topNodes.length || 32;
        centerOnLoad(_lastEntrants);
      }catch(e){
        console.error(e);
      }
    }

    // initial + poll every 30s
    await refresh();
    setInterval(refresh, 30000);
    window.addEventListener('resize', ()=> centerOnLoad(_lastEntrants));
  </script>
</body>
</html>