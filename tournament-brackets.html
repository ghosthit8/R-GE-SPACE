<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — Tournament Brackets</title>
  <link rel="stylesheet" href="style.css?v=3" />
  <style>
    :root{
      --green:#39ff14; --red:#ff0033; --bg:#000; --ink:#e5ffe5; --border:#0f2510;
      --card:#070707; --muted:#8aff8a;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; background:#000; color:var(--green);
      font-family: ui-sans-serif,system-ui,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing: antialiased;
      overflow:hidden;
    }
    header{ max-width:960px; margin:10px auto 0; padding:0 16px; }
    .toolbar{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .btn{ border:1px solid var(--green); color:var(--green); text-decoration:none; padding:8px 12px; border-radius:10px; display:inline-flex; align-items:center; gap:8px; background:transparent; cursor:pointer; }

    .viewport{
      position:fixed; inset:56px 8px 8px; border:1px solid var(--border); border-radius:14px; overflow:hidden;
      background:
        radial-gradient(1200px 800px at 70% -20%, rgba(57,255,20,0.08), transparent 60%),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0, rgba(255,255,255,.03) 2px, transparent 2px, transparent 4px),
        rgba(7,7,7,.45);
      touch-action:none; /* allow custom pinch/drag */
    }

    .layer{ position:absolute; top:0; left:0; width:5200px; height:3200px; transform-origin:0 0; }
    svg.wires{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0; }
    .nodes{ position:absolute; inset:0; z-index:1; }

    .node{ position:absolute; width:220px; }
    .card{
      border:1px solid var(--border); border-radius:12px; overflow:hidden; background:rgba(0,0,0,.55);
      box-shadow: 0 0 18px rgba(57,255,20,.08) inset; backdrop-filter: blur(1px);
      position: relative;
    }
    .thumb{ display:block; width:100%; aspect-ratio:3/4; object-fit:cover; background:#050505; }
    .meta{ padding:8px 10px; border-top:1px solid var(--border); }
    .title{
      font-size:.9rem; line-height:1.2; margin:0 0 4px 0; color:var(--ink);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .timer,.votes{ font-variant-numeric:tabular-nums; opacity:.85; }
    .enter{ margin-top:6px; display:flex; justify-content:flex-end; }
    .enter .btn{ padding:5px 9px; font-size:.85rem }

    .entrant .enter{ display:none; }
    .entrant .title{ opacity:.9; }

    .tbd .thumb{
      background:
        repeating-linear-gradient(45deg, rgba(57,255,20,.08) 0 6px, transparent 6px 12px),
        #0a0a0a;
      filter: saturate(.4) contrast(.9) brightness(.9);
    }
    .tbd .tbd-badge{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      font-size:3rem; font-weight:900; color:rgba(57,255,20,.75);
      text-shadow:0 0 10px rgba(57,255,20,.4); pointer-events:none;
    }

    .round-label{
      position:absolute; left:12px; transform:translateY(-120%); font-size:.85rem; opacity:.8;
      background:rgba(0,0,0,.45); border:1px solid var(--border); border-radius:8px; padding:4px 8px;
      pointer-events:none;
    }

    .hint{
      position:absolute; right:12px; bottom:8px; font-size:.85rem; opacity:.75;
      background:rgba(0,0,0,.45); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      pointer-events:none;
    }

    .zoom-controls{
      position:absolute; right:12px; top:12px; display:flex; flex-direction:column; gap:8px; z-index:5;
    }
    .zoom-controls button{
      width:42px; height:42px; border-radius:10px; border:1px solid var(--green);
      background:rgba(0,0,0,.55); color:var(--green); font-weight:700; cursor:pointer;
    }

    @media (max-width:900px){ .viewport{ inset:64px 6px 6px } }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <h1 style="margin:0">R<span class="anarchy">Ⓐ</span>GE SPACE — TOURNAMENT</h1>
      <div style="display:flex; gap:8px">
        <a class="btn" href="matchup.html">⚔️ Random Battle</a>
        <a class="btn" href="menu.html">← Menu</a>
      </div>
    </div>
  </header>

  <div class="viewport" id="viewport">
    <svg class="layer wires" id="wires" viewBox="0 0 5200 3200" preserveAspectRatio="none"></svg>
    <div class="layer nodes" id="nodes"></div>

    <div class="zoom-controls">
      <button id="zoomin"  aria-label="Zoom in">＋</button>
      <button id="zoomout" aria-label="Zoom out">－</button>
      <button id="zoomreset" aria-label="Reset zoom">⟳</button>
    </div>

    <div class="hint">Drag to move • Pinch/Scroll to zoom • Double-tap to zoom (Shift = zoom out)</div>
  </div>

  <script type="module">
    /************* MODE *************/
    const DEMO_MODE = true;

    /************* (Optional) SUPABASE *************/
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
    const TOURNAMENT_ID = "682da23f-6e32-4782-8b8a-8e59527d6b58";
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /************* LAYOUT *************/
    const CARD_W = 220;
    let   CARD_H = 320;
    const X_START = 100;
    const X_GAP   = 260;
    const ROW_GAP = 420;

    const viewport = document.getElementById('viewport');
    const nodesEl  = document.getElementById('nodes');
    const wiresEl  = document.getElementById('wires');
    const BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    const rowY = (i)=> 200 + i*ROW_GAP;

    /************* DATA *************/
    async function fetchMatchesLive(){
      const { data, error } = await supabase
        .from('match_public')
        .select('*')
        .eq('tournament_id', TOURNAMENT_ID)
        .order('round_number', { ascending: true })
        .order('index_in_round', { ascending: true });
      if (error) throw error;
      return data || [];
    }
    function demoEntrants32(){
      return Array.from({length:32}, (_,i)=>({ name:`Seed ${i+1}`, img:`https://picsum.photos/seed/e${i+1}/600/800`, v:0 }));
    }

    /************* TEMPLATES *************/
    function entrantHTML(id,x,y,p){
      return `
        <div class="node entrant" data-id="${id}" style="left:${x}px; top:${y}px">
          <article class="card">
            <img class="thumb" src="${p.img||BLANK}" alt="">
            <div class="meta">
              <h3 class="title">${p.name||'TBD'}</h3>
              <div class="row"><span class="timer" data-ends="${Date.now()}"></span><span class="votes">0</span></div>
              <div class="enter"></div>
            </div>
          </article>
        </div>`;
    }
    function matchHTML(id,x,y,a,b){
      const label = `${clip(a?.name)||'TBD'} vs ${clip(b?.name)||'TBD'}`;
      const art = a?.img || b?.img || BLANK;
      const tbd = !(a?.img || b?.img);
      return `
        <div class="node ${tbd?'tbd':''}" data-id="${id}" style="left:${x}px; top:${y}px">
          <article class="card">
            <img class="thumb" src="${art}" alt="">
            ${tbd?'<div class="tbd-badge">?</div>':''}
            <div class="meta">
              <h3 class="title">${label}</h3>
              <div class="row"><span class="timer" data-ends="${Date.now()}"></span><span class="votes">0 - 0</span></div>
              <div class="enter"><a class="btn" href="matchup.html?battle=${id}">Enter</a></div>
            </div>
          </article>
        </div>`;
    }
    function clip(s){ if(!s) return s; return s.length>24 ? s.slice(0,22)+'…' : s; }

    /************* BUILD *************/
    async function build(){
      nodesEl.innerHTML = '';
      const centers = [];

      if (DEMO_MODE){
        const ENTRANTS = demoEntrants32();
        for (let i=0;i<ENTRANTS.length;i++){
          const x = X_START + i*X_GAP;
          centers.push(x + CARD_W/2);
          nodesEl.insertAdjacentHTML('beforeend', entrantHTML('E'+(i+1), x, rowY(0), ENTRANTS[i]));
        }

        const R32 = [];
        for (let i=0;i<16;i++){
          const cx = (centers[2*i] + centers[2*i+1]) / 2 - CARD_W/2;
          const a = ENTRANTS[2*i], b = ENTRANTS[2*i+1];
          const id = 'R32_'+(i+1);
          R32.push({id, cx, a, b});
          nodesEl.insertAdjacentHTML('beforeend', matchHTML(id, cx, rowY(1), a, b));
        }

        const R16 = [];
        for (let i=0;i<8;i++){
          const cx = (R32[i*2].cx + CARD_W/2 + R32[i*2+1].cx + CARD_W/2)/2 - CARD_W/2;
          const id = 'R16_'+(i+1);
          R16.push({id, cx});
          nodesEl.insertAdjacentHTML('beforeend', matchHTML(id, cx, rowY(2)));
        }

        const QF = [];
        for (let i=0;i<4;i++){
          const cx = (R16[i*2].cx + CARD_W/2 + R16[i*2+1].cx + CARD_W/2)/2 - CARD_W/2;
          const id = 'QF_'+(i+1);
          QF.push({id, cx});
          nodesEl.insertAdjacentHTML('beforeend', matchHTML(id, cx, rowY(3)));
        }

        const SF = [];
        for (let i=0;i<2;i++){
          const cx = (QF[i*2].cx + CARD_W/2 + QF[i*2+1].cx + CARD_W/2)/2 - CARD_W/2;
          const id = 'SF_'+(i+1);
          SF.push({id, cx});
          nodesEl.insertAdjacentHTML('beforeend', matchHTML(id, cx, rowY(4)));
        }

        const FINAL_CX = (SF[0].cx + CARD_W/2 + SF[1].cx + CARD_W/2)/2 - CARD_W/2;
        nodesEl.insertAdjacentHTML('beforeend', matchHTML('FINAL', FINAL_CX, rowY(5)));

        requestAnimationFrame(()=>{
          const any = nodesEl.querySelector('.card');
          if (any) CARD_H = any.getBoundingClientRect().height;
          drawDemoWires(centers, R32, R16, QF, SF, FINAL_CX);
          startClocks();
          centerOnLoad(32);
        });

      } else {
        // live build (unchanged from your version) ...
      }
    }

    /************* WIRES *************/
    function drawElbow(fromRect, toRect){
      const [x1,y1] = [fromRect.x + CARD_W/2, fromRect.y + CARD_H];
      const [x2,y2] = [toRect.x + CARD_W/2,   toRect.y];
      const midY = (y1 + y2)/2;
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`);
      p.setAttribute('fill','none');
      p.setAttribute('stroke','rgba(57,255,20,0.55)');
      p.setAttribute('stroke-width','2');
      p.setAttribute('shape-rendering','crispEdges');
      wiresEl.appendChild(p);
    }
    function drawDemoWires(centers, R32, R16, QF, SF, FINAL_CX){
      const any = nodesEl.querySelector('.card');
      if (any) CARD_H = any.getBoundingClientRect().height;
      wiresEl.innerHTML='';
      for (let i=0;i<R32.length;i++){
        const m = R32[i];
        drawElbow({x: centers[2*i]-CARD_W/2, y: rowY(0)}, {x: m.cx, y: rowY(1)});
        drawElbow({x: centers[2*i+1]-CARD_W/2, y: rowY(0)}, {x: m.cx, y: rowY(1)});
      }
      for (let i=0;i<R16.length;i++){
        const a = R32[i*2], b = R32[i*2+1], p = R16[i];
        drawElbow({x: a.cx, y: rowY(1)}, {x: p.cx, y: rowY(2)});
        drawElbow({x: b.cx, y: rowY(1)}, {x: p.cx, y: rowY(2)});
      }
      for (let i=0;i<QF.length;i++){
        const a = R16[i*2], b = R16[i*2+1], p = QF[i];
        drawElbow({x: a.cx, y: rowY(2)}, {x: p.cx, y: rowY(3)});
        drawElbow({x: b.cx, y: rowY(2)}, {x: p.cx, y: rowY(3)});
      }
      for (let i=0;i<SF.length;i++){
        const a = QF[i*2], b = QF[i*2+1], p = SF[i];
        drawElbow({x: a.cx, y: rowY(3)}, {x: p.cx, y: rowY(4)});
        drawElbow({x: b.cx, y: rowY(3)}, {x: p.cx, y: rowY(4)});
      }
      drawElbow({x: SF[0].cx, y: rowY(4)}, {x: FINAL_CX, y: rowY(5)});
      drawElbow({x: SF[1].cx, y: rowY(4)}, {x: FINAL_CX, y: rowY(5)});
    }

    /************* TIMERS *************/
    function fmt(ms){ if(!ms || ms<=0) return '00:00:00';
      const s=Math.floor(ms/1000);
      const hh=String(Math.floor(s/3600)).padStart(2,'0');
      const mm=String(Math.floor((s%3600)/60)).padStart(2,'0');
      const ss=String(s%60).padStart(2,'0');
      return `${hh}:${mm}:${ss}`; }
    function startClocks(){
      const upd = ()=>{
        document.querySelectorAll('.timer').forEach(el=>{
          const ends = +el.dataset.ends || 0;
          const left = ends - Date.now();
          el.textContent = fmt(left);
        });
      };
      upd();
      clearInterval(startClocks._t);
      startClocks._t = setInterval(upd, 1000);
    }

    /************* PAN & ZOOM (boosted & fixed) *************/
    const layers=[wiresEl,nodesEl];
    let scale=0.8, minS=0.05, maxS=10.0, tx=40, ty=12;

    function apply(){
      // apply same transform to both layers so cards and wires stay aligned
      layers.forEach(el=>{
        el.style.transform=`translate(${tx}px,${ty}px) scale(${scale})`;
        el.style.transformOrigin='0 0';
      });
    }
    apply();

    function centerOnLoad(totalEntrants){
      const totalWidth = X_START + (totalEntrants-1)*X_GAP + CARD_W + X_START;
      const totalHeight = rowY(5) + CARD_H + 100;
      const view = viewport.getBoundingClientRect();
      const sx = (view.width - 40) / totalWidth;
      const sy = (view.height - 80) / totalHeight;
      scale = Math.max(minS, Math.min(maxS, Math.min(sx, sy)*0.95));
      tx = (view.width - totalWidth*scale)/2;
      ty = 12;
      apply();
    }

    // Wheel zoom (desktop)
    viewport.addEventListener('wheel',(e)=>{
      e.preventDefault();
      const r=viewport.getBoundingClientRect();
      const mx=(e.clientX-r.left-tx)/scale, my=(e.clientY-r.top-ty)/scale;
      const ds=e.deltaY<0?1.12:0.9;
      const ns=Math.min(maxS,Math.max(minS,scale*ds));
      tx = e.clientX-r.left - mx*ns; ty = e.clientY-r.top - my*ns; scale=ns; apply();
    },{passive:false});

    // Drag + pinch
    let dragging=false, lx=0, ly=0;
    const activePointers = new Map();
    let isPinching=false, pinchStartDist=0, pinchStartScale=1, pinchCenter=[0,0];

    viewport.addEventListener('pointerdown',e=>{
      viewport.setPointerCapture(e.pointerId);
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activePointers.size===1){ dragging=true; lx=e.clientX; ly=e.clientY; }
    });
    viewport.addEventListener('pointermove',e=>{
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activePointers.size===2){
        pinchUpdate();
      } else if (dragging){
        tx += e.clientX - lx; ty += e.clientY - ly; lx=e.clientX; ly=e.clientY; apply();
      }
    });
    viewport.addEventListener('pointerup',e=>{
      activePointers.delete(e.pointerId);
      if (activePointers.size<2) isPinching=false;
      if (activePointers.size===0) dragging=false;
    });
    viewport.addEventListener('pointercancel',e=>{
      activePointers.delete(e.pointerId);
      isPinching=false; dragging=false;
    });

    // Double-tap/Double-click zoom
    viewport.addEventListener('dblclick',(e)=>{
      const r=viewport.getBoundingClientRect();
      const mx=(e.clientX-r.left-tx)/scale, my=(e.clientY-r.top-ty)/scale;
      const factor = e.shiftKey ? 0.6 : 1.6;
      const ns=Math.min(maxS,Math.max(minS,scale*factor));
      tx = e.clientX-r.left - mx*ns; ty = e.clientY-r.top - my*ns; scale=ns; apply();
    });

    function distance(p1,p2){ const dx=p1.x-p2.x, dy=p1.y-p2.y; return Math.hypot(dx,dy); }
    function pinchUpdate(){
      const pts = [...activePointers.values()]; if (pts.length!==2) return;
      const p1=pts[0], p2=pts[1];
      if (!isPinching){
        isPinching=true; pinchStartDist = distance(p1,p2); pinchStartScale = scale;
        const r=viewport.getBoundingClientRect();
        pinchCenter = [(p1.x+p2.x)/2, (p1.y+p2.y)/2];
        return;
      }
      const r=viewport.getBoundingClientRect();
      const centerX = (pinchCenter[0]-r.left - tx)/scale;
      const centerY = (pinchCenter[1]-r.top  - ty)/scale;
      const dist = distance(p1,p2);
      const ns = Math.min(maxS, Math.max(minS, pinchStartScale * (dist/pinchStartDist)));
      tx = pinchCenter[0]-r.left - centerX*ns; ty = pinchCenter[1]-r.top - centerY*ns; scale = ns; apply();
    }

    // Buttons
    document.getElementById('zoomin').addEventListener('click', ()=> zoomBy(1.2));
    document.getElementById('zoomout').addEventListener('click', ()=> zoomBy(1/1.2));
    document.getElementById('zoomreset').addEventListener('click', ()=> centerOnLoad(32));
    function zoomBy(f){
      const r=viewport.getBoundingClientRect();
      const cx=r.width/2, cy=r.height/2;
      const mx=(cx-tx)/scale, my=(cy-ty)/scale;
      const ns=Math.min(maxS,Math.max(minS,scale*f));
      tx = cx - mx*ns; ty = cy - my*ns; scale=ns; apply();
    }

    // Keyboard shortcuts: + / - / 0
    window.addEventListener('keydown',(e)=>{
      if (e.target && /input|textarea|select|button/i.test(e.target.tagName)) return;
      if (e.key==='+' || e.key==='='){ e.preventDefault(); zoomBy(1.2); }
      if (e.key==='-'){ e.preventDefault(); zoomBy(1/1.2); }
      if (e.key==='0'){ e.preventDefault(); centerOnLoad(32); }
    });

    /************* GO *************/
    await build();
    window.addEventListener('resize', ()=> centerOnLoad(32));
  </script>
</body>
</html>