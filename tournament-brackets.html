<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — Tournament Brackets</title>
  <link rel="stylesheet" href="style.css?v=2" />
  <style>
    :root{
      --green:#39ff14; --red:#ff0033; --bg:#000; --ink:#e5ffe5; --border:#0f2510;
      --card:#070707; --muted:#8aff8a;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; background:#000; color:var(--green);
      font-family: ui-sans-serif,system-ui,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing: antialiased;
      overflow:hidden;
    }
    header{ max-width:960px; margin:10px auto 0; padding:0 16px; }
    .toolbar{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .btn{ border:1px solid var(--green); color:var(--green); text-decoration:none; padding:8px 12px; border-radius:10px; display:inline-flex; align-items:center; gap:8px; background:transparent; cursor:pointer; }

    /* Pan/zoom viewport */
    .viewport{
      position:fixed; inset:56px 8px 8px; border:1px solid var(--border); border-radius:14px; overflow:hidden;
      background:
        radial-gradient(1200px 800px at 70% -20%, rgba(57,255,20,0.08), transparent 60%),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0, rgba(255,255,255,.03) 2px, transparent 2px, transparent 4px),
        rgba(7,7,7,.45);
      touch-action: none; /* required for custom pinch/pan */
    }

    /* Big canvas so you can zoom far out */
    .layer{ position:absolute; top:0; left:0; width:3000px; height:2200px; transform-origin:0 0; }
    svg.wires{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0; }
    .nodes{ position:absolute; inset:0; z-index:1; }

    /* Cards */
    .node{ position:absolute; width:220px; }
    .card{
      border:1px solid var(--border); border-radius:12px; overflow:hidden; background:rgba(0,0,0,.55);
      box-shadow: 0 0 18px rgba(57,255,20,.08) inset; backdrop-filter: blur(1px);
    }
    .thumb{ display:block; width:100%; aspect-ratio:3/4; object-fit:cover; background:#050505; }
    .meta{ padding:8px 10px; border-top:1px solid var(--border); }
    .title{
      font-size:.9rem; line-height:1.2; margin:0 0 4px 0; color:var(--ink);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .timer,.votes{ font-variant-numeric:tabular-nums; opacity:.85; }
    .enter{ margin-top:6px; display:flex; justify-content:flex-end; }
    .enter .btn{ padding:5px 9px; font-size:.85rem }

    /* Entrant tiles are view-only (no button) */
    .entrant .enter{ display:none; }
    .entrant .title{ opacity:.9; }

    .hint{
      position:absolute; right:12px; bottom:8px; font-size:.85rem; opacity:.75;
      background:rgba(0,0,0,.45); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      pointer-events:none;
    }

    /* Zoom controls */
    .zoom-controls{
      position:absolute; right:12px; top:12px; display:flex; flex-direction:column; gap:8px; z-index:5;
    }
    .zoom-controls button{
      width:42px; height:42px; border-radius:10px; border:1px solid var(--green);
      background:rgba(0,0,0,.55); color:var(--green); font-weight:700; cursor:pointer;
    }

    @media (max-width:900px){ .viewport{ inset:64px 6px 6px } }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <h1 style="margin:0">R<span class="anarchy">Ⓐ</span>GE SPACE — TOURNAMENT</h1>
      <div style="display:flex; gap:8px">
        <a class="btn" href="matchup.html">⚔️ Random Battle</a>
        <a class="btn" href="menu.html">← Menu</a>
      </div>
    </div>
  </header>

  <div class="viewport" id="viewport">
    <svg class="layer wires" id="wires" viewBox="0 0 3000 2200" preserveAspectRatio="none"></svg>
    <div class="layer nodes" id="nodes"></div>

    <!-- On-screen zoom controls -->
    <div class="zoom-controls">
      <button id="zoomin"  aria-label="Zoom in">＋</button>
      <button id="zoomout" aria-label="Zoom out">－</button>
      <button id="zoomreset" aria-label="Reset zoom">⟳</button>
    </div>

    <div class="hint">Drag to move • Pinch/Scroll to zoom • Double-tap to zoom in</div>
  </div>

  <script>
    /************* CONFIG *************/
    function hours(h){ return Date.now()+h*3600*1000; }

    // 8 entrants (first round shown as one straight row)
    const ENTRANTS = [
      {name:'Seed 1', img:'https://picsum.photos/seed/e1/600/800', v:0},
      {name:'Seed 2', img:'https://picsum.photos/seed/e2/600/800', v:0},
      {name:'Seed 3', img:'https://picsum.photos/seed/e3/600/800', v:0},
      {name:'Seed 4', img:'https://picsum.photos/seed/e4/600/800', v:0},
      {name:'Seed 5', img:'https://picsum.photos/seed/e5/600/800', v:0},
      {name:'Seed 6', img:'https://picsum.photos/seed/e6/600/800', v:0},
      {name:'Seed 7', img:'https://picsum.photos/seed/e7/600/800', v:0},
      {name:'Seed 8', img:'https://picsum.photos/seed/e8/600/800', v:0},
    ];

    // Layout constants
    const CARD_W = 220;
    let   CARD_H = 320; // corrected after render

    const Y_R1    = 200;
    const Y_QF    = Y_R1 + 420;
    const Y_SEMI  = Y_QF + 420;
    const Y_FINAL = Y_SEMI + 420;

    const X_START = 100;
    const X_GAP   = 260;

    /************* DOM helpers *************/
    const viewport = document.getElementById('viewport');
    const nodesEl  = document.getElementById('nodes');
    const wiresEl  = document.getElementById('wires');

    function nodeHTML({id,x,y,a,b,ends,entrant=false}){
      return `
        <div class="node ${entrant?'entrant':''}" data-id="${id}" style="left:${x}px; top:${y}px">
          <article class="card" title="${entrant?'Entrant':'Open battle'}">
            <img class="thumb" src="${a.img}" alt="">
            <div class="meta">
              <h3 class="title">${entrant ? a.name : `${a.name} vs ${b.name}`}</h3>
              <div class="row">
                <span class="timer" data-ends="${ends}"></span>
                <span class="votes">${a.v}${entrant?'':` - ${b.v}`}</span>
              </div>
              <div class="enter"><a class="btn" href="matchup.html?battle=${id}">Enter</a></div>
            </div>
          </article>
        </div>`;
    }
    function addClickNav(){
      nodesEl.addEventListener('click',(e)=>{
        const tile = e.target.closest('.node');
        if (!tile || tile.classList.contains('entrant')) return;
        if (e.target.closest('a')) return;
        location.href = `matchup.html?battle=${tile.dataset.id}`;
      });
    }

    /************* BUILD LAYOUT *************/
    // Entrants row
    let html = '';
    const entrantCenters = [];
    ENTRANTS.forEach((p, i)=>{
      const x = X_START + i*X_GAP;
      entrantCenters.push(x + CARD_W/2);
      html += nodeHTML({ id:`E${i+1}`, x, y:Y_R1, a:p, b:p, ends:hours(8), entrant:true });
    });
    nodesEl.innerHTML = html;
    addClickNav();

    requestAnimationFrame(()=>{
      const anyCard = nodesEl.querySelector('.card');
      if (anyCard) CARD_H = anyCard.getBoundingClientRect().height;

      // QFs
      const qfX = [];
      for(let i=0;i<4;i++){
        const c = (entrantCenters[i*2] + entrantCenters[i*2+1]) / 2 - CARD_W/2;
        qfX.push(c);
        nodesEl.insertAdjacentHTML('beforeend', nodeHTML({
          id:`QF${i+1}`, x:c, y:Y_QF,
          a:{name:`E${i*2+1}`, img:ENTRANTS[i*2].img, v:0},
          b:{name:`E${i*2+2}`, img:ENTRANTS[i*2+1].img, v:0},
          ends:hours(12)
        }));
      }

      // Semis
      const semiX = [];
      for(let i=0;i<2;i++){
        const c = (qfX[i*2] + CARD_W/2 + qfX[i*2+1] + CARD_W/2) / 2 - CARD_W/2;
        semiX.push(c);
        nodesEl.insertAdjacentHTML('beforeend', nodeHTML({
          id:`SF${i+1}`, x:c, y:Y_SEMI,
          a:{name:`Winner QF${i*2+1}`, img:ENTRANTS[i*4].img, v:0},
          b:{name:`Winner QF${i*2+2}`, img:ENTRANTS[i*4+2].img, v:0},
          ends:hours(16)
        }));
      }

      // Final
      const finalCenter = (semiX[0] + CARD_W/2 + semiX[1] + CARD_W/2)/2 - CARD_W/2;
      nodesEl.insertAdjacentHTML('beforeend', nodeHTML({
        id:'FINAL', x:finalCenter, y:Y_FINAL,
        a:{name:'Winner SF1', img:ENTRANTS[0].img, v:0},
        b:{name:'Winner SF2', img:ENTRANTS[4].img, v:0},
        ends:hours(20)
      }));

      drawWires();
      centerOnLoad();
    });

    /************* WIRES *************/
    function rectOf(id){
      const el = nodesEl.querySelector(`[data-id="${id}"]`);
      return { x: parseFloat(el.style.left), y: parseFloat(el.style.top) };
    }
    function tc(r){ return [r.x + CARD_W/2, r.y]; }
    function bc(r){ return [r.x + CARD_W/2, r.y + CARD_H]; }
    function pathEl(d){
      const p=document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', d);
      p.setAttribute('fill','none');
      p.setAttribute('stroke','rgba(57,255,20,0.55)');
      p.setAttribute('stroke-width','2');
      p.setAttribute('shape-rendering','crispEdges');
      return p;
    }
    function elbow(fromRect, toRect){
      const [x1,y1]=bc(fromRect), [x2,y2]=tc(toRect);
      const midY=(y1+y2)/2;
      return `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
    }
    function drawWires(){
      wiresEl.innerHTML='';
      const pairs = [
        ['E1','QF1'], ['E2','QF1'],
        ['E3','QF2'], ['E4','QF2'],
        ['E5','QF3'], ['E6','QF3'],
        ['E7','QF4'], ['E8','QF4'],
        ['QF1','SF1'], ['QF2','SF1'],
        ['QF3','SF2'], ['QF4','SF2'],
        ['SF1','FINAL'], ['SF2','FINAL'],
      ];
      pairs.forEach(([a,b])=>{
        wiresEl.appendChild(pathEl(elbow(rectOf(a), rectOf(b))));
      });
    }

    /************* Timers *************/
    function fmt(ms){
      if(ms<=0) return '00:00:00';
      const s=Math.floor(ms/1000);
      const hh=String(Math.floor(s/3600)).padStart(2,'0');
      const mm=String(Math.floor((s%3600)/60)).padStart(2,'0');
      const ss=String(s%60).padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    }
    function tick(){
      document.querySelectorAll('.timer').forEach(el=>{
        const ends=+el.dataset.ends;
        el.textContent=fmt(ends-Date.now());
      });
    }
    tick(); const tId=setInterval(tick,1000);
    window.addEventListener('beforeunload',()=>clearInterval(tId));

    /************* PAN & ZOOM (wheel, pinch, double-tap, buttons) *************/
    const layers=[wiresEl,nodesEl];
    let scale=0.95, minS=0.10, maxS=3.0, tx=40, ty=12;

    function apply(){
      layers.forEach(el=>{
        el.style.transform=`translate(${tx}px,${ty}px) scale(${scale})`;
        el.style.transformOrigin='0 0';
      });
    }
    apply();

    // Auto-center on load
    function centerOnLoad(){
      const view = viewport.getBoundingClientRect();
      const totalWidth = X_START + (ENTRANTS.length-1)*X_GAP + CARD_W + X_START;
      const totalHeight = Y_FINAL + CARD_H + 80;
      const sx = (view.width - 40) / totalWidth;
      const sy = (view.height - 80) / totalHeight;
      scale = Math.max(minS, Math.min(maxS, Math.min(sx, sy)*0.95));
      tx = (view.width - totalWidth*scale)/2;
      ty = 12;
      apply();
    }

    // Wheel zoom (desktop)
    viewport.addEventListener('wheel',(e)=>{
      e.preventDefault();
      const r=viewport.getBoundingClientRect();
      const mx=(e.clientX-r.left-tx)/scale, my=(e.clientY-r.top-ty)/scale;
      const ds=e.deltaY<0?1.12:0.9;
      const ns=Math.min(maxS,Math.max(minS,scale*ds));
      tx = e.clientX-r.left - mx*ns;
      ty = e.clientY-r.top  - my*ns;
      scale=ns; apply();
    },{passive:false});

    // Drag to pan (single pointer)
    let dragging=false, lx=0, ly=0;
    viewport.addEventListener('pointerdown',e=>{
      viewport.setPointerCapture(e.pointerId);
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activePointers.size===1){ dragging=true; lx=e.clientX; ly=e.clientY; }
    });
    viewport.addEventListener('pointermove',e=>{
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activePointers.size===2){
        pinchUpdate(); // handled below
      } else if (dragging){
        tx += e.clientX - lx; ty += e.clientY - ly; lx = e.clientX; ly = e.clientY; apply();
      }
    });
    viewport.addEventListener('pointerup',e=>{
      activePointers.delete(e.pointerId);
      if (activePointers.size<2) isPinching=false;
      if (activePointers.size===0) dragging=false;
    });
    viewport.addEventListener('pointercancel',e=>{
      activePointers.delete(e.pointerId);
      isPinching=false; dragging=false;
    });

    // Double-tap zoom (mobile) / double-click (desktop)
    viewport.addEventListener('dblclick',(e)=>{
      const r=viewport.getBoundingClientRect();
      const mx=(e.clientX-r.left-tx)/scale, my=(e.clientY-r.top-ty)/scale;
      const factor = e.shiftKey ? 0.74 : 1.35;
      const ns=Math.min(maxS,Math.max(minS,scale*factor));
      tx = e.clientX-r.left - mx*ns;
      ty = e.clientY-r.top  - my*ns;
      scale=ns; apply();
    });

    // Pinch-to-zoom (two pointers)
    const activePointers = new Map(); // id -> {x,y}
    let isPinching=false, pinchStartDist=0, pinchStartScale=1, pinchCenter=[0,0];

    function distance(p1,p2){ const dx=p1.x-p2.x, dy=p1.y-p2.y; return Math.hypot(dx,dy); }
    function midpoint(p1,p2){ return [(p1.x+p2.x)/2, (p1.y+p2.y)/2]; }

    function pinchUpdate(){
      const pts = [...activePointers.values()];
      if (pts.length!==2) return;
      const p1=pts[0], p2=pts[1];

      if (!isPinching){
        isPinching=true;
        pinchStartDist = distance(p1,p2);
        pinchStartScale = scale;
        pinchCenter = midpoint(p1,p2);
        return;
      }
      const r=viewport.getBoundingClientRect();
      const centerX = (pinchCenter[0]-r.left - tx)/scale;
      const centerY = (pinchCenter[1]-r.top  - ty)/scale;

      const dist = distance(p1,p2);
      const ns = Math.min(maxS, Math.max(minS, pinchStartScale * (dist/pinchStartDist)));

      // keep the pinch center fixed
      tx = pinchCenter[0]-r.left - centerX*ns;
      ty = pinchCenter[1]-r.top  - centerY*ns;
      scale = ns; apply();
    }

    // On-screen zoom buttons
    document.getElementById('zoomin').addEventListener('click', ()=>{
      zoomBy(1.2);
    });
    document.getElementById('zoomout').addEventListener('click', ()=>{
      zoomBy(1/1.2);
    });
    document.getElementById('zoomreset').addEventListener('click', centerOnLoad);

    function zoomBy(factor){
      const r=viewport.getBoundingClientRect();
      // zoom around viewport center
      const cx=r.width/2, cy=r.height/2;
      const mx=(cx-tx)/scale, my=(cy-ty)/scale;
      const ns=Math.min(maxS,Math.max(minS,scale*factor));
      tx = cx - mx*ns; ty = cy - my*ns; scale=ns; apply();
    }
  </script>
</body>
</html>