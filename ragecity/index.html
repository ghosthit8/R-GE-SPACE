<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space ‚Äî City Proto</title>

  <style>
    :root {
      --green: #39ff14;
      --red: #ff0033;
    }

    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .home-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      right: 16px;
      padding: 8px 14px;
      border: 1px solid var(--green);
      border-radius: 8px;
      text-decoration: none;
      color: var(--green);
      background: transparent;
      font-weight: bold;
      text-shadow: 0 0 6px var(--green);
      z-index: 9999;
      pointer-events: auto;
    }
    .home-btn:hover {
      color: var(--red);
      border-color: var(--red);
      text-shadow: 0 0 6px var(--red);
    }

    .fullscreen-btn {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: 16px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(57, 255, 20, 0.8);
      background: rgba(0, 0, 0, 0.85);
      color: var(--green);
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.7);
      z-index: 9999;
      pointer-events: auto;
    }
    .fullscreen-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
    }

    #game-container {
      margin-top: 80px;
      margin-bottom: 8px;
      width: calc(100% - 24px);
      max-width: 720px;
      position: relative;
      height: 520px;
      border: 2px solid rgba(57, 255, 20, 0.9);
      box-shadow: 0 0 16px rgba(57, 255, 20, 0.8);
      background: #020202;
      overflow: hidden;
      margin-left: auto;
      margin-right: auto;
    }

    #game-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: rgba(57, 255, 20, 0.7);
      z-index: 1;
    }

    #art-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5;
      flex-direction: column;
    }

    #art-overlay-img {
      max-width: 90%;
      max-height: 80%;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(57, 255, 20, 0.8);
    }

    #art-overlay-msg {
      width: 100%;
      text-align: center;
      font-size: 18px;
      color: var(--green);
      text-shadow: 0 0 8px var(--green);
      margin-bottom: 12px;
      display: block;
    }

    .controls-overlay {
      position: fixed;
      left: 0;
      right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      z-index: 999;
      pointer-events: none;
    }

    .controls-inner {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 12px;
    }

    .dpad,
    .ab-buttons {
      pointer-events: auto;
    }

    .dpad {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 4px;
      opacity: 0.9;
    }

    .dpad button,
    .ab-buttons button {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid rgba(57, 255, 20, 0.8);
      border-radius: 12px;
      color: var(--green);
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(57, 255, 20, 0.9);
      touch-action: none;
    }

    .dpad button:active,
    .ab-buttons button:active {
      transform: scale(0.96);
      box-shadow: 0 0 4px rgba(57, 255, 20, 1);
      background: #000;
    }

    .dpad .empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .ab-buttons {
      position: relative;
      width: 180px;
      height: 140px;
      opacity: 0.9;
    }

    .ab-buttons button {
      position: absolute;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      font-size: 1.1rem;
    }

    .ab-buttons .btn-a::after,
    .ab-buttons .btn-b::after {
      display: block;
      font-size: 0.65rem;
      margin-top: 2px;
      letter-spacing: 2px;
    }
    .ab-buttons .btn-a::after {
      content: "A";
    }
    .ab-buttons .btn-b::after {
      content: "B";
    }

    .ab-buttons .btn-b {
      bottom: 10px;
      left: 30px;
    }
    .ab-buttons .btn-a {
      bottom: 40px;
      right: 25px;
    }

    @media (max-width: 600px) {
      #game-container {
        height: 480px;
      }
      .dpad {
        grid-template-columns: 52px 52px 52px;
        grid-template-rows: 52px 52px 52px;
      }
      .ab-buttons button {
        width: 56px;
        height: 56px;
      }
    }
  </style>
</head>
<body>
  <a class="home-btn" href="./menu.html">‚Üê Menu</a>

  <button id="btn-fullscreen" class="fullscreen-btn">‚õ∂ Fullscreen</button>

  <div id="game-container">
    <div id="game-fallback">Loading Rage City‚Ä¶</div>

    <div id="art-overlay">
      <div id="art-overlay-msg">Press "A" for fullscreen</div>
      <img
        id="art-overlay-img"
        src="https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=2000&q=80"
        alt="Gallery art"
      />
    </div>
  </div>

  <div class="controls-overlay">
    <div class="controls-inner">
      <div class="dpad">
        <button class="empty" disabled></button>
        <button id="btn-up">‚ñ≤</button>
        <button class="empty" disabled></button>

        <button id="btn-left">‚óÄ</button>
        <button class="empty" disabled></button>
        <button id="btn-right">‚ñ∂</button>

        <button class="empty" disabled></button>
        <button id="btn-down">‚ñº</button>
        <button class="empty" disabled></button>
      </div>

      <div class="ab-buttons">
        <button id="btn-b" class="btn-b">‚óè</button>
        <button id="btn-a" class="btn-a">‚óè</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <script>
    const inputState = {
      left: false,
      right: false,
      up: false,
      down: false,
      A: false,
      B: false
    };

    const PAINTING_FULL_URL =
      "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=2000&q=80";
    const SCULPTURE_FULL_URL =
      "https://images.unsplash.com/photo-1582719478250-c89cae4dc85b?auto=format&fit=crop&w=2000&q=80";

    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      parent: "game-container",
      pixelArt: false,
      backgroundColor: "#111122",
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      physics: {
        default: "arcade",
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      },
      scene: { preload, create, update }
    };

    let player;
    let promptText;
    let artOpen = false;
    let prevA = false;
    let prevB = false;

    let galleryFrames = [];
    let sculptureSpot = null;
    let wallsGroup;

    const artOverlayEl = document.getElementById("art-overlay");
    const artImg = document.getElementById("art-overlay-img");
    const artMsg = document.getElementById("art-overlay-msg");

    function preload() {
      this.load.image(
        "artThumb",
        "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=1000&q=80"
      );
    }

    function create() {
      const fb = document.getElementById("game-fallback");
      if (fb) fb.style.display = "none";

      const w = this.scale.width;
      const h = this.scale.height;

      this.physics.world.setBounds(0, 0, w, h);
      wallsGroup = this.physics.add.staticGroup();
      const scene = this;

      function addWallRect(x1, y1, x2, y2, thickness = 14) {
        if (x1 === x2 && y1 !== y2) {
          const height = Math.abs(y2 - y1);
          const centerY = (y1 + y2) / 2;
          const wall = scene.add.rectangle(x1, centerY, thickness, height, 0x00ff00, 0);
          wall.setVisible(false);
          scene.physics.add.existing(wall, true);
          wallsGroup.add(wall);
        } else if (y1 === y2 && x1 !== x2) {
          const width = Math.abs(x2 - x1);
          const centerX = (x1 + x2) / 2;
          const wall = scene.add.rectangle(centerX, y1, width, thickness, 0x00ff00, 0);
          wall.setVisible(false);
          scene.physics.add.existing(wall, true);
          wallsGroup.add(wall);
        }
      }

      function addWallBlock(x, y, size = 16) {
        const wall = scene.add.rectangle(x, y, size, size, 0x00ff00, 0);
        wall.setVisible(false);
        scene.physics.add.existing(wall, true);
        wallsGroup.add(wall);
      }

      // ==== ROOM GEOMETRY ====
      const marginX = 60;
      const marginY = 90;

      const leftOuter = marginX;
      const rightOuter = w - marginX;
      const topOuter = marginY;
      const bottomOuter = h - marginY;

      const corridorWidth = 32;
      const leftInner = leftOuter + corridorWidth;
      const rightInner = rightOuter - corridorWidth;
      const topInner = topOuter + corridorWidth;
      const bottomInner = bottomOuter - corridorWidth;

      const doorWidth = 90;

      const doorCenterY = topInner + (bottomInner - topInner) * 0.65;
      const gapOuterTopY = doorCenterY - doorWidth / 2;
      const gapOuterBotY = doorCenterY + doorWidth / 2;

      const gapInnerTopY = doorCenterY - doorWidth / 2;
      const gapInnerBotY = doorCenterY + doorWidth / 2;

      // Outer wall
      const wallOuter = this.add.graphics();
      wallOuter.lineStyle(4, 0xffffff, 1);
      wallOuter.beginPath();
      wallOuter.moveTo(leftOuter, topOuter);
      wallOuter.lineTo(rightOuter, topOuter);
      wallOuter.lineTo(rightOuter, bottomOuter);
      wallOuter.lineTo(leftOuter, bottomOuter);
      wallOuter.lineTo(leftOuter, gapOuterBotY);
      wallOuter.moveTo(leftOuter, gapOuterTopY);
      wallOuter.lineTo(leftOuter, topOuter);
      wallOuter.strokePath();

      // Inner wall
      const wallInner = this.add.graphics();
      wallInner.lineStyle(4, 0xffffff, 1);
      wallInner.beginPath();
      wallInner.moveTo(leftInner, topInner);
      wallInner.lineTo(rightInner, topInner);
      wallInner.lineTo(rightInner, bottomInner);
      wallInner.lineTo(leftInner, bottomInner);
      wallInner.lineTo(leftInner, gapInnerBotY);
      wallInner.moveTo(leftInner, gapInnerTopY);
      wallInner.lineTo(leftInner, topInner);
      wallInner.strokePath();

      // Diagonals
      const diag = this.add.graphics();
      diag.lineStyle(4, 0xffffff, 1);
      diag.beginPath();
      diag.moveTo(leftOuter, topOuter);
      diag.lineTo(leftInner, topInner);
      diag.moveTo(rightOuter, topOuter);
      diag.lineTo(rightInner, topInner);
      diag.moveTo(rightOuter, bottomOuter);
      diag.lineTo(rightInner, bottomInner);
      diag.moveTo(leftOuter, bottomOuter);
      diag.lineTo(leftInner, bottomInner);
      diag.strokePath();

      // Ledges
      const ledges = this.add.graphics();
      ledges.lineStyle(4, 0xffffff, 1);
      const ledgeLength = leftInner - leftOuter;
      const upperLedgeY = gapInnerTopY;
      const lowerLedgeY = gapInnerBotY;
      ledges.beginPath();
      ledges.moveTo(leftOuter, upperLedgeY);
      ledges.lineTo(leftOuter + ledgeLength, upperLedgeY);
      ledges.moveTo(leftOuter, lowerLedgeY);
      ledges.lineTo(leftOuter + ledgeLength, lowerLedgeY);
      ledges.strokePath();

      // WALL COLLIDERS
      addWallRect(leftOuter, topOuter, rightOuter, topOuter);
      addWallRect(rightOuter, topOuter, rightOuter, bottomOuter);
      addWallRect(leftOuter, bottomOuter, rightOuter, bottomOuter);
      addWallRect(leftOuter, topOuter, leftOuter, gapOuterTopY);
      addWallRect(leftOuter, gapOuterBotY, leftOuter, bottomOuter);

      addWallRect(leftInner, topInner, rightInner, topInner);
      addWallRect(rightInner, topInner, rightInner, bottomInner);
      addWallRect(leftInner, bottomInner, rightInner, bottomInner);
      addWallRect(leftInner, topInner, leftInner, gapInnerTopY);
      addWallRect(leftInner, gapInnerBotY, leftInner, bottomInner);

      addWallRect(leftOuter, upperLedgeY, leftOuter + ledgeLength, upperLedgeY);
      addWallRect(leftOuter, lowerLedgeY, leftOuter + ledgeLength, lowerLedgeY);

      const steps = 6;
      for (let i = 0; i <= steps; i++) {
        let t = i / steps;
        let x = Phaser.Math.Linear(leftOuter, leftInner, t);
        let y = Phaser.Math.Linear(topOuter, topInner, t);
        addWallBlock(x, y, 14);
        x = Phaser.Math.Linear(rightOuter, rightInner, t);
        y = Phaser.Math.Linear(topOuter, topInner, t);
        addWallBlock(x, y, 14);
        x = Phaser.Math.Linear(rightOuter, rightInner, t);
        y = Phaser.Math.Linear(bottomOuter, bottomInner, t);
        addWallBlock(x, y, 14);
        x = Phaser.Math.Linear(leftOuter, leftInner, t);
        y = Phaser.Math.Linear(bottomOuter, bottomInner, t);
        addWallBlock(x, y, 14);
      }

      // Player
      player = this.add.rectangle(leftOuter - 20, doorCenterY, 20, 20, 0x39ff14);
      this.physics.add.existing(player);
      player.body.setCollideWorldBounds(true);
      this.physics.add.collider(player, wallsGroup);

      // FRAMES
      const tex = this.textures.get("artThumb").getSourceImage();
      const natW = tex.width;
      const natH = tex.height;
      const imgMaxW = 26;
      const imgMaxH = 26;
      const imgScale = Math.min(imgMaxW / natW, imgMaxH / natH);
      galleryFrames = [];

      function addTrapezoidFrame(scene2, x, y, side) {
        const g = scene2.add.graphics();
        g.lineStyle(3, 0x39ff14, 1);
        const wTop = 18;
        const wBottom = 28;
        const h2 = 26;
        const skew = 5;
        let points;
        if (side === "left") {
          points = [
            { x: -wBottom / 2, y: -h2 / 2 },
            { x:  wTop / 2,    y: -h2 / 2 + skew },
            { x:  wTop / 2,    y:  h2 / 2 - skew },
            { x: -wBottom / 2, y:  h2 / 2 }
          ];
        } else if (side === "right") {
          points = [
            { x: -wTop / 2,    y: -h2 / 2 + skew },
            { x:  wBottom / 2, y: -h2 / 2 },
            { x:  wBottom / 2, y:  h2 / 2 },
            { x: -wTop / 2,    y:  h2 / 2 - skew }
          ];
        } else if (side === "top") {
          points = [
            { x: -wBottom / 2, y: -h2 / 2 },
            { x:  wBottom / 2, y: -h2 / 2 },
            { x:  wTop / 2,    y:  h2 / 2 },
            { x: -wTop / 2,    y:  h2 / 2 }
          ];
        } else {
          points = [
            { x: -wTop / 2,    y: -h2 / 2 },
            { x:  wTop / 2,    y: -h2 / 2 },
            { x:  wBottom / 2, y:  h2 / 2 },
            { x: -wBottom / 2, y:  h2 / 2 }
          ];
        }

        g.beginPath();
        g.moveTo(x + points[0].x, y + points[0].y);
        for (let i = 1; i < points.length; i++) {
          g.lineTo(x + points[i].x, y + points[i].y);
        }
        g.closePath();
        g.strokePath();

        const gMat = scene2.add.graphics();
        gMat.lineStyle(2, 0x1a8f3a, 1);
        gMat.fillStyle(0x000000, 1);
        const matScale = 0.78;
        gMat.beginPath();
        gMat.moveTo(
          x + points[0].x * matScale,
          y + points[0].y * matScale
        );
        for (let i = 1; i < points.length; i++) {
          gMat.lineTo(
            x + points[i].x * matScale,
            y + points[i].y * matScale
          );
        }
        gMat.closePath();
        gMat.fillPath();
        gMat.strokePath();

        const img = scene2.add.image(x, y, "artThumb");
        img.setScale(imgScale * 0.9);

        galleryFrames.push({
          x,
          y,
          side,
          frameGfx: g,
          matGfx: gMat,
          img,
          fullUrl: PAINTING_FULL_URL
        });
      }

      const midLeftX   = (leftOuter  + leftInner)  / 2;
      const midRightX  = (rightOuter + rightInner) / 2;
      const midTopY    = (topOuter   + topInner)   / 2;
      const midBottomY = (bottomOuter+ bottomInner)/ 2;

      const topCount = 4;
      const topStartX = leftInner + 35;
      const topEndX   = rightInner - 35;
      for (let i = 0; i < topCount; i++) {
        const t = topCount === 1 ? 0.5 : i / (topCount - 1);
        const x = Phaser.Math.Linear(topStartX, topEndX, t);
        addTrapezoidFrame(this, x, midTopY, "top");
      }

      const rightCount = 4;
      for (let i = 0; i < rightCount; i++) {
        const t = i / (rightCount - 1);
        const y = Phaser.Math.Linear(topInner + 40, bottomInner - 40, t);
        addTrapezoidFrame(this, midRightX, y, "right");
      }

      const leftYPositions = [
        topInner + 55,
        gapInnerTopY - 22
      ];
      leftYPositions.forEach((y) => {
        addTrapezoidFrame(this, midLeftX, y, "left");
      });

      const bottomPositions = [
        leftInner + 24,
        leftInner + 90,
        (leftInner + rightInner) / 2,
        rightInner - 90,
        rightInner - 24
      ];
      bottomPositions.forEach((x) => {
        addTrapezoidFrame(this, x, midBottomY, "bottom");
      });

      // ===== SCULPTURE CUBE =====
      const centerX = (leftOuter + rightOuter) / 2;
      const centerY = (topOuter + bottomOuter) / 2;
      const sculptureX = centerX + 35;
      const sculptureY = centerY + 60;

      const cube = this.add.graphics();
      cube.lineStyle(3, 0xffffff, 1);

      const size = 46;   // outer front square
      const depth = 10;

      const frontX = sculptureX - size / 2;
      const frontY = sculptureY - size / 2;
      cube.strokeRect(frontX, frontY, size, size);

      const backX = frontX - depth;
      const backY = frontY - depth;
      cube.strokeRect(backX, backY, size, size);

      cube.beginPath();
      cube.moveTo(frontX, frontY);
      cube.lineTo(backX, backY);
      cube.moveTo(frontX + size, frontY);
      cube.lineTo(backX + size, backY);
      cube.moveTo(frontX, frontY + size);
      cube.lineTo(backX, backY + size);
      cube.moveTo(frontX + size, frontY + size);
      cube.lineTo(backX + size, backY + size);
      cube.strokePath();

      const innerSize = 22; // inner green
      const inner = this.add.rectangle(
        sculptureX,
        sculptureY,
        innerSize,
        innerSize,
        0x000000
      );
      inner.setStrokeStyle(2, 0x39ff14, 1);

      sculptureSpot = {
        x: sculptureX,
        y: sculptureY,
        fullUrl: SCULPTURE_FULL_URL,
        type: "sculpture"
      };

      // ===== COLLIDER: first white square, expanded top + left =====
      // ===== COLLIDER: first white square, adjustable on all sides =====
const midSize = (size + innerSize) / 2;

// how far to push each side out (+) or pull in (-)
const expandLeft   = 18;
const expandRight  = -3;  // üëâ increase to expand right edge
const expandTop    = 18;
const expandBottom = -3;  // üëâ increase to expand bottom edge

const colliderWidth  = midSize + expandLeft + expandRight;
const colliderHeight = midSize + expandTop + expandBottom;

const frontCollider = this.add.rectangle(
  sculptureX + (expandRight - expandLeft) / 2,
  sculptureY + (expandBottom - expandTop) / 2,
  colliderWidth,
  colliderHeight,
  0x00ff00,
  0
);
frontCollider.setVisible(false);
this.physics.add.existing(frontCollider, true);
wallsGroup.add(frontCollider);

      // prompt text
      promptText = this.add.text(w / 2, h - 40, "", {
        fontFamily:
          "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
        fontSize: "14px",
        color: "#39ff14"
      });
      promptText.setOrigin(0.5);
      promptText.setVisible(false);

      this.scale.on("resize", (gameSize) => {
        promptText.setPosition(gameSize.width / 2, gameSize.height - 40);
      });

      setupKeyboard(this);
      setupTouchButton("btn-left", "left");
      setupTouchButton("btn-right", "right");
      setupTouchButton("btn-up", "up");
      setupTouchButton("btn-down", "down");
      setupTouchButton("btn-a", "A");
      setupTouchButton("btn-b", "B");
      setupFullscreenButton();

      artOverlayEl.addEventListener("click", () => {
        if (artOpen) closeArtOverlay();
      });
    }

    function setupKeyboard(scene) {
      scene.input.keyboard.on("keydown", (event) => {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = true;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = true;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = true;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = true;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = true;
            break;
          case "KeyX":
            inputState.B = true;
            break;
        }
      });

      scene.input.keyboard.on("keyup", (event) => {
        switch (event.code) {
          case "ArrowLeft":
          case "KeyA":
            inputState.left = false;
            break;
          case "ArrowRight":
          case "KeyD":
            inputState.right = false;
            break;
          case "ArrowUp":
          case "KeyW":
            inputState.up = false;
            break;
          case "ArrowDown":
          case "KeyS":
            inputState.down = false;
            break;
          case "KeyZ":
          case "Enter":
            inputState.A = false;
            break;
          case "KeyX":
            inputState.B = false;
            break;
        }
      });
    }

    function setupTouchButton(id, key) {
      const el = document.getElementById(id);
      if (!el) return;

      function setPressed(pressed) {
        inputState[key] = pressed;
      }

      function start(e) {
        e.preventDefault();
        setPressed(true);
      }
      function end(e) {
        e.preventDefault();
        setPressed(false);
      }

      el.addEventListener("mousedown", start);
      el.addEventListener("mouseup", end);
      el.addEventListener("mouseleave", end);

      el.addEventListener("touchstart", start, { passive: false });
      el.addEventListener("touchend", end, { passive: false });
      el.addEventListener("touchcancel", end, { passive: false });
    }

    function setupFullscreenButton() {
      const btn = document.getElementById("btn-fullscreen");
      if (!btn) return;

      btn.addEventListener("click", () => {
        const elem = document.documentElement;
        if (!document.fullscreenElement) {
          if (elem.requestFullscreen) elem.requestFullscreen();
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      });

      document.addEventListener("fullscreenchange", () => {
        if (!btn) return;
        btn.textContent = document.fullscreenElement
          ? "‚õ∂ Exit Fullscreen"
          : "‚õ∂ Fullscreen";
      });
    }

    function update(time, delta) {
      if (!player || !player.body) return;

      const justPressedA = inputState.A && !prevA;
      const justPressedB = inputState.B && !prevB;

      if (artOpen) {
        if (justPressedA) toggleArtFullscreen();
        if (justPressedB) closeArtOverlay();
        prevA = inputState.A;
        prevB = inputState.B;
        return;
      }

      const speed = 120;
      let vx = 0;
      let vy = 0;

      if (inputState.left) vx -= 1;
      if (inputState.right) vx += 1;
      if (inputState.up) vy -= 1;
      if (inputState.down) vy += 1;

      if (vx !== 0 || vy !== 0) {
        const len = Math.sqrt(vx * vx + vy * vy);
        vx = (vx / len) * speed;
        vy = (vy / len) * speed;
      }

      player.body.setVelocity(vx, vy);

      let nearestItem = null;
      let nearestDist = Infinity;

      galleryFrames.forEach((f) => {
        const d = Phaser.Math.Distance.Between(player.x, player.y, f.x, f.y);
        if (d < nearestDist) {
          nearestDist = d;
          nearestItem = { type: "painting", fullUrl: f.fullUrl };
        }
      });

      if (sculptureSpot) {
        const d = Phaser.Math.Distance.Between(
          player.x,
          player.y,
          sculptureSpot.x,
          sculptureSpot.y
        );
        if (d < nearestDist) {
          nearestDist = d;
          nearestItem = { type: "sculpture", fullUrl: sculptureSpot.fullUrl };
        }
      }

      if (promptText) {
        if (nearestItem && nearestDist < 80) {
          promptText.setVisible(true);
          promptText.setText(
            nearestItem.type === "sculpture"
              ? "Press A to inspect sculpture"
              : "Press A to view art"
          );
        } else {
          promptText.setVisible(false);
        }
      }

      if (nearestItem && nearestDist < 60 && justPressedA) {
        openArtOverlay(nearestItem.fullUrl);
      }

      prevA = inputState.A;
      prevB = inputState.B;
    }

    function openArtOverlay(imageUrl) {
      artOpen = true;
      if (imageUrl && artImg) artImg.src = imageUrl;
      if (artOverlayEl) artOverlayEl.style.display = "flex";
      if (promptText) promptText.setVisible(false);
      if (artMsg) artMsg.style.display = "block";
    }

    function closeArtOverlay() {
      artOpen = false;
      if (artOverlayEl) artOverlayEl.style.display = "none";
      if (artMsg) artMsg.style.display = "none";

      if (
        (document.fullscreenElement === artImg ||
          document.webkitFullscreenElement === artImg) &&
        document.exitFullscreen
      ) {
        document.exitFullscreen();
      }
    }

    function toggleArtFullscreen() {
      if (artMsg) artMsg.style.display = "none";
      if (
        document.fullscreenElement === artImg ||
        document.webkitFullscreenElement === artImg
      ) {
        if (document.exitFullscreen) document.exitFullscreen();
      } else {
        if (artImg.requestFullscreen) {
          artImg.requestFullscreen();
        }
      }
    }

    new Phaser.Game(config);
  </script>
</body>
</html>