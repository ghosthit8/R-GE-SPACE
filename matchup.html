<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rage Space ‚Äî Tournament (Shared Timers + Realtime Votes)</title>
<style>
  :root{ --green:#39ff14; --border:#0f2510; --ink:#e5ffe5; --bg:#000; --card:#070707; --pink:#ff1f8f; --blue:#00e5ff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:#000;color:var(--green);font-family:ui-sans-serif,system-ui,Arial}
  a.btn,button.btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;text-decoration:none;display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;padding:10px 14px}
  .app{display:grid;grid-template-columns: 360px 1fr;gap:14px;height:calc(100vh - 56px);padding:0 14px 14px}

  /* Left list */
  .listWrap{border:1px solid var(--border);border-radius:12px;overflow:hidden;background:rgba(7,7,7,.55);display:flex;flex-direction:column;min-height:0}
  .listHead{padding:10px 12px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;gap:10px}
  .listHeadRight{display:flex;align-items:center;gap:10px}
  .list{overflow:auto;flex:1;min-height:0}
  .matchItem{display:grid;grid-template-columns:64px 1fr auto;gap:10px;align-items:center;padding:10px;border-bottom:1px solid rgba(15,37,16,.6);cursor:pointer}
  .matchItem:hover{background:rgba(57,255,20,.05)}
  .thumbMini{width:64px;height:64px;background:#050505;border-radius:8px;overflow:hidden;display:flex;flex:0 0 auto}
  .thumbMini img{width:50%;object-fit:cover}
  .title{color:var(--ink);font-size:.95rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .metaRow{display:flex;gap:8px;align-items:center}
  .badge{font-size:.75rem;border:1px solid var(--border);border-radius:8px;padding:2px 6px;opacity:.85}
  .timer{font-variant-numeric:tabular-nums;opacity:.85}
  .selected{outline:2px solid rgba(57,255,20,.55);outline-offset:-2px}

  /* Right detail */
  .detail{border:1px solid var(--border);border-radius:12px;overflow:hidden;background:rgba(7,7,7,.55);display:flex;flex-direction:column;min-height:0}
  .detailHead{padding:10px 12px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}
  .stage{display:grid;grid-template-columns:1fr 1fr;gap:16px;padding:14px}
  @media (max-width:820px){ .stage{ grid-template-columns:1fr; gap:22px; } }
  .tile{border:1px solid var(--border);border-radius:12px;overflow:hidden;background:rgba(7,7,7,.6);position:relative;display:flex;flex-direction:column}

  /* Frame + image fit (bigger/taller rectangle) */
  .frame{
    position:relative; width:100%; aspect-ratio:4/3;
    background:#050505; border-bottom:1px solid var(--border); overflow:hidden;
  }
  @media (max-width:1000px){ .frame{ aspect-ratio:3/4; max-height:72vh; } }
  .art{
    position:absolute; inset:0; margin:auto; max-width:100%; max-height:100%;
    width:auto; height:auto; object-fit:contain; display:block; background:#000;
  }

  .tbd{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:3rem;font-weight:900;color:rgba(57,255,20,.75);pointer-events:none}
  .tileMeta{display:flex;justify-content:space-between;gap:8px;padding:10px;align-items:center}

  .countdown{padding:0 14px 10px}
  .actions{padding:0 14px 14px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .hint{opacity:.75;padding:0 14px 14px}
  .choice.btn{border-style:solid}
  .choice.btn.active{box-shadow:0 0 0 2px rgba(57,255,20,.6) inset}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0a0a0a;border:1px solid var(--border);color:var(--ink);padding:8px 12px;border-radius:10px;display:none;z-index:50}
  .timer:not([data-ends]){display:none}
  @media (max-width:900px){ .app{grid-template-columns:1fr;height:auto} .detail{order:-1} }

  /* Fullscreen icon */
  .fsIcon{
    position:absolute; top:8px; right:8px; width:22px; height:22px; border-radius:6px;
    border:1px solid rgba(57,255,20,.7); background:rgba(0,0,0,.5);
    display:grid; place-items:center; font-size:12px; line-height:1;
    opacity:.9; backdrop-filter: blur(2px); cursor:pointer; z-index:2;
  }
  .fsIcon:hover{opacity:1} .fsIcon:active{transform:scale(.98)}

  /* Winner overlay (unchanged visuals) */
  .championOverlay{
    position:fixed; inset:0; display:none; place-items:center; z-index:9999;
    background: radial-gradient(1000px 600px at 70% -10%, rgba(57,255,20,.09), transparent 60%),
               radial-gradient(900px 700px at 20% 110%, rgba(0,229,255,.08), transparent 60%),
               rgba(0,0,0,.92);
    overflow:hidden;
  }
  .championOverlay.show{ display:grid; animation:fadeIn .3s ease-out both; }
  @keyframes fadeIn{ from{opacity:0} to{opacity:1} }
  .scanlines::before{
    content:""; position:absolute; inset:0;
    background: repeating-linear-gradient(to bottom, rgba(255,255,255,.06), rgba(255,255,255,.06) 1px, transparent 1px, transparent 3px);
    mix-blend-mode:overlay; pointer-events:none; opacity:.2;
  }
  .crtGlow{ filter: drop-shadow(0 0 16px rgba(57,255,20,.55)) drop-shadow(0 0 32px rgba(0,229,255,.35)); }
  .championCard{
    position:relative; width:min(900px, 92vw); border:1px solid var(--green);
    border-radius:18px; background:linear-gradient(to bottom right, rgba(7,7,7,.85), rgba(7,7,7,.75));
    padding:18px; display:grid; grid-template-columns: 340px 1fr; gap:18px;
  }
  @media (max-width:800px){ .championCard{ grid-template-columns:1fr } }
  .championArt{ border:1px solid var(--border); border-radius:14px; overflow:hidden; background:#050505; aspect-ratio:4/5; width:100%; object-fit:cover; }
  .championMeta{ display:flex; flex-direction:column; gap:12px; justify-content:center; position:relative; }
  .glitchTitle{
    font-size: clamp(28px, 5.5vw, 68px); font-weight:900; letter-spacing:.02em;
    text-transform:uppercase; position:relative; line-height:1;
  }
  .glitchTitle::before, .glitchTitle::after{ content:attr(data-text); position:absolute; inset:0; pointer-events:none; }
  .glitchTitle::before{ left:-2px; text-shadow: -2px 0 var(--pink); animation:glitch 2s infinite ease-in-out alternate-reverse; }
  .glitchTitle::after{  left: 2px; text-shadow:  2px 0 var(--blue); animation:glitch 2.2s infinite ease-in-out alternate; }
  @keyframes glitch{
    0%{clip-path: inset(0 0 85% 0);} 10%{clip-path: inset(10% 0 70% 0);}
    20%{clip-path: inset(85% 0 0 0);} 30%{clip-path: inset(40% 0 40% 0);}
    40%{clip-path: inset(0 0 85% 0);} 50%{clip-path: inset(60% 0 20% 0);}
    60%{clip-path: inset(20% 0 60% 0);} 70%{clip-path: inset(0 0 85% 0);}
    80%{clip-path: inset(80% 0 5% 0);} 100%{clip-path: inset(10% 0 70% 0);}
  }
  .winnerName{ font-size: clamp(16px, 2.2vw, 24px); color:var(--ink); border:1px solid var(--border); padding:8px 10px; border-radius:10px; display:inline-block; background: rgba(0,0,0,.35); }

  /* Fullscreen fit */
  img.art:fullscreen,
  img.art:-webkit-full-screen,
  img.art:-ms-fullscreen{
    width:100vw !important; height:100vh !important;
    max-width:100vw !important; max-height:100vh !important;
    object-fit:contain !important; aspect-ratio:auto !important; background:#000;
  }
</style>
</head>
<body>
  <header>
    <h1 style="margin:0">R<span style="letter-spacing:.03em">‚í∂</span>GE SPACE ‚Äî TOURNAMENT</h1>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="btnReset" class="btn">üîÅ Reset test</button>
      <button id="btnForce" class="btn">‚ö° Force decide (selected)</button>
      <button id="btnClearVotes" class="btn">üßπ Clear my votes</button>
      <a class="btn" href="#" onclick="return false">üèÅ Bracket (coming soon)</a>
    </div>
  </header>

  <div class="app">
    <section class="listWrap">
      <div class="listHead">
        <strong>Bracket</strong>
        <div class="listHeadRight">
          <span class="badge" id="roundSummary">R32 ‚Üí Final</span>
          <label style="display:inline-flex;align-items:center;gap:6px;font-size:.85rem;opacity:.9">
            <input type="checkbox" id="toggleFinished"> Show finished rounds
          </label>
        </div>
      </div>
      <div class="list" id="matchList"></div>
    </section>

    <section class="detail">
      <div class="detailHead">
        <div>
          <span class="badge" id="detailRound">Round ‚Äì</span>
          <span class="badge" id="detailIndex">Match ‚Äì/‚Äì</span>
        </div>
        <span class="badge" id="detailState">‚Äî</span>
      </div>

      <div class="countdown">Decision in: <span class="timer" id="detailClock">00:00:00</span></div>

      <div class="stage">
        <!-- TOP tile -->
        <div class="tile" id="tileLeft">
          <div class="frame">
            <img id="leftArt" class="art" alt="">
            <button class="fsIcon" id="fsLeft" aria-label="Fullscreen top">‚§¢</button>
            <div id="leftTbd" class="tbd" style="display:none">?</div>
          </div>
          <div class="tileMeta">
            <span id="leftName">TBD</span>
            <span class="badge" id="leftVotes">0</span>
          </div>
        </div>

        <!-- BOTTOM tile -->
        <div class="tile" id="tileRight">
          <div class="frame">
            <img id="rightArt" class="art" alt="">
            <button class="fsIcon" id="fsRight" aria-label="Fullscreen bottom">‚§¢</button>
            <div id="rightTbd" class="tbd" style="display:none">?</div>
          </div>
          <div class="tileMeta">
            <span id="rightName">TBD</span>
            <span class="badge" id="rightVotes">0</span>
          </div>
        </div>
      </div>

      <div class="actions">
        <button id="btnLeft" class="btn choice">Vote TOP</button>
        <button id="btnRight" class="btn choice">Vote BOTTOM</button>
        <button id="btnSubmit" class="btn" disabled>‚úÖ Submit Vote</button>
        <span id="voteLock" class="badge" style="display:none">You voted.</span>
      </div>
      <div class="hint">which side are you on... One vote per match.</div>
    </section>
  </div>

  <div id="toast" class="toast"></div>

  <!-- Winner Overlay -->
  <div id="championOverlay" class="championOverlay scanlines">
    <button id="btnCloseChampion" class="btnClose">‚úñ</button>
    <div class="championCard crtGlow">
      <img id="championArt" class="championArt" alt="Champion art">
      <div class="championMeta">
        <div class="subBadge">üèÜ FINAL ‚Äî WINNER</div>
        <div id="championTitle" class="glitchTitle" data-text="CHAMPION">CHAMPION</div>
        <div id="championName" class="winnerName">‚Äî</div>
        <div style="opacity:.8">Glory to the machine. Your art devours the bracket.</div>
      </div>
      <div id="fxLayer" class="fxBurst"></div>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script type="module">
  /********* Config *********/
  const ROUND_MS = 30000; // 30 seconds per match

  /********* Supabase *********/
  const SUPABASE_URL  = 'https://YOUR-PROJECT.supabase.co';   // <-- replace
  const SUPABASE_ANON = 'YOUR_PUBLIC_ANON_KEY';               // <-- replace
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
  const MATCH_TABLE = 'matches';
  const toIso = (ms)=> new Date(ms).toISOString();
  const nowMs = ()=> Date.now();

  /********* Helpers *********/
  const BLANK='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
  const roundLabel = ['','R32','R16','QF','SF','FINAL'];

  // Vote-lock (per-browser)
  const VOTE_NS = 'rs_stack_vote_v2_';
  const LEGACY_NS = 'rs_stack_vote_';
  const lockKey = (id)=> `${VOTE_NS}${id}`;
  const clearVoteLocks = ()=>{
    const keys=[]; for(let i=0;i<localStorage.length;i++){ const k=localStorage.key(i); if(k && (k.startsWith(VOTE_NS)||k.startsWith(LEGACY_NS))) keys.push(k); }
    keys.forEach(k=>localStorage.removeItem(k));
  };

  const fmt = (ms)=>{ if(ms<=0) return '00:00:00'; const s=Math.floor(ms/1000);
    return String(Math.floor(s/3600)).padStart(2,'0')+':' +
           String(Math.floor((s%3600)/60)).padStart(2,'0')+':' +
           String(s%60).padStart(2,'0'); };

  const toast = (msg)=>{ const el=document.getElementById('toast'); el.textContent=msg; el.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>el.style.display='none',1400); };

  /********* Tournament data *********/
  let rounds, flat, sel=null, tickHandle=null, chosen=null, showFinished=false;

  function makeTournament(){
    const entries = Array.from({length:32}, (_,i)=>({name:`Seed ${i+1}`, img:`https://picsum.photos/seed/e${i+1}/800/1000`}));
    rounds = {1:[],2:[],3:[],4:[],5:[]};
    for (let i=0;i<16;i++){
      rounds[1].push({
        id:`R32_${i+1}`, round:1, index:i+1,
        A:{name:entries[2*i].name, img:entries[2*i].img},
        B:{name:entries[2*i+1].name, img:entries[2*i+1].img},
        votesA:0, votesB:0, ends:null, decided:false,
      });
    }
    for (let r=2, size=8; r<=5; r++, size=Math.max(1, size/2)){
      for (let i=0;i<size;i++){
        rounds[r].push({ id: `${roundLabel[r]}_${i+1}`, round:r, index:i+1,
          A:{}, B:{}, votesA:0, votesB:0, ends:null, decided:false
        });
      }
    }
    flat = [...rounds[1], ...rounds[2], ...rounds[3], ...rounds[4], ...rounds[5]];
  }

  /********* DOM refs *********/
  const listEl=document.getElementById('matchList');
  const detailRound=document.getElementById('detailRound');
  const detailIndex=document.getElementById('detailIndex');
  const detailState=document.getElementById('detailState');
  const detailClock=document.getElementById('detailClock');
  const leftArt=document.getElementById('leftArt'), rightArt=document.getElementById('rightArt');
  const leftTbd=document.getElementById('leftTbd'), rightTbd=document.getElementById('rightTbd');
  const leftName=document.getElementById('leftName'), rightName=document.getElementById('rightName');
  const leftVotes=document.getElementById('leftVotes'), rightVotes=document.getElementById('rightVotes');
  const btnLeft=document.getElementById('btnLeft'), btnRight=document.getElementById('btnRight');
  const btnSubmit=document.getElementById('btnSubmit');
  const voteLockBadge=document.getElementById('voteLock');
  const btnReset=document.getElementById('btnReset'), btnForce=document.getElementById('btnForce'), btnClearVotes=document.getElementById('btnClearVotes');
  const roundSummary=document.getElementById('roundSummary');
  const toggleFinished=document.getElementById('toggleFinished');

  // Overlay refs
  const overlay = document.getElementById('championOverlay');
  const championArt = document.getElementById('championArt');
  const championName = document.getElementById('championName');
  const championTitle = document.getElementById('championTitle');
  const fxLayer = document.getElementById('fxLayer');

  // Fullscreen buttons
  const fsLeft = document.getElementById('fsLeft');
  const fsRight = document.getElementById('fsRight');

  /********* Supabase sync (timers + votes) *********/
  async function loadServerState() {
    const { data, error } = await supabase
      .from(MATCH_TABLE)
      .select('slug, ends, decided, votesA, votesB');
    if (error) { console.warn('loadServerState error', error); return; }
    console.log('[state] rows', data?.length, data?.slice?.(0,3));
    const map = new Map(data.map(r => [r.slug, r]));
    for (const m of flat) {
      const row = map.get(m.id);   // our local id is the slug (e.g., "R32_4")
      if (!row) continue;
      m.decided = !!row.decided;
      m.ends    = row.ends ? new Date(row.ends).getTime() : null;
      m.votesA  = row.votesA ?? 0;
      m.votesB  = row.votesB ?? 0;
    }
  }

  // ensure rows exist by slug (does NOT overwrite server values)
  async function ensureRowsExist() {
    const rows = flat.map(m => ({ slug: m.id, round: m.round, idx: m.index }));
    const { error } = await supabase
      .from(MATCH_TABLE)
      .insert(rows, { onConflict: 'slug', ignoreDuplicates: true });
    if (error) console.warn('ensureRowsExist error', error);
  }

  // start a timer ONLY if none exists (server-authoritative)
  async function startFreshTimerIfReady(node){
    if(node.A?.img && node.B?.img && !node.ends && !node.decided){
      const proposedEnds = nowMs() + ROUND_MS;
      const { data, error } = await supabase
        .rpc('start_timer_by_slug', { p_slug: node.id, p_ends: toIso(proposedEnds) });
      console.log('[timer] RPC result', node.id, {data, error});
      if (error) { console.warn('start_timer_by_slug error', error); return; }
      const row = Array.isArray(data) ? data[0] : data;
      if (row?.ends) {
        node.ends = new Date(row.ends).getTime();
        repaintRow(node.id);
        if(sel===node.id) select(node.id);
      }
    }
  }

  // decide match (update by slug)
  async function setDecidedOnServer(matchSlug, decided) {
    const { error } = await supabase
      .from(MATCH_TABLE)
      .update({ decided: !!decided, ends: null })
      .eq('slug', matchSlug);
    if (error) console.warn('setDecidedOnServer error', error);
  }

  // atomic vote via RPC (by slug)
  async function castVoteOnServer(matchSlug, side){
    const { data, error } = await supabase
      .rpc('cast_vote_by_slug', { p_slug: matchSlug, p_side: side });
    if (error) { console.warn('cast_vote_by_slug error', error); throw error; }
    return Array.isArray(data) ? data[0] : data;
  }

  function subscribeRealtime() {
    supabase.channel('matches-realtime')
      .on('postgres_changes', { event: '*', schema: 'public', table: MATCH_TABLE }, payload => {
        const row = payload.new || payload.old;
        if (!row) return;
        const key = row.slug || row.id; // prefer slug
        const m = flat.find(x => x.id === key);
        if (!m || !payload.new) return;
        m.decided = !!payload.new.decided;
        m.ends = payload.new.ends ? new Date(payload.new.ends).getTime() : null;
        m.votesA = payload.new.votesA ?? 0;
        m.votesB = payload.new.votesB ?? 0;
        repaintRow(m.id);
        if (sel === m.id) select(m.id);
      })
      .subscribe();
  }

  /********* Round helpers *********/
  function isRoundComplete(r){ return rounds[r].length>0 && rounds[r].every(m=>m.decided); }
  function currentRound(){ for(let r=1;r<=5;r++){ if(rounds[r].some(m=>!m.decided)) return r; } return 5; }
  function visibleMatches(){ const cur=currentRound(); return flat.filter(m => showFinished ? true : (m.round >= cur)); }
  function updateRoundBreadcrumb(){ const cur=currentRound(); roundSummary.textContent = `${roundLabel[cur]} ‚Üí Final`; }

  /********* Build list *********/
  function buildList(preserveId){
    listEl.innerHTML='';
    const items = visibleMatches();
    for (const m of items){
      const item=document.createElement('div'); item.className='matchItem'; item.dataset.id=m.id;
      const mini=document.createElement('div'); mini.className='thumbMini';
      const iA=document.createElement('img'); iA.src=m.A?.img||BLANK;
      const iB=document.createElement('img'); iB.src=m.B?.img||BLANK;
      mini.append(iA,iB);
      const mid=document.createElement('div');
      const title=document.createElement('div'); title.className='title';
      title.textContent=`${m.A?.name||'TBD'} vs ${m.B?.name||'TBD'}`;
      const row=document.createElement('div'); row.className='metaRow';
      const badge=document.createElement('span'); badge.className='badge'; badge.textContent=roundLabel[m.round];
      const timer=document.createElement('span'); timer.className='timer';
      if(m.ends){timer.dataset.ends=m.ends; timer.textContent=fmt(m.ends-nowMs());}
      row.append(badge,timer); mid.append(title,row);
      const score=document.createElement('div'); score.textContent=`${m.votesA||0} - ${m.votesB||0}`;
      item.append(mini,mid,score);
      item.addEventListener('click',()=>select(m.id));
      listEl.appendChild(item);
    }
    updateRoundBreadcrumb();
    let targetId = preserveId && items.some(x=>x.id===preserveId) ? preserveId : (items.find(x=>x.A.img&&x.B.img)||items[0])?.id;
    if(targetId) select(targetId);
  }

  function repaintRow(id){
    if(!visibleMatches().some(x=>x.id===id)){ buildList(); return; }
    const m=flat.find(x=>x.id===id); if(!m) return;
    const row=[...listEl.children].find(c=>c.dataset.id===id); if(!row) return;
    const imgs=row.querySelectorAll('.thumbMini img');
    if(imgs[0]) imgs[0].src=m.A?.img||BLANK;
    if(imgs[1]) imgs[1].src=m.B?.img||BLANK;
    const title=row.querySelector('.title'); if(title) title.textContent=`${m.A?.name||'TBD'} vs ${m.B?.name||'TBD'}`;
    const timer=row.querySelector('.timer');
    if(m.ends){timer.dataset.ends=m.ends; timer.textContent=fmt(m.ends-nowMs());}
    else{timer.removeAttribute('data-ends'); timer.textContent='';}
    const score=row.children[row.children.length-1]; score.textContent=`${m.votesA||0} - ${m.votesB||0}`;
  }

  function scrollToRow(id){
    const row=[...listEl.children].find(c=>c.dataset.id===id);
    if(!row) return;
    listEl.scrollTo({top: row.offsetTop - 12, behavior:'smooth'});
  }

  /********* Selection *********/
  function select(id){
    sel=id; chosen=null;
    [...listEl.children].forEach(li=>li.classList.toggle('selected',li.dataset.id===id));
    const m=flat.find(x=>x.id===id); if(!m) return;

    detailRound.textContent=roundLabel[m.round];
    detailIndex.textContent=`Match ${m.index}/${rounds[m.round].length}`;

    const canVote=!!(m.A.img&&m.B.img);
    detailState.textContent=m.decided?'DECIDED':(m.ends?'OPEN':(canVote?'READY':'TBD'));

    leftArt.src=m.A.img||BLANK; rightArt.src=m.B.img||BLANK;
    leftTbd.style.display=m.A.img?'none':'flex';
    rightTbd.style.display=m.B.img?'none':'flex';
    leftName.textContent=m.A.name||'TBD'; rightName.textContent=m.B.name||'TBD';
    leftVotes.textContent=m.votesA||0; rightVotes.textContent=m.votesB||0;

    const already=!!localStorage.getItem(lockKey(m.id));
    btnLeft.disabled=btnRight.disabled=!m.ends||already||m.decided;
    btnSubmit.disabled=true;
    voteLockBadge.style.display=already?'inline-block':'none';
    btnLeft.classList.remove('active'); btnRight.classList.remove('active');

    if(m.ends){detailClock.dataset.ends=m.ends;} else {detailClock.removeAttribute('data-ends');}
    updateClock();

    if(tickHandle) clearInterval(tickHandle);
    tickHandle=setInterval(updateClock,1000);
  }
  function updateClock(){const m=flat.find(x=>x.id===sel); if(!m) return;
    const ms=(m.ends||0)-nowMs(); detailClock.textContent=fmt(ms>0?ms:0);}

  /********* Winner + advancement *********/
  const nextId=(id)=>{const [r,i]=id.split('_');const idx=parseInt(i||'1',10);
    if(r==='R32')return`R16_${Math.ceil(idx/2)}`;
    if(r==='R16')return`QF_${Math.ceil(idx/2)}`;
    if(r==='QF')return`SF_${Math.ceil(idx/2)}`;
    if(r==='SF')return`FINAL_1`; return null;};

  function pickWinnerObj(m){ const a=m.votesA||0, b=m.votesB||0; if(a>b) return m.A; if(b>a) return m.B; return (Math.random()<0.5)?m.A:m.B; }

  function finalizeMatch(m){
    if(m.decided) return false;
    m.decided=true; m.ends=null;
    setDecidedOnServer(m.id, true); // update by slug
    const winner=pickWinnerObj(m);
    const nid=nextId(m.id);
    if(!nid){
      showChampion(winner); repaintRow(m.id); if(sel===m.id) select(m.id); return true;
    }
    const nr=flat.find(x=>x.id===nid); if(!nr) return true;
    if(!nr.A.img) nr.A={...winner}; else if(!nr.B.img) nr.B={...winner};
    repaintRow(m.id); repaintRow(nr.id);
    startFreshTimerIfReady(nr);
    if(isRoundComplete(m.round)){ buildList(nr.id); } else { select(nr.id); scrollToRow(nr.id); }
    return true;
  }

  function showChampion(winner){
    const overlay = document.getElementById('championOverlay');
    const championArt = document.getElementById('championArt');
    const championName = document.getElementById('championName');
    const championTitle = document.getElementById('championTitle');
    const fxLayer = document.getElementById('fxLayer');
    championArt.src = winner.img || BLANK;
    championName.textContent = winner.name || 'Champion';
    championTitle.setAttribute('data-text','CHAMPION');
    championTitle.textContent = 'CHAMPION';
    fxLayer.innerHTML='';
    overlay.classList.add('show');
  }
  document.getElementById('btnCloseChampion').addEventListener('click', ()=> document.getElementById('championOverlay').classList.remove('show'));

  function globalTick(){
    let anyChanged=false;
    for(const m of flat){
      if(m.ends && !m.decided){
        const left=m.ends-nowMs();
        const row=[...listEl.children].find(c=>c.dataset.id===m.id);
        const t=row?.querySelector('.timer');
        if(t){ t.textContent=fmt(left>0?left:0); t.dataset.ends=m.ends; }
        if(left<=0){ anyChanged = finalizeMatch(m) || anyChanged; }
      }
    }
    if(sel){
      const m=flat.find(x=>x.id===sel);
      if(m){
        leftVotes.textContent=m.votesA||0; rightVotes.textContent=m.votesB||0;
        const canVote=!!(m.A.img&&m.B.img);
        detailState.textContent=m.decided?'DECIDED':(m.ends?'OPEN':(canVote?'READY':'TBD'));
        updateClock();
      }
    }
    if(anyChanged){ buildList(sel); }
  }

  /********* Voting *********/
  function setChoice(side){
    if (btnLeft.disabled || btnRight.disabled) return;
    chosen = side; // 'A' or 'B'
    btnLeft.classList.toggle('active', side==='A');
    btnRight.classList.toggle('active', side==='B');
    btnSubmit.disabled = false;
  }
  btnLeft.addEventListener('click', () => setChoice('A'));
  btnRight.addEventListener('click', () => setChoice('B'));

  btnSubmit.addEventListener('click', async () => {
    const m = flat.find(x => x.id === sel);
    if (!m) return;
    if (!m.ends || m.decided){ toast('Voting closed for this match'); return; }

    const key = lockKey(m.id);
    if (localStorage.getItem(key)){ toast('You already voted here'); return; }
    if (!chosen){ toast('Pick a side first'); return; }

    try{
      const row = await castVoteOnServer(m.id, chosen); // RPC by slug
      m.votesA = row.votesa ?? row.votesA ?? m.votesA;
      m.votesB = row.votesb ?? row.votesB ?? m.votesB;

      localStorage.setItem(key, chosen);
      voteLockBadge.style.display = 'inline-block';
      btnLeft.disabled = btnRight.disabled = true;
      btnSubmit.disabled = true;

      leftVotes.textContent = m.votesA || 0;
      rightVotes.textContent = m.votesB || 0;
      repaintRow(m.id);
      toast('Vote submitted');
    }catch(e){
      toast('Could not submit vote');
    }
  });

  /********* Fullscreen *********/
  async function requestFS(el){
    try{
      if (el.requestFullscreen) await el.requestFullscreen({ navigationUI:'hide' });
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) el.msRequestFullscreen();
      else throw new Error('Fullscreen API unavailable');
    }catch(e){
      const src = (el.tagName==='IMG' ? el.src : el.querySelector('img')?.src);
      if(src) window.open(src, '_blank');
    }
  }
  function wireFS(imgEl, btnEl){
    btnEl.addEventListener('click', ()=> requestFS(imgEl));
    let last=0; imgEl.addEventListener('click', ()=>{ const now=Date.now(); if(now-last<300) requestFS(imgEl); last=now; });
  }
  wireFS(leftArt,  fsLeft); wireFS(rightArt, fsRight);

  /********* Controls *********/
  document.getElementById('btnReset').addEventListener('click', async ()=>{
    clearVoteLocks();
    if (tickHandle) { clearInterval(tickHandle); tickHandle=null; }
    document.getElementById('championOverlay').classList.remove('show');
    makeTournament();
    await initAfterTournamentBuild(); // server timers persist; fresh ones only start if missing
    toast('Reset complete');
  });

  document.getElementById('btnForce').addEventListener('click', ()=>{
    const m=flat.find(x=>x.id===sel);
    if (!m) return;
    if (m.decided) { toast('Match already decided'); return; }
    m.ends = nowMs();
    finalizeMatch(m);
  });

  document.getElementById('btnClearVotes').addEventListener('click', ()=>{
    clearVoteLocks();
    voteLockBadge.style.display='none';
    if(sel){
      const m=flat.find(x=>x.id===sel);
      if(m && m.ends && !m.decided){
        btnLeft.disabled = btnRight.disabled = false;
      }
    }
    toast('Your local votes were cleared');
  });

  toggleFinished.addEventListener('change', (e)=>{
    showFinished = e.target.checked;
    buildList(sel);
  });

  /********* Init *********/
  async function initAfterTournamentBuild(){
    await ensureRowsExist();      // make sure slug rows exist first
    await loadServerState();      // hydrate ends/decided + votes
    for (const m of flat) await startFreshTimerIfReady(m); // starts only if server accepts
    buildList();
    if (!tickHandle) tickHandle = setInterval(globalTick, 250);
  }

  async function init(){
    clearVoteLocks();
    makeTournament();
    subscribeRealtime();
    await initAfterTournamentBuild();
  }
  init();
</script>
</body>
</html>