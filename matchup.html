// global-timer-v2 â€” 16-up version: R16 @90s, quarters @60s, semis @30s, final @0s
// drop-in replacement for your current file

import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type Row = {
  id: string;
  base_iso: string;
  ends_at: string;
  period_sec: number;

  // live lanes (reused each phase)
  seed_a_url: string | null; seed_b_url: string | null;
  seed_c_url: string | null; seed_d_url: string | null;
  seed_e_url: string | null; seed_f_url: string | null;
  seed_g_url: string | null; seed_h_url: string | null;

  // extra R16 lanes
  seed_i_url: string | null; seed_j_url: string | null;
  seed_k_url: string | null; seed_l_url: string | null;
  seed_m_url: string | null; seed_n_url: string | null;
  seed_o_url: string | null; seed_p_url: string | null;

  seed_a_count: number; seed_b_count: number;
  seed_c_count: number; seed_d_count: number;
  seed_e_count: number; seed_f_count: number;
  seed_g_count: number; seed_h_count: number;

  seed_i_count: number; seed_j_count: number;
  seed_k_count: number; seed_l_count: number;
  seed_m_count: number; seed_n_count: number;
  seed_o_count: number; seed_p_count: number;

  // phase flags
  r16_done: boolean | null;  // after R16 (T-90)
  mid1_done: boolean | null; // after quarters (T-60)
  mid2_done: boolean | null; // after semis   (T-30)

  // quarter snapshots (unchanged shape)
  q1_a_url?: string | null; q1_b_url?: string | null;
  q1_a_count?: number | null; q1_b_count?: number | null;
  q2_c_url?: string | null; q2_d_url?: string | null;
  q2_c_count?: number | null; q2_d_count?: number | null;
  q3_e_url?: string | null; q3_f_url?: string | null;
  q3_e_count?: number | null; q3_f_count?: number | null;
  q4_g_url?: string | null; q4_h_url?: string | null;
  q4_g_count?: number | null; q4_h_count?: number | null;

  // semi snapshots
  semi_1_left_url?: string | null;  semi_1_right_url?: string | null;
  semi_1_left_count?: number | null; semi_1_right_count?: number | null;
  semi_2_left_url?: string | null;  semi_2_right_url?: string | null;
  semi_2_left_count?: number | null; semi_2_right_count?: number | null;

  // final snapshot (UI-compatible)
  mid_winner_1_url?: string | null;
  mid_winner_2_url?: string | null;
};

const cors: Record<string,string> = {
  "Access-Control-Allow-Origin":"*",
  "Access-Control-Allow-Headers":"authorization, x-client-info, apikey, content-type, x-rsid, x-admin-key",
  "Access-Control-Allow-Methods":"GET, POST, DELETE, OPTIONS",
  "Content-Type":"application/json",
};

const DEFAULT_PERIOD_SEC = 120; // ðŸ”” 120s total
const GRACE_MS = 800;
const ADMIN_CLEAR_KEY = "Inklink88!";

function supaAdmin(){
  const url = Deno.env.get("SUPABASE_URL")!;
  const srk = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
  return createClient(url, srk, { auth: { persistSession:false } });
}

const picsum = (seed:string)=>`https://picsum.photos/seed/${encodeURIComponent(seed)}/900/1200`;
const safeIso = (d:Date|string)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,"Z");

function rngBit(){ try{const a=new Uint32Array(1); crypto.getRandomValues(a); return (a[0]&1)===0;}catch{return Math.random()<.5;} }
function decidePair(u1:string|null,u2:string|null,c1:number,c2:number){ 
  if (c1===c2) return {winner_url: rngBit()?u1:u2, decided_by:"random_tie" as const};
  return {winner_url: c1>c2?u1:u2, decided_by:"votes" as const};
}

function remainingMs(tiso:string){ return new Date(tiso).getTime()-Date.now(); }

async function claimN(db: ReturnType<typeof supaAdmin>, n:number, base_iso:string){
  const picked:any[]=[]; 
  for (let i=0;i<Math.ceil(n/2);i++){
    const {data,error}=await db.rpc("claim_two_queue_items",{base_iso});
    if (error) break;
    if (Array.isArray(data)){
      for (const row of data){
        if (row?.image_url){ picked.push(row); if (picked.length>=n) break; }
      }
    }
    if (picked.length>=n) break;
  }
  return picked.slice(0,n);
}

async function getSingleton(db=supaAdmin()): Promise<Row>{
  const {data, error} = await db.from("cycles_v2").select("*").limit(1).maybeSingle();
  if (error) throw error;

  if (!data){
    const base_iso = safeIso(new Date());
    const ends_at  = new Date(Date.now()+DEFAULT_PERIOD_SEC*1000).toISOString();
    const seeds16  = "abcdefghijklmnop".split("").map(s=>picsum(s));
    const insert:any = {
      base_iso, ends_at, period_sec: DEFAULT_PERIOD_SEC,
      // A..H
      seed_a_url:seeds16[0], seed_b_url:seeds16[1], seed_c_url:seeds16[2], seed_d_url:seeds16[3],
      seed_e_url:seeds16[4], seed_f_url:seeds16[5], seed_g_url:seeds16[6], seed_h_url:seeds16[7],
      // I..P
      seed_i_url:seeds16[8], seed_j_url:seeds16[9], seed_k_url:seeds16[10], seed_l_url:seeds16[11],
      seed_m_url:seeds16[12],seed_n_url:seeds16[13],seed_o_url:seeds16[14], seed_p_url:seeds16[15],

      seed_a_count:0, seed_b_count:0, seed_c_count:0, seed_d_count:0,
      seed_e_count:0, seed_f_count:0, seed_g_count:0, seed_h_count:0,
      seed_i_count:0, seed_j_count:0, seed_k_count:0, seed_l_count:0,
      seed_m_count:0, seed_n_count:0, seed_o_count:0, seed_p_count:0,

      r16_done:false, mid1_done:false, mid2_done:false
    };
    const {data:ins, error:e2}=await db.from("cycles_v2").insert(insert).select("*").single();
    if (e2) throw e2;
    return ins as any;
  }

  return {
    ...data,
    period_sec: data.period_sec ?? DEFAULT_PERIOD_SEC,
    // backfill new fields if null
    r16_done: data.r16_done ?? false,
    seed_i_url: data.seed_i_url ?? picsum("i"),
    seed_j_url: data.seed_j_url ?? picsum("j"),
    seed_k_url: data.seed_k_url ?? picsum("k"),
    seed_l_url: data.seed_l_url ?? picsum("l"),
    seed_m_url: data.seed_m_url ?? picsum("m"),
    seed_n_url: data.seed_n_url ?? picsum("n"),
    seed_o_url: data.seed_o_url ?? picsum("o"),
    seed_p_url: data.seed_p_url ?? picsum("p"),
    seed_i_count: data.seed_i_count ?? 0,
    seed_j_count: data.seed_j_count ?? 0,
    seed_k_count: data.seed_k_count ?? 0,
    seed_l_count: data.seed_l_count ?? 0,
    seed_m_count: data.seed_m_count ?? 0,
    seed_n_count: data.seed_n_count ?? 0,
    seed_o_count: data.seed_o_count ?? 0,
    seed_p_count: data.seed_p_count ?? 0,
    mid1_done: data.mid1_done ?? false,
    mid2_done: data.mid2_done ?? false,
  } as any;
}

// ---------- PHASE A (T-90): decide R16 -> fill A..H lanes ----------
async function runR16(row:Row, db=supaAdmin()){
  if (row.r16_done) return row;

  const p = (u1:any,u2:any,c1:any,c2:any)=>decidePair(u1,u2,c1,c2).winner_url;
  const wA = p(row.seed_a_url,row.seed_b_url,row.seed_a_count,row.seed_b_count);
  const wB = p(row.seed_c_url,row.seed_d_url,row.seed_c_count,row.seed_d_count);
  const wC = p(row.seed_e_url,row.seed_f_url,row.seed_e_count,row.seed_f_count);
  const wD = p(row.seed_g_url,row.seed_h_url,row.seed_g_count,row.seed_h_count);
  const wE = p(row.seed_i_url,row.seed_j_url,row.seed_i_count,row.seed_j_count);
  const wF = p(row.seed_k_url,row.seed_l_url,row.seed_k_count,row.seed_l_count);
  const wG = p(row.seed_m_url,row.seed_n_url,row.seed_m_count,row.seed_n_count);
  const wH = p(row.seed_o_url,row.seed_p_url,row.seed_o_count,row.seed_p_count);

  const { data:upd } = await db.from("cycles_v2").update({
    // promote 8 winners into A..H lanes for quarters
    seed_a_url:wA, seed_b_url:wB, seed_c_url:wC, seed_d_url:wD,
    seed_e_url:wE, seed_f_url:wF, seed_g_url:wG, seed_h_url:wH,

    // clear counts; clear I..P
    seed_a_count:0, seed_b_count:0, seed_c_count:0, seed_d_count:0,
    seed_e_count:0, seed_f_count:0, seed_g_count:0, seed_h_count:0,
    seed_i_url:null, seed_j_url:null, seed_k_url:null, seed_l_url:null,
    seed_m_url:null, seed_n_url:null, seed_o_url:null, seed_p_url:null,
    seed_i_count:0, seed_j_count:0, seed_k_count:0, seed_l_count:0,
    seed_m_count:0, seed_n_count:0, seed_o_count:0, seed_p_count:0,

    r16_done:true
  }).eq("id", row.id).select("*").maybeSingle();

  return (upd as any) ?? row;
}

// ---------- PHASE B (T-60): quarters -> semis (same as before) ----------
async function runQuarters(row:Row, db=supaAdmin()){
  if (row.mid1_done) return row;

  const q1 = decidePair(row.seed_a_url,row.seed_b_url,row.seed_a_count,row.seed_b_count);
  const q2 = decidePair(row.seed_c_url,row.seed_d_url,row.seed_c_count,row.seed_d_count);
  const q3 = decidePair(row.seed_e_url,row.seed_f_url,row.seed_e_count,row.seed_f_count);
  const q4 = decidePair(row.seed_g_url,row.seed_h_url,row.seed_g_count,row.seed_h_count);
  const decided_at = new Date().toISOString();

  await db.from("winners_v2").insert([
    { base_iso: row.base_iso + "::q1", winner_seed: (q1.winner_url===row.seed_a_url?"a":"b"),
      winner_url: q1.winner_url, seed_a_count: row.seed_a_count, seed_b_count: row.seed_b_count,
      decided_by: q1.decided_by, decided_at },
    { base_iso: row.base_iso + "::q2", winner_seed: (q2.winner_url===row.seed_c_url?"c":"d"),
      winner_url: q2.winner_url, seed_a_count: row.seed_c_count, seed_b_count: row.seed_d_count,
      decided_by: q2.decided_by, decided_at },
    { base_iso: row.base_iso + "::q3", winner_seed: (q3.winner_url===row.seed_e_url?"e":"f"),
      winner_url: q3.winner_url, seed_a_count: row.seed_e_count, seed_b_count: row.seed_f_count,
      decided_by: q3.decided_by, decided_at },
    { base_iso: row.base_iso + "::q4", winner_seed: (q4.winner_url===row.seed_g_url?"g":"h"),
      winner_url: q4.winner_url, seed_a_count: row.seed_g_count, seed_b_count: row.seed_h_count,
      decided_by: q4.decided_by, decided_at },
  ]);

  const { data: upd } = await db.from("cycles_v2").update({
    // snapshot quarters
    q1_a_url: row.seed_a_url, q1_b_url: row.seed_b_url,
    q1_a_count: row.seed_a_count, q1_b_count: row.seed_b_count,
    q2_c_url: row.seed_c_url, q2_d_url: row.seed_d_url,
    q2_c_count: row.seed_c_count, q2_d_count: row.seed_d_count,
    q3_e_url: row.seed_e_url, q3_f_url: row.seed_f_url,
    q3_e_count: row.seed_e_count, q3_f_count: row.seed_f_count,
    q4_g_url: row.seed_g_url, q4_h_url: row.seed_h_url,
    q4_g_count: row.seed_g_count, q4_h_count: row.seed_h_count,

    // promote to semis lanes
    semi_1_left_url:  q1.winner_url,
    semi_1_right_url: q2.winner_url,
    semi_2_left_url:  q3.winner_url,
    semi_2_right_url: q4.winner_url,

    // live lanes become semi finalists
    seed_a_url: q1.winner_url, seed_b_url: q2.winner_url,
    seed_c_url: q3.winner_url, seed_d_url: q4.winner_url,
    seed_e_url: null, seed_f_url: null, seed_g_url: null, seed_h_url: null,

    seed_a_count:0, seed_b_count:0, seed_c_count:0, seed_d_count:0,
    seed_e_count:0, seed_f_count:0, seed_g_count:0, seed_h_count:0,

    mid1_done:true
  }).eq("id", row.id).select("*").maybeSingle();

  return (upd as any) ?? row;
}

// ---------- PHASE C (T-30): semis -> final (same) ----------
async function runSemis(row:Row, db=supaAdmin()){
  if (row.mid2_done) return row;

  const s1 = decidePair(row.semi_1_left_url ?? row.seed_a_url, row.semi_1_right_url ?? row.seed_b_url,
                        row.seed_a_count, row.seed_b_count);
  const s2 = decidePair(row.semi_2_left_url ?? row.seed_c_url, row.semi_2_right_url ?? row.seed_d_url,
                        row.seed_c_count, row.seed_d_count);
  const decided_at = new Date().toISOString();

  await db.from("winners_v2").insert([
    { base_iso: row.base_iso + "::semi1", winner_seed: "?", winner_url: s1.winner_url,
      seed_a_count: row.seed_a_count, seed_b_count: row.seed_b_count, decided_by: s1.decided_by, decided_at },
    { base_iso: row.base_iso + "::semi2", winner_seed: "?", winner_url: s2.winner_url,
      seed_a_count: row.seed_c_count, seed_b_count: row.seed_d_count, decided_by: s2.decided_by, decided_at },
  ]);

  const { data: upd } = await db.from("cycles_v2").update({
    semi_1_left_count: row.seed_a_count,
    semi_1_right_count: row.seed_b_count,
    semi_2_left_count: row.seed_c_count,
    semi_2_right_count: row.seed_d_count,

    mid_winner_1_url: s1.winner_url,
    mid_winner_2_url: s2.winner_url,

    seed_a_url: s1.winner_url, seed_b_url: s2.winner_url,
    seed_c_url: null, seed_d_url: null,
    seed_a_count:0, seed_b_count:0, seed_c_count:0, seed_d_count:0,

    mid2_done:true
  }).eq("id", row.id).select("*").maybeSingle();

  return (upd as any) ?? row;
}

// ---------- FINAL (T-0): decide + advance ----------
async function decideAndAdvance(row:Row, db=supaAdmin()){
  const final = decidePair(row.seed_a_url,row.seed_b_url,row.seed_a_count,row.seed_b_count);

  // Idempotent final write
  const { data: exists } = await db.from("winners_v2").select("id").eq("base_iso", row.base_iso).maybeSingle();
  if (!exists){
    await db.from("winners_v2").insert({
      base_iso: row.base_iso,
      winner_seed: final.winner_url===row.seed_a_url? "a" : "b",
      winner_url: final.winner_url,
      seed_a_count: row.seed_a_count, seed_b_count: row.seed_b_count,
      decided_by: final.decided_by, decided_at: row.ends_at
    });
  }

  // next window
  const periodMs = (row.period_sec || DEFAULT_PERIOD_SEC) * 1000;
  const ends = Date.now() + periodMs;
  const base_iso = safeIso(new Date(ends - periodMs));
  const ends_at = new Date(ends).toISOString();

  // reset + clear snapshots
  const { data: updCycle } = await db.from("cycles_v2").update({
    base_iso, ends_at, period_sec: row.period_sec || DEFAULT_PERIOD_SEC,
    // zero counts
    seed_a_count:0, seed_b_count:0, seed_c_count:0, seed_d_count:0,
    seed_e_count:0, seed_f_count:0, seed_g_count:0, seed_h_count:0,
    seed_i_count:0, seed_j_count:0, seed_k_count:0, seed_l_count:0,
    seed_m_count:0, seed_n_count:0, seed_o_count:0, seed_p_count:0,
    // flags
    r16_done:false, mid1_done:false, mid2_done:false,
    // snapshots
    mid_winner_1_url:null, mid_winner_2_url:null,
    q1_a_url:null,q1_b_url:null,q1_a_count:null,q1_b_count:null,
    q2_c_url:null,q2_d_url:null,q2_c_count:null,q2_d_count:null,
    q3_e_url:null,q3_f_url:null,q3_e_count:null,q3_f_count:null,
    q4_g_url:null,q4_h_url:null,q4_g_count:null,q4_h_count:null,
    semi_1_left_url:null, semi_1_right_url:null,
    semi_1_left_count:null, semi_1_right_count:null,
    semi_2_left_url:null, semi_2_right_url:null,
    semi_2_left_count:null, semi_2_right_count:null,
  }).eq("id", row.id).select("*").single();

  // seed next 16
  let next = "abcdefghijklmnop".split("").map(s=>picsum(s));
  try {
    const claimed = await claimN(db, 16, base_iso);
    for (let i=0;i<16;i++) if (claimed[i]?.image_url) next[i]=claimed[i].image_url;
  } catch {}

  await db.from("cycles_v2").update({
    seed_a_url:next[0],seed_b_url:next[1],seed_c_url:next[2],seed_d_url:next[3],
    seed_e_url:next[4],seed_f_url:next[5],seed_g_url:next[6],seed_h_url:next[7],
    seed_i_url:next[8],seed_j_url:next[9],seed_k_url:next[10],seed_l_url:next[11],
    seed_m_url:next[12],seed_n_url:next[13],seed_o_url:next[14],seed_p_url:next[15],
  }).eq("id",(updCycle as any).id);

  return updCycle as Row;
}

Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") return new Response("", { headers:cors });

  try{
    const db = supaAdmin();
    const url = new URL(req.url);
    const wantWinners = url.searchParams.get("winners");
    const wantClear   = url.searchParams.get("clear");
    const limit = Number(url.searchParams.get("limit") || "200");

    // admin: clear winners
    if (req.method==="DELETE" && wantClear){
      const k = req.headers.get("x-admin-key") || "";
      if (k !== ADMIN_CLEAR_KEY) return new Response(JSON.stringify({error:"forbidden"}), {headers:cors,status:403});
      const { error } = await db.from("winners_v2").delete().neq("id","00000000-0000-0000-0000-000000000000");
      if (error) return new Response(JSON.stringify({error:error.message}), {headers:cors,status:500});
      return new Response(JSON.stringify({ok:true}), {headers:cors,status:200});
    }

    // winners passthrough (unchanged response shape)
    if (req.method==="GET" && wantWinners){
      const { data:winners, error } = await db
        .from("winners_v2")
        .select("base_iso,winner_seed,winner_url,seed_a_count,seed_b_count,decided_by,decided_at")
        .order("decided_at",{ascending:false}).limit(isNaN(limit)?200:limit);
      if (error) return new Response(JSON.stringify({error:error.message}), {headers:cors,status:500});
      const mapped = (winners||[]).map(w=>{
        const s=(w.winner_seed||"").toLowerCase();
        const isLeft = s==="a"||s==="c"||s==="e"||s==="g";
        return { ...w, winner_color: isLeft ? "red":"blue", red_count:w.seed_a_count, blue_count:w.seed_b_count, image_url:w.winner_url };
      });
      return new Response(JSON.stringify({ winners:mapped, caught_up:0 }), {headers:cors,status:200});
    }

    // POST vote
    if (req.method==="POST"){
      const body = await req.json().catch(()=> ({}));
      const phase = String(body?.phase||"");
      const side  = String(body?.side ||""); // "left"|"right"
      const valid = ["r1","r2","r3","r4","r5","r6","r7","r8","q1","q2","q3","q4","s1","s2","final"];
      if (!valid.includes(phase) || !["left","right"].includes(side)){
        return new Response(JSON.stringify({error:"bad_request"}), {headers:cors,status:400});
      }

      let row = await getSingleton(db);
      const ms = remainingMs(row.ends_at);
      if (ms <= 0) return new Response(JSON.stringify({error:"cycle_over"}), {headers:cors,status:409});

      if (phase.startsWith("r") && row.r16_done)             return new Response(JSON.stringify({error:"r16_locked"}), {headers:cors,status:409});
      if (phase.startsWith("q") && (!row.r16_done || row.mid1_done)) return new Response(JSON.stringify({error:"quarters_locked"}), {headers:cors,status:409});
      if (phase.startsWith("s") && (!row.mid1_done || row.mid2_done)) return new Response(JSON.stringify({error:"semis_closed"}), {headers:cors,status:409});
      if (phase==="final" && !row.mid2_done)                 return new Response(JSON.stringify({error:"final_not_live"}), {headers:cors,status:409});

      const up: Record<string,number> = {};
      const inc = (k: keyof Row)=> (up[k as string] = ((row as any)[k]||0)+1);

      // map phases â†’ seed counters
      const leftRight = (l: keyof Row, r: keyof Row) => inc(side==="left" ? l : r);

      if (phase==="r1") leftRight("seed_a_count","seed_b_count");
      else if (phase==="r2") leftRight("seed_c_count","seed_d_count");
      else if (phase==="r3") leftRight("seed_e_count","seed_f_count");
      else if (phase==="r4") leftRight("seed_g_count","seed_h_count");
      else if (phase==="r5") leftRight("seed_i_count","seed_j_count");
      else if (phase==="r6") leftRight("seed_k_count","seed_l_count");
      else if (phase==="r7") leftRight("seed_m_count","seed_n_count");
      else if (phase==="r8") leftRight("seed_o_count","seed_p_count");
      else if (phase==="q1") leftRight("seed_a_count","seed_b_count");
      else if (phase==="q2") leftRight("seed_c_count","seed_d_count");
      else if (phase==="q3") leftRight("seed_e_count","seed_f_count");
      else if (phase==="q4") leftRight("seed_g_count","seed_h_count");
      else if (phase==="s1") leftRight("seed_a_count","seed_b_count");
      else if (phase==="s2") leftRight("seed_c_count","seed_d_count");
      else if (phase==="final") leftRight("seed_a_count","seed_b_count");

      const { data:upd, error:ue } = await db.from("cycles_v2").update(up).eq("id", row.id).select("*").maybeSingle();
      if (ue) return new Response(JSON.stringify({error:ue.message}), {headers:cors,status:500});
      return new Response(JSON.stringify(upd), {headers:cors,status:200});
    }

    // GET â€” scheduler
    let row = await getSingleton(db);

    // catch-up loop
    let guard=0;
    while (remainingMs(row.ends_at) <= -GRACE_MS && guard++ < 2000){
      row = await decideAndAdvance(row, db);
    }

    const ms = remainingMs(row.ends_at);
    const LOCK_R16_MS = 90_000;
    const LOCK_Q_MS   = 60_000;
    const LOCK_S_MS   = 30_000;

    if (ms <= LOCK_R16_MS && !row.r16_done){
      row = await runR16(row, db);
    }
    if (ms <= LOCK_Q_MS && row.r16_done && !row.mid1_done){
      row = await runQuarters(row, db);
    }
    if (ms <= LOCK_S_MS && row.mid1_done && !row.mid2_done){
      row = await runSemis(row, db);
    }
    if (ms <= 0 && row.mid2_done){
      row = await decideAndAdvance(row, db);
    }

    return new Response(JSON.stringify(row), {headers:cors,status:200});
  }catch(e:any){
    return new Response(JSON.stringify({error:String(e?.message||e)}), {headers:cors,status:500});
  }
});