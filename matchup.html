<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space — Matchup</title>

<link rel="stylesheet" href="style.css"/>

<style>
body { background:#0b0f13; color:#e5e7eb; font-family:system-ui,Segoe UI,Roboto; margin:0; }
.wrap { max-width:700px; margin:auto; padding:16px 12px 96px; }

.timer { font-size:32px; padding:8px 14px; border:1px solid #20242a; border-radius:12px; background:#0f1318; }

.card { margin-top:12px; border:1px solid #20242a; border-radius:16px; overflow:hidden; background:#0f1318; }
.imgBox { aspect-ratio:3/4; background:#111; }
.imgBox img { width:100%; height:100%; object-fit:cover; }

.bar { display:flex; justify-content:space-between; padding:10px 12px; align-items:center; }
.vote { padding:10px 14px; border-radius:12px; background:#131920; border:1px solid #39ff14; color:#39ff14; cursor:pointer; }
.vote:disabled { opacity:.4; cursor:default; }

.topbar { display:flex; justify-content:space-between; align-items:center; gap:8px; margin:10px 0; }
.pill { padding:8px 12px; border-radius:999px; border:1px solid #20242a; background:#0f1318; font-size:14px; }
.btn { padding:8px 12px; border-radius:12px; border:1px solid rgba(57,255,20,.5); background:#0f1318; color:#39ff14; cursor:pointer; }
.btn:disabled { opacity:.4; cursor:default; }

.thumbs { display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-top:18px; }

.thumb{
  position:relative;
  border-radius:14px;
  overflow:hidden;
  cursor:pointer;
  background:#0f1318;
  border:1px solid rgba(57,255,20,.35);
  box-shadow:0 0 8px rgba(57,255,20,.15), inset 0 0 0 1px rgba(57,255,20,.15);
  transition:box-shadow .2s ease, transform .15s ease;
}
.thumb:hover{
  transform:translateY(-1px);
  box-shadow:0 0 14px rgba(57,255,20,.45), 0 0 32px rgba(57,255,20,.25), inset 0 0 0 1px rgba(57,255,20,.4);
}
.thumb.active{
  box-shadow:0 0 18px rgba(57,255,20,.9), 0 0 48px rgba(57,255,20,.55), inset 0 0 0 2px rgba(57,255,20,.9);
}

.thumb-img{ position:relative; width:100%; aspect-ratio:3/4; background:#0b0f13; }
.thumb-img img{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
.thumb-img img.left{ clip-path:polygon(0% 0%, 100% 0%, 0% 100%); }
.thumb-img img.right{ clip-path:polygon(100% 0%, 100% 100%, 0% 100%); }

.small{ font-size:12px; opacity:.8; }
.warn{ color:#ffcc66; }
.ok{ color:#39ff14; }

/* ===== TIERED THUMBS ===== */
.tier { margin-top:18px; }
.tier-line{
  height:2px;
  background:rgba(57,255,20,.65);
  box-shadow:0 0 12px rgba(57,255,20,.35);
  border-radius:999px;
  margin:18px 0 10px;
}
.tier-title{
  display:flex;
  justify-content:space-between;
  align-items:baseline;
  gap:10px;
  margin:0 2px 10px;
}
.tier-title b{ color:#39ff14; letter-spacing:.06em; }
.tier-title span{ font-size:12px; opacity:.75; }

.thumb .badge{
  position:absolute;
  top:8px;
  left:8px;
  padding:4px 8px;
  font-size:11px;
  border-radius:999px;
  background:rgba(15,19,24,.85);
  border:1px solid rgba(57,255,20,.45);
  color:#39ff14;
  backdrop-filter: blur(6px);
}
.thumb.decided{ opacity:.72; }
.thumb .tbd{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  letter-spacing:.08em;
  color:rgba(229,231,235,.85);
  background:linear-gradient(135deg, rgba(15,19,24,.92), rgba(15,19,24,.65));
  text-shadow:0 0 10px rgba(0,0,0,.55);
}
.thumb .dim{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.15);
  pointer-events:none;
}

</style>
</head>

<body>
<div class="wrap">

<h1>ART BATTLE. Faction I.</h1>

<div class="timer">—</div>

<div class="topbar">
  <button class="btn" id="btnBack">← Menu</button>
  <div class="pill" id="roundLabel">Loading…</div>
  <div style="display:flex; gap:8px; align-items:center;">
    <div class="pill" id="userLabel">Not signed in</div>
    <button class="btn" id="btnSignIn">Sign in</button>
    <button class="btn" id="btnSignOut" disabled>Sign out</button>
  </div>
</div>

<div class="small" id="statusLine"></div>

<div class="card">
  <div class="imgBox"><img id="imgLeft" alt="Active top"></div>
  <div class="bar">
    <span>Top</span>
    <span id="countLeft">0</span>
    <button class="vote" id="voteLeft" disabled>Vote</button>
  </div>
</div>

<div class="card">
  <div class="imgBox"><img id="imgRight" alt="Active bottom"></div>
  <div class="bar">
    <span>Bottom</span>
    <span id="countRight">0</span>
    <button class="vote" id="voteRight" disabled>Vote</button>
  </div>
</div>

<div class="thumbs" id="thumbs"></div>

</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

/* =========================
   SUPABASE (YOUR PROJECT)
========================= */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY =
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Back to menu
const btnBack = document.getElementById("btnBack");
if (btnBack) btnBack.onclick = () => { window.location.href = "menu.html"; };

/* =========================
   DOM
========================= */
const imgLeft = document.getElementById("imgLeft");
const imgRight = document.getElementById("imgRight");
const countLeft = document.getElementById("countLeft");
const countRight = document.getElementById("countRight");
const voteLeft = document.getElementById("voteLeft");
const voteRight = document.getElementById("voteRight");
const thumbsEl = document.getElementById("thumbs");
const roundLabel = document.getElementById("roundLabel");
const userLabel = document.getElementById("userLabel");
const statusLine = document.getElementById("statusLine");
const btnSignIn = document.getElementById("btnSignIn");
const btnSignOut = document.getElementById("btnSignOut");

/* =========================
   STATE
========================= */
let sessionUser = null;
let activeRound = 0;

// All rounds, padded with placeholders so we can show TBD slots
let rounds = [[],[],[],[],[]];

// Current viewed match (can be any round)
let viewRound = 0;
let viewMatchIndex = 0;

// voted matches for ACTIVE round (so you can browse other rounds without mixing state)
let votedMatchIds = new Set();

// prevent jumping after vote
let keepCurrentMatch = false;

// Rounds: 0=r32, 1=r16, 2=QF, 3=SF, 4=Final
const ROUND_NAMES = ["R32","R16","Quarterfinals","Semifinals","Final"];
const ROUND_COUNTS = [16, 8, 4, 2, 1]; // how many matches per round

function setStatus(msg, cls=""){
  statusLine.className = "small " + cls;
  statusLine.textContent = msg;
}

function updateAuthUI(){
  if (sessionUser){
    userLabel.textContent = sessionUser.email ?? "Signed in";
    btnSignIn.disabled = true;
    btnSignOut.disabled = false;
  } else {
    userLabel.textContent = "Not signed in";
    btnSignIn.disabled = false;
    btnSignOut.disabled = true;
  }
}

function normalizeMatch(m, r, idx){
  // Normalize to a predictable shape. Placeholder when row doesn't exist.
  if (!m){
    return {
      id: null,
      round: r,
      match_index: idx,
      left_img: null,
      right_img: null,
      winner_img: null,
      winner_side: null,
      __placeholder: true
    };
  }
  return { __placeholder:false, ...m };
}

function matchHasOpponent(m){
  return !!(m?.left_img && m?.right_img);
}

/* =========================
   AUTH
========================= */
btnSignIn.onclick = async () => {
  const email = prompt("Email:");
  if (!email) return;
  const password = prompt("Password:");
  if (!password) return;

  setStatus("Signing in…");
  const { data, error } = await supabase.auth.signInWithPassword({ email, password });
  if (error){
    setStatus(error.message, "warn");
    return;
  }
  sessionUser = data.user;
  updateAuthUI();
  await refreshAll();
};

btnSignOut.onclick = async () => {
  await supabase.auth.signOut();
  sessionUser = null;
  updateAuthUI();
  await refreshAll();
};

/* =========================
   DATA
========================= */
async function detectActiveRound(){
  for (let r=0;r<5;r++){
    const { data } = await supabase
      .from("matches_v2")
      .select("*")
      .eq("round", r)
      .order("match_index");

    if (data?.some(m=>!m.winner_img)) return r;
  }
  return 4;
}

async function loadRoundRaw(r){
  const { data } = await supabase
    .from("matches_v2")
    .select("*")
    .eq("round", r)
    .order("match_index");
  return data ?? [];
}

async function loadAllRounds(){
  const out = [];
  for (let r=0;r<5;r++){
    const raw = await loadRoundRaw(r);
    const map = new Map((raw ?? []).map(m => [m.match_index, m]));
    const padded = [];
    const count = ROUND_COUNTS[r] ?? 0;
    for (let i=0;i<count;i++){
      padded.push(normalizeMatch(map.get(i), r, i));
    }
    out.push(padded);
  }
  return out;
}

/* counts show across accounts even with RLS */
async function loadCounts(matchId){
  const { data, error } = await supabase.rpc("get_match_counts_v2", { p_match_id: matchId });
  if (error) throw error;
  return {
    l: data?.[0]?.left_count ?? 0,
    r: data?.[0]?.right_count ?? 0
  };
}

/* voted matches for user in ACTIVE round only */
async function loadUserVotedMatchIds(userId, round){
  const set = new Set();
  if (!userId) return set;

  const { data, error } = await supabase
    .from("round_votes_v2")
    .select("match_id, round")
    .eq("user_id", userId)
    .eq("round", round);

  if (error) throw error;

  (data ?? []).forEach(row => set.add(row.match_id));
  return set;
}

/* =========================
   RENDER
========================= */
function getViewedMatch(){
  return rounds?.[viewRound]?.[viewMatchIndex] ?? null;
}

function render(){
  // Keep header label as the CURRENT active round (so you always know what round is live)
  roundLabel.textContent = (ROUND_NAMES[activeRound] ?? ("Round " + activeRound)) + " is LIVE";

  const m = getViewedMatch();
  if (!m){
    imgLeft.removeAttribute("src");
    imgRight.removeAttribute("src");
    countLeft.textContent = "0";
    countRight.textContent = "0";
    voteLeft.disabled = true;
    voteRight.disabled = true;
    return;
  }

  // Images / placeholders
  imgLeft.src = m.left_img || "";
  imgRight.src = m.right_img || "";

  const alreadyVotedThisMatch = m.id ? votedMatchIds.has(m.id) : false;

  const canVote =
    !!sessionUser &&
    viewRound === activeRound &&
    !!m.id &&
    !alreadyVotedThisMatch &&
    !m.winner_img &&
    matchHasOpponent(m);

  voteLeft.disabled = !canVote;
  voteRight.disabled = !canVote;

  renderThumbs();
}

function thumbHTML(m){
  const left = m.left_img
    ? `<img class="left" src="${m.left_img}">`
    : `<div class="tbd">TBD</div>`;

  const right = m.right_img
    ? `<img class="right" src="${m.right_img}">`
    : `<div class="tbd">TBD</div>`;

  const decided = m.winner_img ? `<div class="badge">DECIDED</div><div class="dim"></div>` : "";
  const tbdBadge = (!matchHasOpponent(m) && !m.winner_img) ? `<div class="badge">WAITING</div>` : "";

  return `
    ${decided || tbdBadge}
    <div class="thumb-img">
      ${left}
      ${right}
    </div>
  `;
}

function renderThumbs(){
  thumbsEl.innerHTML = "";

  for (let r=0;r<5;r++){
    // divider + title
    const line = document.createElement("div");
    line.className = "tier-line";
    thumbsEl.appendChild(line);

    const title = document.createElement("div");
    title.className = "tier-title";
    title.innerHTML = `<b>${ROUND_NAMES[r]}</b><span>${ROUND_COUNTS[r]} matches</span>`;
    thumbsEl.appendChild(title);

    const grid = document.createElement("div");
    grid.className = "thumbs"; // reuse existing grid styling
    grid.style.marginTop = "0";

    (rounds[r] ?? []).forEach((m, i) => {
      const t = document.createElement("div");
      const isActive = (r === viewRound && i === viewMatchIndex);
      const isDecided = !!m.winner_img;

      t.className = "thumb" + (isActive ? " active" : "") + (isDecided ? " decided" : "");
      t.innerHTML = thumbHTML(m);

      // Click to view any matchup in any round
      t.onclick = async () => {
        viewRound = r;
        viewMatchIndex = i;
        await refreshCounts(); // safe no-op for placeholders
        render();
        updateStatusLine();
      };

      grid.appendChild(t);
    });

    thumbsEl.appendChild(grid);
  }
}

async function refreshCounts(){
  const m = getViewedMatch();
  if (!m?.id){
    countLeft.textContent = "0";
    countRight.textContent = "0";
    return;
  }
  const c = await loadCounts(m.id);
  countLeft.textContent = c.l;
  countRight.textContent = c.r;
}

function updateStatusLine(){
  if (!sessionUser){
    setStatus("Sign in to vote. (You can vote once per match.)");
    return;
  }

  const m = getViewedMatch();
  if (!m){
    setStatus("No matchup selected.", "warn");
    return;
  }

  if (viewRound !== activeRound){
    setStatus(`Viewing ${ROUND_NAMES[viewRound]}. Voting is only enabled in LIVE round: ${ROUND_NAMES[activeRound]}.`, "warn");
    return;
  }

  if (!m.id){
    setStatus("This slot hasn't been created yet. (Waiting for winners to advance.)", "warn");
    return;
  }

  if (!matchHasOpponent(m)){
    setStatus("Waiting for an opponent (TBD). Voting is locked until both sides exist.", "warn");
    return;
  }

  if (m.winner_img){
    setStatus("This match is decided. Pick another matchup.", "warn");
    return;
  }

  if (votedMatchIds.has(m.id)){
    setStatus("You already voted in THIS matchup. You can vote in other matchups.", "warn");
    return;
  }

  setStatus("You can vote once in this matchup.", "ok");
}



/* =========================
   ADVANCE (SELF-HEAL)
========================= */
async function tryAutoAdvanceIfReady(matchId){
  if (!matchId) return false;
  try{
    const { error } = await supabase.rpc("advance_match_v2", { p_match_id: matchId });
    if (error){
      console.warn("advance_match_v2 error:", error);
      setStatus("Advance RPC failed: " + error.message, "warn");
      return false;
    }
    return true;
  } catch(e){
    console.warn("advance_match_v2 crash:", e);
    setStatus("Advance RPC crashed: " + (e?.message ?? e), "warn");
    return false;
  }
}

/* =========================
   VOTE
========================= */
async function castVote(side){
  const m = getViewedMatch();
  if (!m || !sessionUser) return;

  if (viewRound !== activeRound){
    setStatus("Voting is only enabled in the LIVE round.", "warn");
    return;
  }

  if (!m.id){
    setStatus("This match hasn't been created yet.", "warn");
    return;
  }

  if (!matchHasOpponent(m)){
    setStatus("Waiting for an opponent (TBD).", "warn");
    return;
  }

  if (votedMatchIds.has(m.id)){
    setStatus("Already voted in this matchup.", "warn");
    return;
  }

  setStatus("Submitting vote…");

  const { error } = await supabase
    .from("round_votes_v2")
    .insert({
      user_id: sessionUser.id,
      round: activeRound,
      match_id: m.id,
      side
    });

  if (error){
    if (String(error.code) === "23505"){
      votedMatchIds.add(m.id);
      setStatus("Already voted in this matchup (DB enforced).", "warn");
      keepCurrentMatch = true;
      await refreshAll();
      return;
    }
    setStatus("Vote failed: " + error.message, "warn");
    return;
  }

  votedMatchIds.add(m.id);
  setStatus("Vote submitted.", "ok");

  // Stay on the same battle screen after voting
  keepCurrentMatch = true;

  // Auto-advance (winner_img should be written in DB by this RPC)
  const { error: advErr } = await supabase.rpc("advance_match_v2", { p_match_id: m.id });
  if (advErr){
    // Don't block UI, but tell you what's wrong (usually permissions/RLS)
    console.warn("advance_match_v2 error:", advErr);
    setStatus("Vote saved. Advance RPC failed: " + advErr.message, "warn");
  }

  await refreshAll();
}

voteLeft.onclick=()=>castVote("left");
voteRight.onclick=()=>castVote("right");

/* =========================
   REFRESH
========================= */
async function refreshAll(){
  try{
    const { data: sess, error: sessErr } = await supabase.auth.getSession();
    if (sessErr) throw sessErr;

    sessionUser = sess?.session?.user ?? null;
    updateAuthUI();

    // Remember current selection
    const prev = keepCurrentMatch ? {
      round: viewRound,
      id: getViewedMatch()?.id ?? null,
      idx: viewMatchIndex
    } : null;

    activeRound = await detectActiveRound();
    rounds = await loadAllRounds();

    // Default view to first unfinished in active round (or first match)
    if (!prev){
      viewRound = activeRound;
      const firstUnfinished = (rounds[activeRound] ?? []).findIndex(m => m?.id && !m.winner_img);
      viewMatchIndex = firstUnfinished >= 0 ? firstUnfinished : 0;
    } else {
      // try to restore the exact match id (preferred), else keep same slot
      if (prev.id){
        const idx = (rounds[prev.round] ?? []).findIndex(mm => mm?.id === prev.id);
        if (idx >= 0){
          viewRound = prev.round;
          viewMatchIndex = idx;
        } else {
          viewRound = prev.round;
          viewMatchIndex = Math.min(prev.idx ?? 0, (rounds[prev.round]?.length ?? 1) - 1);
        }
      } else {
        viewRound = prev.round;
        viewMatchIndex = Math.min(prev.idx ?? 0, (rounds[prev.round]?.length ?? 1) - 1);
      }
      keepCurrentMatch = false;
    }

    votedMatchIds = await loadUserVotedMatchIds(sessionUser?.id, activeRound);

    render();
    await refreshCounts();
    // Self-heal: if a match already reached 2 votes but winner_img wasn't written yet, try advancing now
    const vm = getViewedMatch();
    if (vm?.id && !vm.winner_img){
      try{
        const c2 = await loadCounts(vm.id);
        if ((c2.l >= 2 || c2.r >= 2)){
          const advanced = await tryAutoAdvanceIfReady(vm.id);
          if (advanced){
            // Reload all rounds so thumbnails + LIVE round update immediately
            activeRound = await detectActiveRound();
            rounds = await loadAllRounds();

            // Restore view by id if possible
            const ridx = (rounds[vm.round] ?? []).findIndex(mm => mm?.id === vm.id);
            if (ridx >= 0){
              viewRound = vm.round;
              viewMatchIndex = ridx;
            }
            render();
            await refreshCounts();
          }
        }
      } catch(e){
        console.warn("Self-heal check failed:", e);
      }
    }

    updateStatusLine();
  } catch(e){
    console.error(e);
    setStatus("Load error: " + (e?.message ?? e), "warn");
  }
}

await refreshAll();
</script>

</body>
</html>