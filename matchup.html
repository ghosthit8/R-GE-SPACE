<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <!-- VOTE-TO-WIN BUILD v4 (NO EDGE TIMER) -->
  <title>Rage Space ‚Äî Matchup (32-up ‚Üí 2-up)</title>
  <link rel="stylesheet" href="style.css"/>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <style>
    :root { --fg:#e5e7eb; --bg:#0b0f13; --accent:#39ff14; --muted:#8b8b8b; --card:#0f1318; --border:#20242a; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,Segoe UI,Roboto,Inter,ui-sans-serif; }
    .wrap { max-width:700px; margin:0 auto; padding:16px 12px 96px; }
    h1 { margin:0 0 10px; font-size:20px; font-weight:700; letter-spacing:.5px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .timer { font-variant-numeric: tabular-nums; font-weight:700; font-size:32px; line-height:1; padding:8px 14px; border:1px solid var(--border); border-radius:12px; background:var(--card); }
    .state { color:var(--muted); font-size:12px; }

    .round-label { font-size:13px; color:var(--muted); }

    .card { margin-top:12px; border:1px solid var(--border); border-radius:16px; overflow:hidden; background:var(--card); }
    .imgBox { position:relative; width:100%; aspect-ratio:3/4; background:#111; display:grid; place-items:center; }
    .imgBox img, .imgBox video { width:100%; height:100%; object-fit:cover; display:block; }
    .fullscreenBtn { position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.55); color:var(--accent); border:1px solid var(--accent); border-radius:8px; font-size:14px; padding:4px 8px; cursor:pointer; font-weight:700; }
    .bar { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; gap:8px; border-top:1px solid var(--border); }
    .label { text-transform:uppercase; letter-spacing:.12em; font-weight:700; font-size:12px; color:#a1a1a1; }
    .counts { font-variant-numeric: tabular-nums; font-weight:700; }
    .btn, .vote, .linkbtn, .backbtn { appearance:none; border:1px solid #24303a; background:#131920; color:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:700; text-decoration:none; display:inline-flex; align-items:center; }
    .btn.ghost { color:#a0aec0; }
    button.vote { padding:10px 14px; }
    button.vote:disabled { opacity:.6; cursor:default; }

    /* tiny AFK row under vote */
    .autoRow {
      display:flex;
      justify-content:flex-end;
      padding:0 12px 8px;
    }

    /* tiny AFK auto-vote button */
    .autoVoteBtn {
      padding: 2px 6px;
      font-size: 9px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      cursor: pointer;
      white-space: nowrap;
    }
    .autoVoteBtn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .navArrow {
      border: 1px solid var(--accent);
      background: rgba(0,0,0,0.45);
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
    }
    .navArrow:disabled {
      opacity: .35;
      cursor: default;
    }

    .piece-meta {
      padding:6px 12px 10px;
      border-top:1px solid var(--border);
      font-size:12px;
      color:var(--muted);
    }
    .piece-meta .piece-desc { white-space:pre-wrap; }
    .piece-meta .seeMoreBtn {
      margin-top:4px;
      font-size:11px;
      border-radius:999px;
      padding:3px 8px;
      border:1px solid var(--accent);
      background:transparent;
      color:var(--accent);
      cursor:pointer;
    }

    .thumbs-wrap { margin-top:16px; }
    .thumbs-title { font-size:12px; opacity:.6; margin-bottom:6px; }
    .thumbs { display:grid; grid-template-columns:repeat(3,1fr); gap:10px; }
    .thumb { border:1px solid var(--border); border-radius:12px; overflow:hidden; background:var(--card); cursor:pointer; position:relative; }
    .thumb.disabled { opacity:.55; cursor:default; }
    .thumb.active { border-color:var(--accent); box-shadow:0 0 0 1px rgba(57,255,20,.3); }

    .thumb-img {
      position:relative;
      width:100%;
      aspect-ratio:3/4;
      background:#0b0f13;
      overflow:hidden;
    }
    .thumb-img img,
    .thumb-img video {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .thumb-img.diag img.half,
    .thumb-img.diag video.half {
      position:absolute;
      inset:0;
    }
    .thumb-img.diag img.left,
    .thumb-img.diag video.left {
      clip-path:polygon(0 0, 100% 0, 0 100%);
    }
    .thumb-img.diag img.right,
    .thumb-img.diag video.right {
      clip-path:polygon(100% 0, 100% 100%, 0 100%);
    }
    .thumb-img.diag::before {
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:linear-gradient(135deg, rgba(0,0,0,0.75) 48%, rgba(57,255,20,0.7) 50%, rgba(0,0,0,0.75) 52%);
      mix-blend-mode:screen;
      opacity:0.5;
    }

    .video-badge {
      position:absolute;
      top:6px;
      left:6px;
      padding:2px 6px;
      font-size:9px;
      font-weight:700;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:#0b0f13;
      background:var(--accent);
      border-radius:999px;
      box-shadow:0 0 8px rgba(57,255,20,.8);
      pointer-events:none;
      z-index:2;
    }

    .thumb-preview {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      z-index:3;
    }

    .thumb-label { padding:6px 8px 8px; font-size:11px; display:flex; justify-content:space-between; align-items:center; }
    .thumb-count { font-variant-numeric: tabular-nums; font-weight:700; }
    .ghostBox { width:100%; height:100%; display:grid; place-items:center; color:#3b3b3b; font-weight:700; font-size:13px; letter-spacing:.08em; }

    .winner { margin-top:14px; padding:10px 12px; border:1px dashed #2a343f; border-radius:12px; color:#cbd5e1; font-size:14px; }
    .winner b { color:#39ff14; }

    .final-card { margin-top:14px; }
    .final-inner { display:flex; gap:12px; flex-wrap:wrap; padding:12px; }
    .final-slot { flex:1 1 150px; background:#0b0f13; border:1px dashed var(--border); border-radius:10px; padding:8px; text-align:center; }
    .final-slot .label { display:block; margin-bottom:4px; }
    .final-slot .thumb-final { width:100%; aspect-ratio:3/4; background:#000; border-radius:8px; overflow:hidden; display:grid; place-items:center; position:relative; }
    .final-slot .thumb-final img,
    .final-slot .thumb-final video { width:100%; height:100%; object-fit:cover; }

    .final-footer { padding:0 12px 12px; font-size:12px; color:#9aa0a6; }

    .fullscreen-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); justify-content:center; align-items:center; z-index:9999; }
    .fullscreen-overlay img,
    .fullscreen-overlay video { max-width:90%; max-height:90%; border-radius:8px; }
    .fullscreen-overlay button { position:absolute; top:20px; right:20px; background:#111; border:1px solid var(--accent); color:var(--accent); padding:6px 10px; border-radius:6px; font-weight:700; cursor:pointer; }

    .hint { margin-top:10px; color:#9aa0a6; font-size:12px; }
    .hidden { display:none !important; }

    .artist-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: 700;
    }
    .artist-link:hover { text-decoration: underline; }

    </style>
</head>
<body>

<div class="wrap">
  <h1 class="glitch-title" data-text="ART BATTLE. Faction I.">ART BATTLE. Faction I.</h1>

  <div class="header">
    <div class="row">
<div class="round-label" id="currentRound">Current round: ‚Äî</div>
    </div>
    <div class="row">
      <a class="backbtn" href="menu.html">‚Üê Menu</a>
      <a class="linkbtn" href="winners.html">Winners</a>
      <button class="navArrow" id="prevMatch">‚ü®</button>
      <button class="navArrow" id="nextMatch">‚ü©</button>
    </div>
  </div>

  <!-- TOP CARD -->
  <div class="card" id="activeTop">
    <div class="imgBox">
      <img id="imgActive1" alt="Active top">
      <video id="vidActive1" class="hidden" muted playsinline loop controls></video>
      <button class="fullscreenBtn" onclick="openFull('active1')">‚§¢</button>
    </div>
    <div class="bar">
      <div class="label" id="labelActive1">Top</div>
      <div class="counts" id="countActive1">0</div>
      <button class="vote" id="btnActive1">Vote</button>
    </div>
    <div class="autoRow">
      <button class="autoVoteBtn" id="autoActive1">vote this art for every round</button>
    </div>
    <div class="piece-meta hidden" id="metaActive1"></div>
  </div>

  <!-- BOTTOM CARD -->
  <div class="card" id="activeBottom">
    <div class="imgBox">
      <img id="imgActive2" alt="Active bottom">
      <video id="vidActive2" class="hidden" muted playsinline loop controls></video>
      <button class="fullscreenBtn" onclick="openFull('active2')">‚§¢</button>
    </div>
    <div class="bar">
      <div class="label" id="labelActive2">Bottom</div>
      <div class="counts" id="countActive2">0</div>
      <button class="vote" id="btnActive2">Vote</button>
    </div>
    <div class="autoRow">
      <button class="autoVoteBtn" id="autoActive2">vote this art for every round</button>
    </div>
    <div class="piece-meta hidden" id="metaActive2"></div>
  </div>

  <!-- THUMBS -->
  <div class="thumbs-wrap">
    <div class="thumbs-title">Matches (tap to switch)</div>
    <div class="thumbs" id="thumbGrid"></div>
  </div>

  <div class="winner" id="winnerText">
    R32 locks at 69,120s remaining ‚Üí R16 at 51,840s ‚Üí Quarters at 34,560s ‚Üí Semis at 17,280s ‚Üí Final at 0s.
  </div>

  <!-- FINAL BOX -->
  <div class="card final-card" id="finalCard">
    <div class="bar">
      <div class="label">Final</div>
      <div style="font-size:12px;color:#a1a1a1;">Decides at 0s</div>
    </div>
    <div class="final-inner">
      <div class="final-slot">
        <span class="label" id="finalLeftLabel">Winner of Semi 1</span>
        <div class="thumb-final">
          <img id="finalImg1" alt="Final slot 1">
          <video id="finalVid1" class="hidden" muted playsinline loop controls></video>
        </div>
      </div>
      <div class="final-slot">
        <span class="label" id="finalRightLabel">Winner of Semi 2</span>
        <div class="thumb-final">
          <img id="finalImg2" alt="Final slot 2">
          <video id="finalVid2" class="hidden" muted playsinline loop controls></video>
        </div>
      </div>
    </div>
    <div class="final-footer" id="finalFooter">Waiting‚Ä¶ (tap a card‚Äôs ‚§¢ for audio)</div>
  </div>

  <div class="hint">
    24-hour tournament: 32 images ‚Üí R32 (first 4h48m) ‚Üí R16 ‚Üí QF ‚Üí SF ‚Üí Final (last 4h48m).
  </div>
</div>

<!-- FULLSCREEN OVERLAY -->
<div class="fullscreen-overlay" id="overlay">
  <button id="closeFull">‚úï Close</button>
  <img id="fullImg" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=">
  <video id="fullVideo" class="hidden" playsinline controls></video>
</div>

<script src="js/champion-overlay.js"></script>

<script>
  const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // ====== VOTE-TO-WIN MODE (NO TIMER / NO EDGE FUNCTION) ======
  const WIN_TO = 2; // first to 2 wins (change later if you want)

  const RSID_KEY = "rsid_v2";
  let RSID = localStorage.getItem(RSID_KEY);
  if (!RSID){
    RSID = (crypto.randomUUID?.() || Math.random().toString(36).slice(2)+Date.now());
    localStorage.setItem(RSID_KEY, RSID);
  }

  // UI refs 
  const winnerText = document.getElementById("winnerText");
  const currentRoundEl = document.getElementById("currentRound");

  const imgActive1 = document.getElementById("imgActive1");
  const imgActive2 = document.getElementById("imgActive2");
  const vidActive1 = document.getElementById("vidActive1");
  const vidActive2 = document.getElementById("vidActive2");
  const labelActive1 = document.getElementById("labelActive1");
  const labelActive2 = document.getElementById("labelActive2");
  const countActive1 = document.getElementById("countActive1");
  const countActive2 = document.getElementById("countActive2");
  const btnActive1 = document.getElementById("btnActive1");
  const btnActive2 = document.getElementById("btnActive2");
  const metaActive1 = document.getElementById("metaActive1");
  const metaActive2 = document.getElementById("metaActive2");
  const autoBtn1 = document.getElementById("autoActive1");
  const autoBtn2 = document.getElementById("autoActive2");

  const finalImg1 = document.getElementById("finalImg1");
  const finalImg2 = document.getElementById("finalImg2");
  const finalVid1 = document.getElementById("finalVid1");
  const finalVid2 = document.getElementById("finalVid2");
  const finalLeftLabel  = document.getElementById("finalLeftLabel");
  const finalRightLabel = document.getElementById("finalRightLabel");
  const finalFooter = document.getElementById("finalFooter");

  const prevBtn = document.getElementById("prevMatch");
  const nextBtn = document.getElementById("nextMatch");
  const thumbGrid = document.getElementById("thumbGrid");

  // Keep the layout exactly the same ‚Äî we just replace the timer text.
  
  // -----------------------------
  // Bracket model (match keys)
  // -----------------------------
  const matchOrder = [
    "rr1","rr2","rr3","rr4","rr5","rr6","rr7","rr8","rr9","rr10","rr11","rr12","rr13","rr14","rr15","rr16",
    "r1","r2","r3","r4","r5","r6","r7","r8",
    "q1","q2","q3","q4",
    "s1","s2",
    "final"
  ];

  const matchLabels = {
    rr1:"R32 1", rr2:"R32 2", rr3:"R32 3", rr4:"R32 4", rr5:"R32 5", rr6:"R32 6", rr7:"R32 7", rr8:"R32 8",
    rr9:"R32 9", rr10:"R32 10", rr11:"R32 11", rr12:"R32 12", rr13:"R32 13", rr14:"R32 14", rr15:"R32 15", rr16:"R32 16",
    r1:"R16 1", r2:"R16 2", r3:"R16 3", r4:"R16 4", r5:"R16 5", r6:"R16 6", r7:"R16 7", r8:"R16 8",
    q1:"QF 1", q2:"QF 2", q3:"QF 3", q4:"QF 4",
    s1:"Semi 1", s2:"Semi 2",
    final:"Final"
  };

  // winner propagation mapping:
  // [fromMatch] -> { to: nextMatchKey, slot: "left"|"right" }
  const advanceMap = {
    rr1:{to:"r1",slot:"left"},  rr2:{to:"r1",slot:"right"},
    rr3:{to:"r2",slot:"left"},  rr4:{to:"r2",slot:"right"},
    rr5:{to:"r3",slot:"left"},  rr6:{to:"r3",slot:"right"},
    rr7:{to:"r4",slot:"left"},  rr8:{to:"r4",slot:"right"},
    rr9:{to:"r5",slot:"left"},  rr10:{to:"r5",slot:"right"},
    rr11:{to:"r6",slot:"left"}, rr12:{to:"r6",slot:"right"},
    rr13:{to:"r7",slot:"left"}, rr14:{to:"r7",slot:"right"},
    rr15:{to:"r8",slot:"left"}, rr16:{to:"r8",slot:"right"},

    r1:{to:"q1",slot:"left"}, r2:{to:"q1",slot:"right"},
    r3:{to:"q2",slot:"left"}, r4:{to:"q2",slot:"right"},
    r5:{to:"q3",slot:"left"}, r6:{to:"q3",slot:"right"},
    r7:{to:"q4",slot:"left"}, r8:{to:"q4",slot:"right"},

    q1:{to:"s1",slot:"left"}, q2:{to:"s1",slot:"right"},
    q3:{to:"s2",slot:"left"}, q4:{to:"s2",slot:"right"},

    s1:{to:"final",slot:"left"}, s2:{to:"final",slot:"right"},
  };

  // -----------------------------
  // Local state
  // -----------------------------
  let cycle = null;               // row from cycles_v2
  let matches = {};               // { match_key: {left_url,right_url,winner_url,winner_side} }
  let counts = {};                // { match_key: {left,right} }
  let activeMatch = "rr1";

  // vote memory (prevents repeat voting on same match in the same cycle)
  const memKey = (cycleId) => `voteMem:${cycleId}`;
  function memRead(cycleId){
    try{ return JSON.parse(localStorage.getItem(memKey(cycleId))||"{}")||{}; }catch{ return {}; }
  }
  function memWrite(cycleId, matchKey, side){
    const m = memRead(cycleId);
    m[matchKey] = side;
    localStorage.setItem(memKey(cycleId), JSON.stringify(m));
  }

  // -----------------------------
  // Media helpers
  // -----------------------------
  const isVideo = (url="") => /\.(mp4|webm|ogg)(\?|#|$)/i.test(url) || /video\//i.test(url);

  function setCardMedia(imgEl, vidEl, url){
    if (!url){
      imgEl.src = "";
      vidEl.src = "";
      imgEl.classList.remove("hidden");
      vidEl.classList.add("hidden");
      return;
    }
    if (isVideo(url)){
      vidEl.src = url;
      vidEl.classList.remove("hidden");
      imgEl.classList.add("hidden");
    } else {
      imgEl.src = url;
      imgEl.classList.remove("hidden");
      vidEl.classList.add("hidden");
      vidEl.removeAttribute("src");
    }
  }

  // Fullscreen overlay (uses existing HTML)
  const overlay = document.getElementById("overlay");
  const closeFullBtn = document.getElementById("closeFull");
  const fullImg = document.getElementById("fullImg");
  const fullVideo = document.getElementById("fullVideo");

  window.openFull = function(which){
    const m = matches[activeMatch] || {};
    const url = (which==="active1") ? m.left_url : m.right_url;
    if (!url) return;

    overlay.style.display = "flex";
    if (isVideo(url)){
      fullVideo.src = url;
      fullVideo.classList.remove("hidden");
      fullImg.classList.add("hidden");
      fullImg.removeAttribute("src");
      try{ fullVideo.play().catch(()=>{}); }catch{}
    } else {
      fullImg.src = url;
      fullImg.classList.remove("hidden");
      fullVideo.classList.add("hidden");
      fullVideo.removeAttribute("src");
    }
  };

  closeFullBtn.onclick = ()=>{
    overlay.style.display = "none";
    try{ fullVideo.pause(); }catch{}
    fullVideo.removeAttribute("src");
  };
  overlay.addEventListener("click", (e)=>{
    if (e.target === overlay) closeFullBtn.click();
  });

  // -----------------------------
  // DB helpers
  // -----------------------------
  async function getSessionUser(){
    const { data } = await supabase.auth.getSession();
    const sess = data?.session || null;
    return sess?.user || null;
  }

  async function loadLatestCycle(){
    const { data, error } = await supabase
      .from("cycles_v2")
      .select("*")
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) throw error;
    if (!data) throw new Error("No cycle found in cycles_v2.");
    return data;
  }

    async function ensureMatchRows(){
    const cycleId = cycle.id;

    // Pull existing rows (if any)
    const { data: existing, error: exErr } = await supabase
      .from("bracket_matches_v2")
      .select("match_key,left_url,right_url,winner_url,winner_side")
      .eq("cycle_id", cycleId);

    if (exErr) throw exErr;

    const existingMap = {};
    for (const r of (existing || [])) existingMap[r.match_key] = r;

    const hasAllRows = (existing || []).length >= matchOrder.length;
    const rr1 = existingMap["rr1"];
    const looksUnseeded = !rr1 || (!rr1.left_url && !rr1.right_url);

    // Collect seeds from cycles_v2 dynamically.
    // Works with seed_a_url..seed_af_url OR seed_1_url..seed_32_url OR any "seed*url" pattern.
    const seedPairs = Object.entries(cycle)
      .filter(([k,v]) => typeof v === "string" && v && /seed/i.test(k) && /url/i.test(k));

    function naturalRank(key){
      const s = String(key);
      const m = s.match(/(\d+)/);
      if (m) return [0, parseInt(m[1], 10), s];
      return [1, 0, s];
    }
    seedPairs.sort((a,b)=>{
      const ra = naturalRank(a[0]);
      const rb = naturalRank(b[0]);
      if (ra[0] !== rb[0]) return ra[0]-rb[0];
      if (ra[1] !== rb[1]) return ra[1]-rb[1];
      return ra[2].localeCompare(rb[2]);
    });

    const seeds = seedPairs.map(([k,v]) => v).filter(Boolean);

    // If we already have a full, seeded bracket, do nothing.
    if (hasAllRows && !looksUnseeded) return;

    const r32 = seeds.slice(0, 32);
    const rrKeys = matchOrder.filter(k => k.startsWith("rr"));
    const rrAssign = {};
    for (let i=0; i<rrKeys.length; i++){
      const mk = rrKeys[i];
      rrAssign[mk] = { left: r32[i*2] || null, right: r32[i*2+1] || null };
    }

    const rows = matchOrder.map((mk)=>{
      const slot = rrAssign[mk] || { left:null, right:null };
      return {
        cycle_id: cycleId,
        match_key: mk,
        left_url: slot.left,
        right_url: slot.right,
        winner_side: null,
        winner_url: null,
      };
    });

    const { error: upErr } = await supabase
      .from("bracket_matches_v2")
      .upsert(rows, { onConflict: "cycle_id,match_key" });

    if (upErr) throw upErr;
  }

  async function loadMatches(){
    const cycleId = cycle.id;

    const { data, error } = await supabase
      .from("bracket_matches_v2")
      .select("match_key,left_url,right_url,winner_side,winner_url")
      .eq("cycle_id", cycleId);

    if (error) throw error;

    const map = {};
    for (const row of (data||[])) map[row.match_key] = row;
    matches = map;
  }

  async function loadCounts(){
    const cycleId = cycle.id;

    const { data, error } = await supabase
      .from("phase_votes_v2")
      .select("match_key,side")
      .eq("cycle_id", cycleId);

    if (error) throw error;

    const c = {};
    for (const v of (data||[])){
      const mk = v.match_key;
      const side = v.side === "left" ? "left" : "right";
      c[mk] = c[mk] || { left:0, right:0 };
      c[mk][side] += 1;
    }
    counts = c;
  }

  function getCount(matchKey, side){
    return (counts?.[matchKey]?.[side] ?? 0);
  }

  function isReady(matchKey){
    const m = matches[matchKey];
    return !!(m && m.left_url && m.right_url);
  }

  // -----------------------------
  // Rendering
  // -----------------------------
  function setMeta(el, url){
    // Edge used to provide meta_by_url. Without it, we keep these hidden.
    el.classList.add("hidden");
    el.innerHTML = "";
  }

  function renderActive(){
    const m = matches[activeMatch] || {};
    const leftUrl = m.left_url || null;
    const rightUrl = m.right_url || null;

    const leftCt = getCount(activeMatch, "left");
    const rightCt = getCount(activeMatch, "right");

    // labels
    currentRoundEl.textContent = `Current round: ${matchLabels[activeMatch] || activeMatch}`;
    labelActive1.textContent = "Top";
    labelActive2.textContent = "Bottom";

    // media
    setCardMedia(imgActive1, vidActive1, leftUrl);
    setCardMedia(imgActive2, vidActive2, rightUrl);

    // counts
    countActive1.textContent = leftCt;
    countActive2.textContent = rightCt;

    // meta
    setMeta(metaActive1, leftUrl);
    setMeta(metaActive2, rightUrl);

    const decided = !!m.winner_url;
    const ready = !!(leftUrl && rightUrl);

    // vote buttons
    const mem = cycle?.id ? memRead(cycle.id) : {};
    const alreadyVoted = !!mem[activeMatch];

    btnActive1.disabled = !ready || decided || alreadyVoted;
    btnActive2.disabled = !ready || decided || alreadyVoted;

    // AFK buttons (keep UI but disable; you can re-add later)
    autoBtn1.disabled = true;
    autoBtn2.disabled = true;

    // info banner
    if (!ready){
      winnerText.innerHTML = `Waiting for opponent‚Ä¶ <span style="opacity:.7">(${matchLabels[activeMatch] || activeMatch})</span><br><b>First to ${WIN_TO} wins.</b>`;
    } else if (decided){
      winnerText.innerHTML = `<b>Winner decided.</b> First to ${WIN_TO} wins.`;
    } else {
      winnerText.innerHTML = `<b>First to ${WIN_TO} wins.</b>`;
    }

    renderFinalBox();
    renderThumbs();
    updateNavButtons();
  }

  function renderFinalBox(){
    const m = matches["final"] || {};
    const l = m.left_url || null;
    const r = m.right_url || null;

    setCardMedia(finalImg1, finalVid1, l);
    setCardMedia(finalImg2, finalVid2, r);

    const decided = !!m.winner_url;
    if (decided){
      finalFooter.textContent = "Winner decided.";
    } else if (l && r){
      finalFooter.textContent = `Final live ‚Äî first to ${WIN_TO} wins.`;
    } else {
      finalFooter.textContent = "Waiting‚Ä¶ (tap a card‚Äôs ‚§¢ for audio)";
    }
  }

  function renderThumbs(){
    thumbGrid.innerHTML = "";

    for (const mk of matchOrder){
      const m = matches[mk] || {};
      const leftUrl = m.left_url || null;
      const rightUrl = m.right_url || null;

      const leftCt = getCount(mk,"left");
      const rightCt = getCount(mk,"right");

      const t = document.createElement("div");
      t.className = "thumb" + (mk===activeMatch ? " active" : "") + (!isReady(mk) ? " disabled" : "");

      const imgWrap = document.createElement("div");
      imgWrap.className = "thumb-img";

      // If both exist, show diagonal split preview (like your old UI)
      if (leftUrl && rightUrl){
        imgWrap.classList.add("diag");

        const makeHalf = (url, side) => {
          if (isVideo(url)){
            const v = document.createElement("video");
            v.className = `half ${side}`;
            v.muted = true;
            v.playsInline = true;
            v.loop = true;
            v.src = url;
            v.autoplay = true;
            return v;
          } else {
            const i = document.createElement("img");
            i.className = `half ${side}`;
            i.loading = "lazy";
            i.src = url;
            return i;
          }
        };

        imgWrap.appendChild(makeHalf(leftUrl,"left"));
        imgWrap.appendChild(makeHalf(rightUrl,"right"));
      } else if (leftUrl || rightUrl){
        const url = leftUrl || rightUrl;
        if (isVideo(url)){
          const v = document.createElement("video");
          v.className = "thumb-preview";
          v.muted = true;
          v.playsInline = true;
          v.loop = true;
          v.src = url;
          v.autoplay = true;
          imgWrap.appendChild(v);
        } else {
          const i = document.createElement("img");
          i.className = "thumb-preview";
          i.loading = "lazy";
          i.src = url;
          imgWrap.appendChild(i);
        }
      } else {
        const g = document.createElement("div");
        g.className = "ghostBox";
        g.textContent = "‚Äî";
        imgWrap.appendChild(g);
      }

      t.appendChild(imgWrap);

      const lab = document.createElement("div");
      lab.className = "thumb-label";
      const left = document.createElement("span");
      left.textContent = matchLabels[mk] || mk;
      const right = document.createElement("span");
      right.className = "thumb-count";
      right.textContent = `${leftCt}-${rightCt}`;
      lab.appendChild(left);
      lab.appendChild(right);
      t.appendChild(lab);

      t.onclick = ()=>{
        activeMatch = mk;
        renderActive();
      };

      thumbGrid.appendChild(t);
    }
  }

  function updateNavButtons(){
    const idx = matchOrder.indexOf(activeMatch);
    prevBtn.disabled = idx <= 0;
    nextBtn.disabled = idx >= matchOrder.length-1;
  }

  prevBtn.onclick = ()=>{
    const idx = matchOrder.indexOf(activeMatch);
    if (idx>0){ activeMatch = matchOrder[idx-1]; renderActive(); }
  };
  nextBtn.onclick = ()=>{
    const idx = matchOrder.indexOf(activeMatch);
    if (idx<matchOrder.length-1){ activeMatch = matchOrder[idx+1]; renderActive(); }
  };

  // -----------------------------
  // Voting / Winner logic
  // -----------------------------
  async function setWinner(matchKey, winnerSide){
    const m = matches[matchKey] || {};
    const winnerUrl = (winnerSide==="left") ? m.left_url : m.right_url;
    if (!winnerUrl) return;

    // Persist winner
    const { error } = await supabase
      .from("bracket_matches_v2")
      .update({ winner_side: winnerSide, winner_url: winnerUrl })
      .eq("cycle_id", cycle.id)
      .eq("match_key", matchKey);

    if (error) throw error;

    // Advance to next match slot (if any)
    const adv = advanceMap[matchKey];
    if (adv){
      const patch = {};
      patch[adv.slot + "_url"] = winnerUrl;

      const { error: advErr } = await supabase
        .from("bracket_matches_v2")
        .update(patch)
        .eq("cycle_id", cycle.id)
        .eq("match_key", adv.to);

      if (advErr) throw advErr;
    }
  }

  async function vote(side){
    if (!cycle?.id) return;

    const user = await getSessionUser();
    if (!user){
      alert("You need to be signed in to vote.");
      return;
    }

    const mem = memRead(cycle.id);
    if (mem[activeMatch]) return;

    // Only allow voting if match is ready and not decided
    const m = matches[activeMatch] || {};
    if (!m.left_url || !m.right_url) return;
    if (m.winner_url) return;

    // Insert vote (server should enforce unique per voter per match)
    const payload = {
      cycle_id: cycle.id,
      match_key: activeMatch,
      side: side,              // "left" or "right"
      voter_id: user.id,
      rsid: RSID
    };

    const { error } = await supabase.from("phase_votes_v2").insert(payload);
    if (error){
      // likely already voted, just lock locally
      memWrite(cycle.id, activeMatch, side);
      await refresh();
      return;
    }

    memWrite(cycle.id, activeMatch, side);

    // refresh counts immediately
    await refresh();

    // decide winner if threshold reached (double-check DB values)
    const l = getCount(activeMatch,"left");
    const r = getCount(activeMatch,"right");

    if (l >= WIN_TO || r >= WIN_TO){
      const winSide = (l >= WIN_TO) ? "left" : "right";
      await setWinner(activeMatch, winSide);
      await refresh();
    }
  }

  btnActive1.onclick = ()=> vote("left");
  btnActive2.onclick = ()=> vote("right");

  // -----------------------------
  // Refresh (event-driven)
  // -----------------------------
  async function refresh(){
    await loadMatches();
    await loadCounts();

    // Auto-jump to first playable match if current one is not ready
    if (!isReady(activeMatch)){
      const firstReady = matchOrder.find(k => isReady(k) && !(matches[k]?.winner_url));
      if (firstReady) activeMatch = firstReady;
    }

    renderActive();
  }

  function subscribeRealtime(){
    // Any change to match slots / winners should re-render
    supabase.channel("bracket-matches-live")
      .on("postgres_changes", { event: "*", schema: "public", table: "bracket_matches_v2" }, () => {
        refresh().catch(()=>{});
      })
      .subscribe();

    // Any vote insert affects counts
    supabase.channel("votes-live")
      .on("postgres_changes", { event: "INSERT", schema: "public", table: "phase_votes_v2" }, () => {
        refresh().catch(()=>{});
      })
      .subscribe();
  }

  async function boot(){
    try{
      cycle = await loadLatestCycle();
      await ensureMatchRows();
      subscribeRealtime();
      await refresh();

      // Re-sync when you return to the tab
      document.addEventListener("visibilitychange", ()=>{
        if (!document.hidden) refresh().catch(()=>{});
      });
    }catch(e){
      console.error(e);
      winnerText.textContent = "Error loading bracket. Check console.";
    }
  }

  boot();
</script>
<script src="js/auth-guard.js" type="module"></script>
<!-- ================== RAGE DEBUGGER v2 (fixed button) ================== -->
<script>
(function () {
  const MAX_LINES = 2000;
  const EDGE_MATCH = /\/functions\/v1\/__none__/;

  // --- create floating button OUTSIDE the hidden panel ---
  const floatBtn = document.createElement('button');
  floatBtn.id = 'dbgFloatingBtn';
  floatBtn.textContent = 'üêõ Debug';
  floatBtn.style.cssText = `
    position: fixed; right: 8px; bottom: 8px;
    z-index: 2147483647; background:#000; color:#0f0;
    border:1px solid #0f0; border-radius:6px; padding:6px 10px;
    font: 12px/1.1 monospace; cursor:pointer;
  `;
  document.body.appendChild(floatBtn);

  // --- panel wrapper (starts hidden) ---
  const wrap = document.createElement('div');
  wrap.id = 'dbg';
  wrap.style.cssText = `
    position: fixed; right: 0; bottom: 0; left: 0;
    background: rgba(0,0,0,.92); color:#9f9; font: 12px/1.4 monospace;
    z-index: 2147483646; max-height: 45vh; display:none; box-shadow:0 -2px 12px rgba(0,0,0,.6);
  `;

  const bar = document.createElement('div');
  bar.style.cssText = 'display:flex; align-items:center; gap:6px; padding:6px; position:sticky; top:0; background:#111;';
  bar.innerHTML = `
    <span style="color:#6f6">Rage Debug</span>
    <label>Filter:
      <select id="dbgFilter">
        <option value="">All</option>
        <option>NET</option><option>EDGE</option><option>TIMER</option><option>CLOCK</option>
        <option>STAGE</option><option>UI</option><option>IMG</option><option>OBS</option>
        <option>ERR</option><option>WARN</option><option>LOG</option>
      </select>
    </label>
    <label><input id="dbgRecord" type="checkbox" checked> Record</label>
    <button id="dbgCopy">Copy</button>
    <button id="dbgDownload">Download</button>
    <button id="dbgClear">Clear</button>
    <span style="margin-left:auto"></span>
    <button id="dbgClose">‚úï</button>
  `;

  const list = document.createElement('div');
  list.style.cssText = 'padding:6px 8px; white-space:pre-wrap; overflow:auto; max-height:calc(45vh - 42px);';

  wrap.appendChild(bar); wrap.appendChild(list);
  document.body.appendChild(wrap);

  // button wiring
  function showDbg(v){ wrap.style.display = v ? 'block' : 'none'; }
  floatBtn.onclick = () => showDbg(wrap.style.display === 'none');
  bar.querySelector('#dbgClose').onclick = () => showDbg(false);

  // controls
  const filterSel  = bar.querySelector('#dbgFilter');
  const recordChk  = bar.querySelector('#dbgRecord');
  bar.querySelector('#dbgClear').onclick = () => { buffer = []; render(); };
  bar.querySelector('#dbgCopy').onclick = () => navigator.clipboard.writeText(buffer.map(r => r.line).join("\n"));
  bar.querySelector('#dbgDownload').onclick = () => {
    const blob = new Blob([buffer.map(r => r.line).join("\n")], {type:'text/plain'});
    const a = Object.assign(document.createElement('a'), {href: URL.createObjectURL(blob), download: `rage_debug_${Date.now()}.log`});
    a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  };

  // ring buffer + rendering
  let buffer = [];
  function push(kind, msg, extra) {
    if (!recordChk.checked) return;
    const ts = new Date().toLocaleTimeString();
    const line = `[${ts}] ${kind}: ${msg}`;
    buffer.push({kind, line, extra});
    if (buffer.length > MAX_LINES) buffer.shift();
    const f = filterSel.value;
    if (!f || f === kind) addLine({kind, line});
  }
  function addLine(r){
    const div = document.createElement('div');
    div.textContent = r.line;
    if (r.kind === 'ERR') div.style.color = '#f88';
    else if (r.kind === 'WARN') div.style.color = '#ff8';
    else if (r.kind === 'EDGE') div.style.color = '#8ff';
    else if (r.kind === 'NET')  div.style.color = '#8cf';
    else if (r.kind === 'TIMER' || r.kind === 'CLOCK') div.style.color = '#6f6';
    list.appendChild(div); list.scrollTop = list.scrollHeight;
  }
  function render(){
    list.innerHTML = '';
    const f = filterSel.value;
    for (const r of buffer) if (!f || f === r.kind) addLine(r);
  }
  filterSel.onchange = render;

  // console hooks
  const _log = console.log, _warn = console.warn, _err = console.error;
  console.log = (...a) => { try{push('LOG', a.map(String).join(' '));}catch{} _log.apply(console,a); };
  console.warn= (...a) => { try{push('WARN',a.map(String).join(' '));}catch{} _warn.apply(console,a);};
  console.error=(...a) => { try{push('ERR', a.map(String).join(' '));}catch{} _err.apply(console,a);};

  window.addEventListener('error', (e)=> push('ERR', `${e.message} @ ${e.filename}:${e.lineno}`));
  window.addEventListener('unhandledrejection', (e)=> push('ERR', (e.reason && e.reason.message) || String(e.reason)));

  // visibility & UI observers
  document.addEventListener('visibilitychange', () => push('OBS', `visibility: ${document.visibilityState}`));
  const q = (id) => document.getElementById(id);

  function observeText(id, kind) {
    const el = q(id); if (!el) return;
    let last = el.textContent;
    const mo = new MutationObserver(() => {
      if (el.textContent !== last) {
        last = el.textContent;
        push(kind, `${id} ‚Üí ${last}`);
      }
    });
    mo.observe(el, {childList:true, characterData:true, subtree:true});
  }
  observeText('phaseKey', 'STAGE');
  observeText('state', 'STAGE');

  (function watchClock(){
    const el = q('clock'); if (!el) return;
    let last = el.textContent, lastAt = performance.now();
    const mo = new MutationObserver(() => {
      const now = performance.now();
      if (el.textContent !== last) {
        const dt = ((now - lastAt)/1000).toFixed(2);
        push('CLOCK', `clock ${last} ‚Üí ${el.textContent} (Œîdom ${dt}s)`);
        last = el.textContent; lastAt = now;
      }
    });
    mo.observe(el, {childList:true, characterData:true, subtree:true});
  })();

  // fetch tracer
  const _fetch = window.fetch.bind(window);
  window.fetch = async function(url, opts = {}) {
    const start = performance.now();
    const method = (opts && opts.method) || 'GET';
    const tag = EDGE_MATCH.test(String(url)) ? 'EDGE' : 'NET';
    push(tag, `${method} ${url}`);
    try {
      const res = await _fetch(url, opts);
      const ms = (performance.now() - start).toFixed(0);
      push(tag, `${method} ${url} ‚Üí ${res.status} (${ms}ms)`);
      return res;
    } catch (e) {
      const ms = (performance.now() - start).toFixed(0);
      push(tag, `${method} ${url} ‚úñ ${e.name||'error'} (${ms}ms)`);
      throw e;
    }
  };
  // timers & rAF (disabled: avoid noisy TIMER logs)

  // image load tracing
  function hookImg(img){
    if (!img || img.__dbgHooked) return;
    img.__dbgHooked = true;
    img.addEventListener('load',  ()=> push('IMG', `loaded ${img.id||''} ${img.src}`));
    img.addEventListener('error', ()=> push('IMG', `ERROR  ${img.id||''} ${img.src}`));
  }
  Array.from(document.images).forEach(hookImg);
  const imgObs = new MutationObserver((ms)=>{
    for (const m of ms) for (const n of m.addedNodes) {
      if (n.tagName === 'IMG') hookImg(n);
      else if (n.querySelectorAll) n.querySelectorAll('img').forEach(hookImg);
    }
  });
  imgObs.observe(document.documentElement, {childList:true, subtree:true});

  // bracket observer
  const brows = document.getElementById('brows');
  if (brows) {
    const mo = new MutationObserver((ms)=>{
      let adds = 0, rems = 0;
      for (const m of ms) { adds += m.addedNodes.length; rems += m.removedNodes.length; }
      push('OBS', `bracket changed: +${adds} -${rems} (children=${brows.children.length})`);
    });
    mo.observe(brows, {childList:true, subtree:false});
  }

  // public helpers
  window.RageDebug = {
    log: (k, m) => push(k||'LOG', m||''),
    markStage: (stage, base) => push('STAGE', `mark stage=${stage} base=${base||''}`),
    markPaint: (slot, base) => push('UI', `paint slot=${slot} base=${base||''}`),
    markCounts: (slot, r, b) => push('UI', `counts slot=${slot} r=${r} b=${b}`),
  };

  // small banner
  (console.log||(()=>{}))('Debugger ready');
})();
</script>
<!-- ================== /RAGE DEBUGGER v2 ================== -->
</body>
</html>