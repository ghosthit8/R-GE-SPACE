<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space — Matchup</title>

<link rel="stylesheet" href="style.css"/>

<style>
body { background:#0b0f13; color:#e5e7eb; font-family:system-ui,Segoe UI,Roboto; margin:0; }
.wrap { max-width:700px; margin:auto; padding:16px 12px 96px; }

.timer { font-size:32px; padding:8px 14px; border:1px solid #20242a; border-radius:12px; background:#0f1318; }

.card { margin-top:12px; border:1px solid #20242a; border-radius:16px; overflow:hidden; background:#0f1318; }
.imgBox { aspect-ratio:3/4; background:#111; position:relative; }
.imgBox img { width:100%; height:100%; object-fit:cover; }

/* ===== WINNER DECIDED OVERLAY (only when match has winner_img) ===== */
.decidedOverlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  text-align:center;
  padding:18px;
  font-weight:900;
  letter-spacing:.10em;
  text-transform:uppercase;
  color:rgba(229,231,235,.92);
  background:linear-gradient(135deg, rgba(15,19,24,.92), rgba(15,19,24,.62));
  text-shadow:0 0 12px rgba(0,0,0,.65);
  backdrop-filter: blur(2px);
}
.decidedOverlay small{
  display:block;
  margin-top:10px;
  font-weight:700;
  letter-spacing:.02em;
  opacity:.9;
  text-transform:none;
}

.bar { display:flex; justify-content:space-between; padding:10px 12px; align-items:center; }
.vote { padding:10px 14px; border-radius:12px; background:#131920; border:1px solid #39ff14; color:#39ff14; cursor:pointer; }
.vote:disabled { opacity:.4; cursor:default; }

.topbar { display:flex; justify-content:space-between; align-items:center; gap:8px; margin:10px 0; }
.pill { padding:8px 12px; border-radius:999px; border:1px solid #20242a; background:#0f1318; font-size:14px; }
.btn { padding:8px 12px; border-radius:12px; border:1px solid rgba(57,255,20,.5); background:#0f1318; color:#39ff14; cursor:pointer; }
.btn:disabled { opacity:.4; cursor:default; }

.thumbs { display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-top:18px; }

.thumb{
  position:relative;
  border-radius:14px;
  overflow:hidden;
  cursor:pointer;
  background:#0f1318;
  border:1px solid rgba(57,255,20,.35);
  box-shadow:0 0 8px rgba(57,255,20,.15), inset 0 0 0 1px rgba(57,255,20,.15);
  transition:box-shadow .2s ease, transform .15s ease;
}
.thumb:hover{
  transform:translateY(-1px);
  box-shadow:0 0 14px rgba(57,255,20,.45), 0 0 32px rgba(57,255,20,.25), inset 0 0 0 1px rgba(57,255,20,.4);
}
.thumb.active{
  box-shadow:0 0 18px rgba(57,255,20,.9), 0 0 48px rgba(57,255,20,.55), inset 0 0 0 2px rgba(57,255,20,.9);
}

.thumb-img{ position:relative; width:100%; aspect-ratio:3/4; background:#0b0f13; }
.thumb-img img{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
.thumb-img img.left{ clip-path:polygon(0% 0%, 100% 0%, 0% 100%); }
.thumb-img img.right{ clip-path:polygon(100% 0%, 100% 100%, 0% 100%); }

.small{ font-size:12px; opacity:.8; }
.warn{ color:#ffcc66; }
.ok{ color:#39ff14; }

/* ===== TIERED THUMBS ===== */
.tier { margin-top:18px; }
.tier-line{
  height:2px;
  background:rgba(57,255,20,.65);
  box-shadow:0 0 12px rgba(57,255,20,.35);
  border-radius:999px;
  margin:18px 0 10px;
}
.tier-title{
  display:flex;
  justify-content:space-between;
  align-items:baseline;
  gap:10px;
  margin:0 2px 10px;
}
.tier-title b{ color:#39ff14; letter-spacing:.06em; }
.tier-title span{ font-size:12px; opacity:.75; }

.thumb .badge{
  position:absolute;
  top:8px;
  left:8px;
  padding:4px 8px;
  font-size:11px;
  border-radius:999px;
  background:rgba(15,19,24,.85);
  border:1px solid rgba(57,255,20,.45);
  color:#39ff14;
  backdrop-filter: blur(6px);
}
.thumb.decided{ opacity:.72; }
.thumb .tbd{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  letter-spacing:.08em;
  color:rgba(229,231,235,.85);
  background:linear-gradient(135deg, rgba(15,19,24,.92), rgba(15,19,24,.65));
  text-shadow:0 0 10px rgba(0,0,0,.55);
}
.thumb .dim{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.15);
  pointer-events:none;
}

</style>
</head>

<body>
<div class="wrap">

<h1>ART BATTLE. Faction I.</h1>

<div class="timer">—</div>

<div class="topbar">
  <button class="btn" id="btnBack">← Menu</button>
  <div class="pill" id="roundLabel">Loading…</div>
  <div style="display:flex; gap:8px; align-items:center;">
    <div class="pill" id="userLabel">Not signed in</div>
    <button class="btn" id="btnSignIn">Sign in</button>
    <button class="btn" id="btnSignOut" disabled>Sign out</button>
  </div>
</div>

<div class="small" id="statusLine"></div>

<div class="card">
  <div class="imgBox">
    <img id="imgLeft" alt="Active top">
    <div class="decidedOverlay" id="decidedOverlayTop">
      WINNER DECIDED
      <small>Pick another matchup below</small>
    </div>
  </div>
  <div class="bar">
    <span>Top</span>
    <span id="countLeft">0</span>
    <button class="vote" id="voteLeft" disabled>Vote</button>
  </div>
</div>

<div class="card">
  <div class="imgBox">
    <img id="imgRight" alt="Active bottom">
    <div class="decidedOverlay" id="decidedOverlayBottom">
      WINNER DECIDED
      <small>Moved to next battle</small>
    </div>
  </div>
  <div class="bar">
    <span>Bottom</span>
    <span id="countRight">0</span>
    <button class="vote" id="voteRight" disabled>Vote</button>
  </div>
</div>

<div class="thumbs" id="thumbs"></div>

</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

/* =========================
   SUPABASE (YOUR PROJECT)
========================= */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY =
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Back to menu
const btnBack = document.getElementById("btnBack");
if (btnBack) btnBack.onclick = () => { window.location.href = "menu.html"; };

/* =========================
   DOM
========================= */
const imgLeft = document.getElementById("imgLeft");
const imgRight = document.getElementById("imgRight");
const decidedOverlayTop = document.getElementById("decidedOverlayTop");
const decidedOverlayBottom = document.getElementById("decidedOverlayBottom");
const countLeft = document.getElementById("countLeft");
const countRight = document.getElementById("countRight");
const voteLeft = document.getElementById("voteLeft");
const voteRight = document.getElementById("voteRight");
const thumbsEl = document.getElementById("thumbs");
const roundLabel = document.getElementById("roundLabel");
const userLabel = document.getElementById("userLabel");
const statusLine = document.getElementById("statusLine");
const btnSignIn = document.getElementById("btnSignIn");
const btnSignOut = document.getElementById("btnSignOut");

/* =========================
   STATE
========================= */
let sessionUser = null;
let activeRound = 0;

// All rounds, padded with placeholders so we can show TBD slots
let rounds = [[],[],[],[],[]];

// Current viewed match (can be any round)
let viewRound = 0;
let viewMatchIndex = 0;

// voted matches for ACTIVE round
let votedMatchIds = new Set();

// prevent jumping after vote (unless it gets decided)
let keepCurrentMatch = false;

// when a match becomes decided, jump to the NEXT battle in the same round (next undecided after this index)
let jumpAfterDecideFrom = null;

// Rounds: 0=r32, 1=r16, 2=QF, 3=SF, 4=Final
const ROUND_NAMES = ["R32","R16","Quarterfinals","Semifinals","Final"];
const ROUND_COUNTS = [16, 8, 4, 2, 1]; // how many matches per round

function setStatus(msg, cls=""){
  statusLine.className = "small " + cls;
  statusLine.textContent = msg;
}

function updateAuthUI(){
  if (sessionUser){
    userLabel.textContent = sessionUser.email ?? "Signed in";
    btnSignIn.disabled = true;
    btnSignOut.disabled = false;
  } else {
    userLabel.textContent = "Not signed in";
    btnSignIn.disabled = false;
    btnSignOut.disabled = true;
  }
}

function normalizeMatch(m, r, idx){
  if (!m){
    return {
      id: null,
      round: r,
      match_index: idx,
      left_img: null,
      right_img: null,
      winner_img: null,
      winner_side: null,
      __placeholder: true
    };
  }
  return { __placeholder:false, ...m };
}

function matchHasOpponent(m){
  return !!(m?.left_img && m?.right_img);
}

/* =========================
   AUTH
========================= */
btnSignIn.onclick = async () => {
  const email = prompt("Email:");
  if (!email) return;
  const password = prompt("Password:");
  if (!password) return;

  setStatus("Signing in…");
  const { data, error } = await supabase.auth.signInWithPassword({ email, password });
  if (error){
    setStatus(error.message, "warn");
    return;
  }
  sessionUser = data.user;
  updateAuthUI();
  await refreshAll();
};

btnSignOut.onclick = async () => {
  await supabase.auth.signOut();
  sessionUser = null;
  updateAuthUI();
  await refreshAll();
};

/* =========================
   DATA
========================= */
async function detectActiveRound(){
  for (let r=0;r<5;r++){
    const { data } = await supabase
      .from("matches_v2")
      .select("*")
      .eq("round", r)
      .order("match_index");

    if (data?.some(m=>!m.winner_img)) return r;
  }
  return 4;
}

async function loadRoundRaw(r){
  const { data } = await supabase
    .from("matches_v2")
    .select("*")
    .eq("round", r)
    .order("match_index");
  return data ?? [];
}

async function loadAllRounds(){
  const out = [];
  for (let r=0;r<5;r++){
    const raw = await loadRoundRaw(r);
    const map = new Map((raw ?? []).map(m => [m.match_index, m]));
    const padded = [];
    const count = ROUND_COUNTS[r] ?? 0;
    for (let i=0;i<count;i++){
      padded.push(normalizeMatch(map.get(i), r, i));
    }
    out.push(padded);
  }
  return out;
}

/* counts show across accounts even with RLS */
async function loadCounts(matchId){
  const { data, error } = await supabase.rpc("get_match_counts_v2", { p_match_id: matchId });
  if (error) throw error;
  return {
    l: data?.[0]?.left_count ?? 0,
    r: data?.[0]?.right_count ?? 0
  };
}

/* voted matches for user in ACTIVE round only */
async function loadUserVotedMatchIds(userId, round){
  const set = new Set();
  if (!userId) return set;

  const { data, error } = await supabase
    .from("round_votes_v2")
    .select("match_id, round")
    .eq("user_id", userId)
    .eq("round", round);

  if (error) throw error;

  (data ?? []).forEach(row => set.add(row.match_id));
  return set;
}

/* =========================
   RENDER
========================= */
function getViewedMatch(){
  return rounds?.[viewRound]?.[viewMatchIndex] ?? null;
}

function render(){
  roundLabel.textContent = (ROUND_NAMES[activeRound] ?? ("Round " + activeRound)) + " is LIVE";

  const m = getViewedMatch();
  if (!m){
    imgLeft.removeAttribute("src");
    imgRight.removeAttribute("src");
    countLeft.textContent = "0";
    countRight.textContent = "0";
    voteLeft.disabled = true;
    voteRight.disabled = true;
    if (decidedOverlayTop) decidedOverlayTop.style.display = "none";
    if (decidedOverlayBottom) decidedOverlayBottom.style.display = "none";
    return;
  }

  imgLeft.src = m.left_img || "";
  imgRight.src = m.right_img || "";

  // overlays when decided (and only when you are viewing this decided match)
  const decided = !!m.winner_img;
  if (decidedOverlayTop) decidedOverlayTop.style.display = decided ? "flex" : "none";
  if (decidedOverlayBottom) decidedOverlayBottom.style.display = decided ? "flex" : "none";

  const alreadyVotedThisMatch = m.id ? votedMatchIds.has(m.id) : false;

  const canVote =
    !!sessionUser &&
    viewRound === activeRound &&
    !!m.id &&
    !alreadyVotedThisMatch &&
    !m.winner_img &&
    matchHasOpponent(m);

  voteLeft.disabled = !canVote;
  voteRight.disabled = !canVote;

  renderThumbs();
}

function thumbHTML(m){
  const left = m.left_img
    ? `<img class="left" src="${m.left_img}">`
    : `<div class="tbd">TBD</div>`;

  const right = m.right_img
    ? `<img class="right" src="${m.right_img}">`
    : `<div class="tbd">TBD</div>`;

  const decided = m.winner_img ? `<div class="badge">DECIDED</div><div class="dim"></div>` : "";
  const tbdBadge = (!matchHasOpponent(m) && !m.winner_img) ? `<div class="badge">WAITING</div>` : "";

  return `
    ${decided || tbdBadge}
    <div class="thumb-img">
      ${left}
      ${right}
    </div>
  `;
}

function renderThumbs(){
  thumbsEl.innerHTML = "";

  for (let r=0;r<5;r++){
    const line = document.createElement("div");
    line.className = "tier-line";
    thumbsEl.appendChild(line);

    const title = document.createElement("div");
    title.className = "tier-title";
    title.innerHTML = `<b>${ROUND_NAMES[r]}</b><span>${ROUND_COUNTS[r]} matches</span>`;
    thumbsEl.appendChild(title);

    const grid = document.createElement("div");
    grid.className = "thumbs";
    grid.style.marginTop = "0";

    (rounds[r] ?? []).forEach((m, i) => {
      const t = document.createElement("div");
      const isActive = (r === viewRound && i === viewMatchIndex);
      const isDecided = !!m.winner_img;

      t.className = "thumb" + (isActive ? " active" : "") + (isDecided ? " decided" : "");
      t.innerHTML = thumbHTML(m);

      t.onclick = async () => {
        viewRound = r;
        viewMatchIndex = i;
        await refreshCounts();
        render();
        updateStatusLine();
      };

      grid.appendChild(t);
    });

    thumbsEl.appendChild(grid);
  }
}

async function refreshCounts(){
  const m = getViewedMatch();
  if (!m?.id){
    countLeft.textContent = "0";
    countRight.textContent = "0";
    return;
  }
  const c = await loadCounts(m.id);
  countLeft.textContent = c.l;
  countRight.textContent = c.r;
}

function updateStatusLine(){
  if (!sessionUser){
    setStatus("Sign in to vote. (You can vote once per match.)");
    return;
  }

  const m = getViewedMatch();
  if (!m){
    setStatus("No matchup selected.", "warn");
    return;
  }

  if (viewRound !== activeRound){
    setStatus(`Viewing ${ROUND_NAMES[viewRound]}. Voting is only enabled in LIVE round: ${ROUND_NAMES[activeRound]}.`, "warn");
    return;
  }

  if (!m.id){
    setStatus("This slot hasn't been created yet. (Waiting for winners to advance.)", "warn");
    return;
  }

  if (!matchHasOpponent(m)){
    setStatus("Waiting for an opponent (TBD). Voting is locked until both sides exist.", "warn");
    return;
  }

  if (m.winner_img){
    setStatus("WINNER DECIDED. This match is locked.", "warn");
    return;
  }

  if (votedMatchIds.has(m.id)){
    setStatus("You already voted in THIS matchup. You can vote in other matchups.", "warn");
    return;
  }

  setStatus("You can vote once in this matchup.", "ok");
}

/* =========================
   ADVANCE (SELF-HEAL)
========================= */
async function tryAutoAdvanceIfReady(matchId){
  if (!matchId) return false;
  try{
    const { error } = await supabase.rpc("advance_match_v2", { p_match_id: matchId });
    if (error){
      console.warn("advance_match_v2 error:", error);
      setStatus("Advance RPC failed: " + error.message, "warn");
      return false;
    }
    return true;
  } catch(e){
    console.warn("advance_match_v2 crash:", e);
    setStatus("Advance RPC crashed: " + (e?.message ?? e), "warn");
    return false;
  }
}

/* =========================
   HELPERS: JUMP TO NEXT BATTLE
========================= */
function pickNextUnfinishedIndexInRound(r, startAfterIndex){
  const arr = rounds?.[r] ?? [];
  if (!arr.length) return 0;

  // 1) next unfinished AFTER current index
  for (let i = (startAfterIndex + 1); i < arr.length; i++){
    const m = arr[i];
    if (m?.id && !m.winner_img) return i;
  }

  // 2) wrap: first unfinished anywhere
  const first = arr.findIndex(m => m?.id && !m.winner_img);
  return first >= 0 ? first : 0;
}

/* =========================
   VOTE
========================= */
async function castVote(side){
  const m = getViewedMatch();
  if (!m || !sessionUser) return;

  if (viewRound !== activeRound){
    setStatus("Voting is only enabled in the LIVE round.", "warn");
    return;
  }

  if (!m.id){
    setStatus("This match hasn't been created yet.", "warn");
    return;
  }

  if (!matchHasOpponent(m)){
    setStatus("Waiting for an opponent (TBD).", "warn");
    return;
  }

  if (votedMatchIds.has(m.id)){
    setStatus("Already voted in this matchup.", "warn");
    return;
  }

  setStatus("Submitting vote…");

  const { error } = await supabase
    .from("round_votes_v2")
    .insert({
      user_id: sessionUser.id,
      round: activeRound,
      match_id: m.id,
      side
    });

  if (error){
    if (String(error.code) === "23505"){
      votedMatchIds.add(m.id);
      setStatus("Already voted in this matchup (DB enforced).", "warn");
      keepCurrentMatch = true;
      await refreshAll();
      return;
    }
    setStatus("Vote failed: " + error.message, "warn");
    return;
  }

  votedMatchIds.add(m.id);

  // update counts immediately
  let cNow = null;
  try{
    cNow = await loadCounts(m.id);
    countLeft.textContent = cNow.l;
    countRight.textContent = cNow.r;
  } catch(e){
    console.warn("count refresh after vote failed:", e);
  }

  // decide/jump rules:
  // - if it hits 2 votes on either side, we advance and then jump to the NEXT battle (next undecided after this one)
  // - otherwise stay on this battle
  const isNowDecidedByCount = !!(cNow && (cNow.l >= 2 || cNow.r >= 2));

  if (isNowDecidedByCount){
    setStatus("Winner decided — advancing and moving to next battle…", "ok");

    // next-battle jump target (same round, after this index)
    jumpAfterDecideFrom = { round: viewRound, index: viewMatchIndex };

    // DO NOT keep current match
    keepCurrentMatch = false;

    // run advance RPC to write winner_img + propagate winner
    const ok = await tryAutoAdvanceIfReady(m.id);
    if (!ok){
      // even if advance fails, keep you on same match (so you can see what's wrong)
      keepCurrentMatch = true;
      jumpAfterDecideFrom = null;
      setStatus("Vote saved, but advance failed — staying on this match.", "warn");
    }
  } else {
    keepCurrentMatch = true;
    setStatus("Vote submitted.", "ok");
  }

  await refreshAll();
}

voteLeft.onclick=()=>castVote("left");
voteRight.onclick=()=>castVote("right");

/* =========================
   REFRESH
========================= */
async function refreshAll(){
  try{
    const { data: sess, error: sessErr } = await supabase.auth.getSession();
    if (sessErr) throw sessErr;

    sessionUser = sess?.session?.user ?? null;
    updateAuthUI();

    // Remember current selection
    const prev = keepCurrentMatch ? {
      round: viewRound,
      id: getViewedMatch()?.id ?? null,
      idx: viewMatchIndex
    } : null;

    activeRound = await detectActiveRound();
    rounds = await loadAllRounds();
    votedMatchIds = await loadUserVotedMatchIds(sessionUser?.id, activeRound);

    // If we just decided a match, jump to the next battle (next unfinished after that match index)
    if (!prev && jumpAfterDecideFrom && jumpAfterDecideFrom.round === activeRound){
      viewRound = activeRound;
      viewMatchIndex = pickNextUnfinishedIndexInRound(activeRound, jumpAfterDecideFrom.index);
      jumpAfterDecideFrom = null;
      keepCurrentMatch = false;
    }
    else if (!prev){
      // Default view to first unfinished in active round (or first match)
      viewRound = activeRound;
      const firstUnfinished = (rounds[activeRound] ?? []).findIndex(m => m?.id && !m.winner_img);
      viewMatchIndex = firstUnfinished >= 0 ? firstUnfinished : 0;
    } else {
      // Restore previous viewed match
      if (prev.id){
        const idx = (rounds[prev.round] ?? []).findIndex(mm => mm?.id === prev.id);
        if (idx >= 0){
          viewRound = prev.round;
          viewMatchIndex = idx;
        } else {
          viewRound = prev.round;
          viewMatchIndex = Math.min(prev.idx ?? 0, (rounds[prev.round]?.length ?? 1) - 1);
        }
      } else {
        viewRound = prev.round;
        viewMatchIndex = Math.min(prev.idx ?? 0, (rounds[prev.round]?.length ?? 1) - 1);
      }
      keepCurrentMatch = false;
    }

    render();
    await refreshCounts();

    // Self-heal: if a match reached 2 votes but winner_img wasn't written yet, try advancing now
    const vm = getViewedMatch();
    if (vm?.id && !vm.winner_img){
      try{
        const c2 = await loadCounts(vm.id);
        if ((c2.l >= 2 || c2.r >= 2)){
          const advanced = await tryAutoAdvanceIfReady(vm.id);
          if (advanced){
            activeRound = await detectActiveRound();
            rounds = await loadAllRounds();

            const ridx = (rounds[vm.round] ?? []).findIndex(mm => mm?.id === vm.id);
            if (ridx >= 0){
              viewRound = vm.round;
              viewMatchIndex = ridx;
            }
            render();
            await refreshCounts();
          }
        }
      } catch(e){
        console.warn("Self-heal check failed:", e);
      }
    }

    updateStatusLine();
  } catch(e){
    console.error(e);
    setStatus("Load error: " + (e?.message ?? e), "warn");
  }
}

await refreshAll();
</script>

</body>
</html>