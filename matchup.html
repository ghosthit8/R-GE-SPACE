<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space ‚Äî Matchup (v2)</title>

<link rel="preconnect" href="https://tuqvpcevrhciursxrgav.supabase.co">
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
  :root{ --green:#39ff14; --muted:#9eea9e; --border:#153b16; --ink:#e5e5e5; --bg:#000; }
  body{margin:0;background:#000;color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
  .wrap{max-width:980px;margin:16px auto 64px;padding:0 16px}
  .scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
  .btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;cursor:pointer}
  .clock,.badge{border:1px solid var(--border);border-radius:8px;padding:2px 8px}
  .tile{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:rgba(7,7,7,.6);margin-top:16px;position:relative}
  .art{aspect-ratio:4/3;width:100%;height:auto;display:block;object-fit:cover}
  .meta{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-top:1px solid var(--border)}
  .caption{display:block;text-align:center;font-size:12px;color:var(--muted);padding:6px 8px;border-top:1px dashed var(--border)}
  .btn.primary.selected{background:rgba(57,255,20,.22);color:var(--ink);box-shadow:0 0 18px rgba(125,255,98,.35), inset 0 0 12px rgba(57,255,20,.15)}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:14px}
  .bracket{margin-top:20px;border:1px solid var(--border);border-radius:14px;background:rgba(7,7,7,.5);overflow:hidden}
  .bracket-head{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--border)}
  .brow{display:grid;grid-template-columns:auto auto 1fr auto;gap:10px 12px;padding:12px 14px;border-top:1px solid var(--border);align-items:center;cursor:pointer}
  .brow:first-child{border-top:0}
  .bbadge{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:12px}
  .thumb{width:44px;height:44px;border-radius:10px;overflow:hidden;border:1px solid var(--border);background:rgba(0,0,0,.35)}
  .thumb img{width:100%;height:100%;object-fit:cover;display:block}
  .bmeta{display:flex;flex-direction:column;gap:4px;min-width:0}
  .title{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .bscore{font-variant-numeric:tabular-nums;font-size:18px;justify-self:end}
  /* winner overlay (minimal) */
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.92);display:none;align-items:center;justify-content:center;z-index:9999}
  #overlay.show{display:flex}
  #overlayClose{position:absolute;right:14px;top:12px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="scorebar">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <strong>Decision in</strong>
        <span id="clock" class="clock">‚Äî</span>
        <span id="phaseBadge" class="clock">phase: ‚Äî</span>
        <span id="loginBadge" class="badge">checking auth‚Ä¶</span>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">‚è∏Ô∏è Pause</button>
        <button id="btnReset" class="btn">üîÅ Reset</button>
        <a class="btn" href="./winners.html">üèÅ Winners</a>
      </div>
    </div>

    <!-- Current Match -->
    <div class="tile" id="tileA">
      <img id="imgA" class="art" alt="Entry Left"/>
      <div class="caption" id="countA">0 votes</div>
      <div class="meta">
        <span id="labelA">Left</span>
        <button class="btn primary" id="voteA">Vote This</button>
      </div>
    </div>

    <div class="tile" id="tileB">
      <img id="imgB" class="art" alt="Entry Right"/>
      <div class="caption" id="countB">0 votes</div>
      <div class="meta">
        <span id="labelB">Right</span>
        <button class="btn primary" id="voteB">Vote This</button>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="submitBtn" disabled>‚úÖ Submit Vote</button>
    </div>

    <!-- Bracket list -->
    <section class="bracket" id="bracket">
      <div class="bracket-head">
        <div class="title">Bracket</div>
        <label style="display:flex;align-items:center;gap:8px">
          <input id="showDone" type="checkbox" checked>
          <span>Show finished rounds</span>
        </label>
      </div>
      <div id="brows"></div>
    </section>
  </div>

  <!-- Final overlay -->
  <div id="overlay">
    <button id="overlayClose" class="btn">‚úï</button>
    <div style="text-align:center;max-width:80vw">
      <h1>CHAMPION</h1>
      <img id="overlayImg" style="max-width:80vw;max-height:70vh;border:1px solid var(--border);border-radius:12px"/>
      <p id="overlayNote" style="color:var(--muted)"></p>
    </div>
  </div>

<script>
/* ===== CONFIG ===== */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON = "YOUR_PUBLIC_ANON_KEY";
const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer-v2`;

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

/* ===== STATE ===== */
let currentUid = null;
let cycleStart = null;
let periodSec = 100;
let lastCheckpoint = 0; // 0..5
let paused = false;

let activeSlot = 'r32_1'; // switches as rounds advance
let currentStage = 'r32'; // 'r32','r16','qf','sf','final'

/* ===== DOM ===== */
const clockEl = document.getElementById('clock');
const phaseBadge = document.getElementById('phaseBadge');
const loginBadge = document.getElementById('loginBadge');
const voteA = document.getElementById('voteA');
const voteB = document.getElementById('voteB');
const imgA = document.getElementById('imgA');
const imgB = document.getElementById('imgB');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');
const submitBtn = document.getElementById('submitBtn');
const btnPause = document.getElementById('btnPause');
const btnReset = document.getElementById('btnReset');
const brows = document.getElementById('brows');
const showDone = document.getElementById('showDone');
const overlay = document.getElementById('overlay');
const overlayImg = document.getElementById('overlayImg');
const overlayNote = document.getElementById('overlayNote');
document.getElementById('overlayClose').onclick = () => overlay.classList.remove('show');

/* ===== helpers ===== */
const iso=(d)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,'Z');
const stageOf = (slot)=> slot.startsWith('r32')?'r32':slot.startsWith('r16')?'r16':slot.startsWith('qf')?'qf':(slot.startsWith('sf')?'sf':'final');
const stageLevel = (s)=> s==='r32'?1:s==='r16'?2:s==='qf'?3:s==='sf'?4:5;
const slotLevel = (slot)=> stageLevel(stageOf(slot));
function baseForSlot(slot){
  // For v2 we use the *same* base for all slots in the current cycle
  return cycleStart;
}
function slotKey(slot, base){ return slot==='final' ? `${base}::final` : `${base}::${slot}`; }
function seedUrlFromKey(baseISO, suffix){
  const s=encodeURIComponent(`${baseISO}-${suffix}`); return `https://picsum.photos/seed/${s}/1600/1200`;
}

/* keep your 32 images (seeded) */
function r32Pack(baseISO, n){
  return { A: seedUrlFromKey(baseISO, `A${n}`), B: seedUrlFromKey(baseISO, `B${n}`) };
}

/* entrant plumbing (rebuild from winners_v2 colors) */
async function getPairFromWinners(baseISO, leftKey, rightKey, rebuildLeft, rebuildRight){
  const { data } = await supabase.from('winners_v2').select('phase_key,color').in('phase_key', [leftKey, rightKey]);
  const map = Object.fromEntries((data||[]).map(r=>[r.phase_key, String(r.color||'').toLowerCase()]));
  if (!(map[leftKey] && map[rightKey])) return null;
  const L = await rebuildLeft();  const R = await rebuildRight();
  const leftSrc  = (map[leftKey]==='red') ? L.A : L.B;
  const rightSrc = (map[rightKey]==='red') ? R.A : R.B;
  return { A: leftSrc, B: rightSrc };
}

async function packFor(slot){
  const base = baseForSlot(slot);
  if (!base) return null;
  if (slot.startsWith('r32')){
    const n = Number(slot.split('_')[1]); return r32Pack(base, n);
  }
  if (slot.startsWith('r16')){
    const i = Number(slot.split('_')[1]);
    const pair = [i*2-1, i*2];
    const k1 = `${base}::r32_${pair[0]}`, k2 = `${base}::r32_${pair[1]}`;
    const rebuild = (n)=>()=> Promise.resolve(r32Pack(base, n));
    return await getPairFromWinners(base, k1, k2, rebuild(pair[0]), rebuild(pair[1]));
  }
  if (slot.startsWith('qf')){
    const map = {qf1:[1,2], qf2:[3,4], qf3:[5,6], qf4:[7,8]}[slot];
    const k1 = `${base}::r16_${map[0]}`, k2 = `${base}::r16_${map[1]}`;
    const rebuild = (n)=>()=> packFor(`r16_${n}`);
    return await getPairFromWinners(base, k1, k2, rebuild(map[0]), rebuild(map[1]));
  }
  if (slot.startsWith('sf')){
    const map = slot==='sf1' ? ['qf1','qf2'] : ['qf3','qf4'];
    const k1 = `${base}::${map[0]}`, k2 = `${base}::${map[1]}`;
    const rebuild = (s)=>()=> packFor(s);
    return await getPairFromWinners(base, k1, k2, rebuild(map[0]), rebuild(map[1]));
  }
  // final from sf1/sf2
  const k1 = `${base}::sf1`, k2 = `${base}::sf2`;
  const rebuild = (s)=>()=> packFor(s);
  return await getPairFromWinners(base, k1, k2, rebuild('sf1'), rebuild('sf2'));
}

/* votes */
async function countVotes(key){
  const { data } = await supabase.from('phase_votes_v2').select('vote').eq('phase_key', key);
  let r=0,b=0; (data||[]).forEach(v=>{ if(v.vote==='red') r++; else if(v.vote==='blue') b++; });
  return {r,b};
}

/* paint current slot */
async function paintSlot(slot){
  const base = baseForSlot(slot);
  if (!base) return;
  phaseBadge.textContent = `phase: ${base}`;
  const pack = await packFor(slot);
  if (pack){ imgA.src = pack.A; imgB.src = pack.B; } else { imgA.removeAttribute('src'); imgB.removeAttribute('src'); }
  const key = slotKey(slot, base);
  const {r,b} = await countVotes(key);
  countA.textContent = `${r} vote${r===1?'':'s'}`;
  countB.textContent = `${b} vote${b===1?'':'s'}`;
}

/* bracket render (compact) */
async function renderBracket(){
  const base = cycleStart;
  if (!base){ brows.innerHTML=''; return; }
  const order = [
    'r32_1','r32_2','r32_3','r32_4','r32_5','r32_6','r32_7','r32_8',
    'r32_9','r32_10','r32_11','r32_12','r32_13','r32_14','r32_15','r32_16',
    'r16_1','r16_2','r16_3','r16_4','r16_5','r16_6','r16_7','r16_8',
    'qf1','qf2','qf3','qf4','sf1','sf2','final'
  ];
  const blocks = await Promise.all(order.map(async s=>{
    const p = await packFor(s);
    const key = slotKey(s, base);
    const {r,b} = await countVotes(key).catch(()=>({r:0,b:0}));
    return `
      <div class="brow" data-slot="${s}">
        <div class="bbadge">${stageOf(s).toUpperCase()}</div>
        <div style="display:flex;gap:8px">
          <div class="thumb">${p?.A ? `<img src="${p.A}" alt="">` : ''}</div>
          <div class="thumb">${p?.B ? `<img src="${p.B}" alt="">` : ''}</div>
        </div>
        <div class="bmeta"><div class="title">${s}</div></div>
        <div class="bscore">${r} - ${b}</div>
      </div>`;
  }));
  brows.innerHTML = blocks.join('');
  brows.querySelectorAll('.brow').forEach(row=>{
    row.addEventListener('click', async ()=>{
      activeSlot = row.dataset.slot;
      await paintSlot(activeSlot);
    });
  });
}

/* auth badge */
async function setAuth(){
  const { data:{session} } = await supabase.auth.getSession();
  currentUid = session?.user?.id || null;
  loginBadge.textContent = currentUid ? 'logged in' : 'not logged in';
}

/* edge polling */
async function fetchState(){
  const res = await fetch(EDGE_URL, { headers: { 'apikey': SUPABASE_ANON, 'Authorization': `Bearer ${SUPABASE_ANON}` }});
  const { state } = await res.json();
  cycleStart = state.cycle_start;
  periodSec = state.period_sec;
  lastCheckpoint = state.last_checkpoint;
  paused = state.paused;

  // determine stage from checkpoint (1..5)
  currentStage = ['r32','r16','qf','sf','final'][Math.max(0, lastCheckpoint)-1] || 'r32';
  clockEl.textContent = String(state.remaining_sec);
}

/* controls */
btnPause.onclick = async ()=>{
  await fetch(EDGE_URL, { method:'POST', headers:{'Content-Type':'application/json','apikey':SUPABASE_ANON,'Authorization':`Bearer ${SUPABASE_ANON}`}, body: JSON.stringify({action: paused?'resume':'pause'}) });
  await fetchState();
};
btnReset.onclick = async ()=>{
  await fetch(EDGE_URL, { method:'POST', headers:{'Content-Type':'application/json','apikey':SUPABASE_ANON,'Authorization':`Bearer ${SUPABASE_ANON}`}, body: JSON.stringify({action:'reset'}) });
  await fetchState(); await paintSlot(activeSlot); await renderBracket();
};

/* voting */
let chosen = null;
function lockUI(){
  const locked = slotLevel(activeSlot) !== stageLevel(currentStage);
  [voteA, voteB, submitBtn].forEach(b=> b.disabled = locked || !currentUid);
}
voteA.onclick=()=>{ chosen='red'; voteA.classList.add('selected'); voteB.classList.remove('selected'); submitBtn.disabled=!currentUid; };
voteB.onclick=()=>{ chosen='blue'; voteB.classList.add('selected'); voteA.classList.remove('selected'); submitBtn.disabled=!currentUid; };
submitBtn.onclick=async ()=>{
  if (!chosen) return;
  if (!currentUid) return alert('Log in to vote');
  const key = slotKey(activeSlot, baseForSlot(activeSlot));
  await supabase.from('phase_votes_v2').upsert({ phase_key: key, user_id: currentUid, vote: chosen }, { onConflict:'phase_key,user_id' });
  await paintSlot(activeSlot);
  submitBtn.textContent='‚úî Voted'; submitBtn.disabled=true;
};

/* realtime bumps */
supabase.channel('v2-votes')
  .on('postgres_changes',{event:'*',schema:'public',table:'phase_votes_v2'}, async ()=>{
    await paintSlot(activeSlot);
  }).subscribe();

supabase.channel('v2-winners')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners_v2'}, (payload)=>{
    const pk = payload?.new?.phase_key || '';
    if (pk.endsWith('::final') && pk.startsWith(cycleStart)){
      const color = (payload?.new?.color||'').toLowerCase();
      overlayNote.textContent = color === 'red' ? 'Left side triumphs.' : 'Right side triumphs.';
      overlayImg.src = color==='red' ? imgA.src : imgB.src;
      overlay.classList.add('show');
    }
  }).subscribe();

/* boot */
(async ()=>{
  await setAuth();
  supabase.auth.onAuthStateChange((_evt, session)=>{ currentUid=session?.user?.id || null; loginBadge.textContent = currentUid ? 'logged in' : 'not logged in'; lockUI(); });

  await fetchState();
  lockUI();
  await paintSlot(activeSlot);
  await renderBracket();

  // light loop just for clock/state freshness
  const tick = async ()=>{
    try{ await fetchState(); lockUI(); }catch{}
    setTimeout(tick, 1000);
  };
  tick();
})();
</script>
<!-- ================== RAGE DEBUGGER v2 (fixed button) ================== -->
<script>
(function () {
  const MAX_LINES = 2000;
  const EDGE_MATCH = /\/functions\/v1\/global-timer/;

  // --- create floating button OUTSIDE the hidden panel ---
  const floatBtn = document.createElement('button');
  floatBtn.id = 'dbgFloatingBtn';
  floatBtn.textContent = 'üêõ Debug';
  floatBtn.style.cssText = `
    position: fixed; right: 8px; bottom: 8px;
    z-index: 2147483647; background:#000; color:#0f0;
    border:1px solid #0f0; border-radius:6px; padding:6px 10px;
    font: 12px/1.1 monospace; cursor:pointer;
  `;
  document.body.appendChild(floatBtn);

  // --- panel wrapper (starts hidden) ---
  const wrap = document.createElement('div');
  wrap.id = 'dbg';
  wrap.style.cssText = `
    position: fixed; right: 0; bottom: 0; left: 0;
    background: rgba(0,0,0,.92); color:#9f9; font: 12px/1.4 monospace;
    z-index: 2147483646; max-height: 45vh; display:none; box-shadow:0 -2px 12px rgba(0,0,0,.6);
  `;

  const bar = document.createElement('div');
  bar.style.cssText = 'display:flex; align-items:center; gap:6px; padding:6px; position:sticky; top:0; background:#111;';
  bar.innerHTML = `
    <span style="color:#6f6">Rage Debug</span>
    <label>Filter:
      <select id="dbgFilter">
        <option value="">All</option>
        <option>NET</option><option>EDGE</option><option>TIMER</option><option>CLOCK</option>
        <option>STAGE</option><option>UI</option><option>IMG</option><option>OBS</option>
        <option>ERR</option><option>WARN</option><option>LOG</option>
      </select>
    </label>
    <label><input id="dbgRecord" type="checkbox" checked> Record</label>
    <button id="dbgCopy">Copy</button>
    <button id="dbgDownload">Download</button>
    <button id="dbgClear">Clear</button>
    <span style="margin-left:auto"></span>
    <button id="dbgClose">‚úï</button>
  `;

  const list = document.createElement('div');
  list.style.cssText = 'padding:6px 8px; white-space:pre-wrap; overflow:auto; max-height:calc(45vh - 42px);';

  wrap.appendChild(bar); wrap.appendChild(list);
  document.body.appendChild(wrap);

  // button wiring
  function showDbg(v){ wrap.style.display = v ? 'block' : 'none'; }
  floatBtn.onclick = () => showDbg(wrap.style.display === 'none');
  bar.querySelector('#dbgClose').onclick = () => showDbg(false);

  // controls
  const filterSel  = bar.querySelector('#dbgFilter');
  const recordChk  = bar.querySelector('#dbgRecord');
  bar.querySelector('#dbgClear').onclick = () => { buffer = []; render(); };
  bar.querySelector('#dbgCopy').onclick = () => navigator.clipboard.writeText(buffer.map(r => r.line).join("\n"));
  bar.querySelector('#dbgDownload').onclick = () => {
    const blob = new Blob([buffer.map(r => r.line).join("\n")], {type:'text/plain'});
    const a = Object.assign(document.createElement('a'), {href: URL.createObjectURL(blob), download: `rage_debug_${Date.now()}.log`});
    a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  };

  // ring buffer + rendering
  let buffer = [];
  function push(kind, msg, extra) {
    if (!recordChk.checked) return;
    const ts = new Date().toLocaleTimeString();
    const line = `[${ts}] ${kind}: ${msg}`;
    buffer.push({kind, line, extra});
    if (buffer.length > MAX_LINES) buffer.shift();
    const f = filterSel.value;
    if (!f || f === kind) addLine({kind, line});
  }
  function addLine(r){
    const div = document.createElement('div');
    div.textContent = r.line;
    if (r.kind === 'ERR') div.style.color = '#f88';
    else if (r.kind === 'WARN') div.style.color = '#ff8';
    else if (r.kind === 'EDGE') div.style.color = '#8ff';
    else if (r.kind === 'NET')  div.style.color = '#8cf';
    else if (r.kind === 'TIMER' || r.kind === 'CLOCK') div.style.color = '#6f6';
    list.appendChild(div); list.scrollTop = list.scrollHeight;
  }
  function render(){
    list.innerHTML = '';
    const f = filterSel.value;
    for (const r of buffer) if (!f || f === r.kind) addLine(r);
  }
  filterSel.onchange = render;

  // console hooks
  const _log = console.log, _warn = console.warn, _err = console.error;
  console.log = (...a) => { try{push('LOG', a.map(String).join(' '));}catch{} _log.apply(console,a); };
  console.warn= (...a) => { try{push('WARN',a.map(String).join(' '));}catch{} _warn.apply(console,a);};
  console.error=(...a) => { try{push('ERR', a.map(String).join(' '));}catch{} _err.apply(console,a);};

  window.addEventListener('error', (e)=> push('ERR', `${e.message} @ ${e.filename}:${e.lineno}`));
  window.addEventListener('unhandledrejection', (e)=> push('ERR', (e.reason && e.reason.message) || String(e.reason)));

  // visibility & UI observers
  document.addEventListener('visibilitychange', () => push('OBS', `visibility: ${document.visibilityState}`));
  const q = (id) => document.getElementById(id);

  function observeText(id, kind) {
    const el = q(id); if (!el) return;
    let last = el.textContent;
    const mo = new MutationObserver(() => {
      if (el.textContent !== last) {
        last = el.textContent;
        push(kind, `${id} ‚Üí ${last}`);
      }
    });
    mo.observe(el, {childList:true, characterData:true, subtree:true});
  }
  observeText('phaseKey', 'STAGE');
  observeText('state', 'STAGE');

  (function watchClock(){
    const el = q('clock'); if (!el) return;
    let last = el.textContent, lastAt = performance.now();
    const mo = new MutationObserver(() => {
      const now = performance.now();
      if (el.textContent !== last) {
        const dt = ((now - lastAt)/1000).toFixed(2);
        push('CLOCK', `clock ${last} ‚Üí ${el.textContent} (Œîdom ${dt}s)`);
        last = el.textContent; lastAt = now;
      }
    });
    mo.observe(el, {childList:true, characterData:true, subtree:true});
  })();

  // fetch tracer
  const _fetch = window.fetch.bind(window);
  window.fetch = async function(url, opts = {}) {
    const start = performance.now();
    const method = (opts && opts.method) || 'GET';
    const tag = EDGE_MATCH.test(String(url)) ? 'EDGE' : 'NET';
    push(tag, `${method} ${url}`);
    try {
      const res = await _fetch(url, opts);
      const ms = (performance.now() - start).toFixed(0);
      push(tag, `${method} ${url} ‚Üí ${res.status} (${ms}ms)`);
      return res;
    } catch (e) {
      const ms = (performance.now() - start).toFixed(0);
      push(tag, `${method} ${url} ‚úñ ${e.name||'error'} (${ms}ms)`);
      throw e;
    }
  };

  // timers & rAF
  const _setInterval = window.setInterval, _clearInterval = window.clearInterval;
  const _setTimeout  = window.setTimeout,  _clearTimeout  = window.clearTimeout;
  const _raf = window.requestAnimationFrame, _caf = window.cancelAnimationFrame;

  const timers = new Map();
  window.setInterval = function(fn, ms, ...rest){
    const id = _setInterval(function(){ const t0=performance.now(); try{fn()}finally{push('TIMER',`interval ${id} tick ${ (performance.now()-t0).toFixed(1)}ms`)} }, ms, ...rest);
    timers.set(id, {type:'interval', ms}); push('TIMER', `interval ${id} set @ ${ms}ms`); return id;
  };
  window.clearInterval = function(id){ if(timers.has(id)) push('TIMER', `interval ${id} cleared`); return _clearInterval(id); };
  window.setTimeout  = function(fn, ms, ...rest){
    const id = _setTimeout(function(){ const t0=performance.now(); try{fn()}finally{push('TIMER',`timeout ${id} run ${ (performance.now()-t0).toFixed(1)}ms`)} }, ms, ...rest);
    timers.set(id, {type:'timeout', ms}); push('TIMER', `timeout ${id} set @ ${ms}ms`); return id;
  };
  window.clearTimeout = function(id){ if(timers.has(id)) push('TIMER', `timeout ${id} cleared`); return _clearTimeout(id); };
  window.requestAnimationFrame = function(fn){
    return _raf(function(t){ const t0=performance.now(); try{fn(t)}finally{push('TIMER',`rAF ${(performance.now()-t0).toFixed(1)}ms`)} });
  };
  window.cancelAnimationFrame = function(id){ _caf(id); };

  // image load tracing
  function hookImg(img){
    if (!img || img.__dbgHooked) return;
    img.__dbgHooked = true;
    img.addEventListener('load',  ()=> push('IMG', `loaded ${img.id||''} ${img.src}`));
    img.addEventListener('error', ()=> push('IMG', `ERROR  ${img.id||''} ${img.src}`));
  }
  Array.from(document.images).forEach(hookImg);
  const imgObs = new MutationObserver((ms)=>{
    for (const m of ms) for (const n of m.addedNodes) {
      if (n.tagName === 'IMG') hookImg(n);
      else if (n.querySelectorAll) n.querySelectorAll('img').forEach(hookImg);
    }
  });
  imgObs.observe(document.documentElement, {childList:true, subtree:true});

  // bracket observer
  const brows = document.getElementById('brows');
  if (brows) {
    const mo = new MutationObserver((ms)=>{
      let adds = 0, rems = 0;
      for (const m of ms) { adds += m.addedNodes.length; rems += m.removedNodes.length; }
      push('OBS', `bracket changed: +${adds} -${rems} (children=${brows.children.length})`);
    });
    mo.observe(brows, {childList:true, subtree:false});
  }

  // public helpers
  window.RageDebug = {
    log: (k, m) => push(k||'LOG', m||''),
    markStage: (stage, base) => push('STAGE', `mark stage=${stage} base=${base||''}`),
    markPaint: (slot, base) => push('UI', `paint slot=${slot} base=${base||''}`),
    markCounts: (slot, r, b) => push('UI', `counts slot=${slot} r=${r} b=${b}`),
  };

  // small banner
  (console.log||(()=>{}))('Debugger ready');
})();
</script>
<!-- ================== /RAGE DEBUGGER v2 ================== -->
</body>
</html>
