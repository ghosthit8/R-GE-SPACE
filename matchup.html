<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space — Matchup</title>

<link rel="preconnect" href="https://tuqvpcevrhciursxrgav.supabase.co">
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>

<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;background:#0b0d12;color:#e7e9ee;margin:0}
  header{display:flex;gap:.75rem;align-items:center;padding:.75rem 1rem;border-bottom:1px solid #1b2130}
  .pill{padding:.35rem .6rem;border:1px solid #2a3347;border-radius:999px;background:#121826}
  #debugPanel{display:none;padding:.5rem 1rem;border-top:1px solid #1b2130;font:12px/1.4 ui-monospace,Consolas,monospace;white-space:pre-wrap;max-height:40vh;overflow:auto;background:#0e111a}
  #brows{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:12px}
  .brow{border:1px solid #22304a;border-radius:12px;overflow:hidden;background:#111827}
  .brow.done{opacity:.35;filter:saturate(.4)}
  .brow header{padding:.5rem .75rem;border-bottom:1px solid #1c2538}
  .brow img{display:block;width:100%;height:auto}
  .hide{display:none!important}
</style>
</head>

<body>
  <header>
    <strong>Rage Space</strong>
    <span class="pill">clock: <span id="clock">--</span></span>
    <label class="pill" title="Hide finished rows">
      <input id="showDone" type="checkbox" checked> hide done
    </label>
    <button id="debugBtn" class="pill" type="button">Debug</button>
  </header>

  <section id="brows" aria-live="polite"></section>
  <section id="debugPanel"></section>

  <!-- Your app code -->
  <script type="module">
    /******** Core config ********/
    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIs...CI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
    const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer`; // “phase end” oracle

    const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /******** DOM ********/
    const clockEl = document.getElementById('clock');
    const brows = document.getElementById('brows');
    const showDone = document.getElementById('showDone');
    const debugBtn = document.getElementById('debugBtn');
    const debugPanel = document.getElementById('debugPanel');

    const log = (...a) => {
      const line = `[${new Date().toLocaleTimeString()}] ${a.join(" ")}`;
      console.log(line);
      debugPanel.textContent += line + "\n";
    };

    debugBtn.addEventListener('click', () => {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });

    /******** Safe, single poller ********/
    function makePoller(fn, {
      minMs = 1200,
      maxMs = 15000,
      stepMs = 600,
      immediate = true
    } = {}) {
      let ms = minMs;
      let t = null;
      let inflight = false;
      let aborted = false;
      let ctrl = null;

      const tick = async () => {
        if (aborted) return;
        if (document.hidden || !navigator.onLine) return schedule(); // skip while hidden/offline
        if (inflight) return; // never overlap
        inflight = true;
        ctrl = new AbortController();
        try {
          const ok = await fn({signal: ctrl.signal});
          ms = ok ? minMs : Math.min(maxMs, ms + stepMs); // backoff on “not ok”
        } catch (e) {
          if (e.name !== 'AbortError') {
            log('poll error:', e.message || e);
            ms = Math.min(maxMs, ms + stepMs * 2);
          }
        } finally {
          inflight = false;
          schedule();
        }
      };

      const schedule = () => { clearTimeout(t); t = setTimeout(tick, ms); };
      const start = () => { if (immediate) tick(); else schedule(); };
      const stop = () => { aborted = true; clearTimeout(t); if (ctrl) ctrl.abort(); };

      // pause/resume on visibility
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) { if (ctrl) ctrl.abort(); }
        else schedule();
      });
      window.addEventListener('online', schedule);
      window.addEventListener('offline', () => { if (ctrl) ctrl.abort(); });

      return { start, stop };
    }

    /******** Data layer ********/
    let currentPhaseKey = null;
    let serverPhaseEndISO = null;

    async function getServerPhaseInfo({signal}) {
      const res = await fetch(EDGE_URL, { signal });
      if (!res.ok) return { ok:false };
      const text = await res.text(); // e.g., "2025-10-16T23:58:40Z"
      serverPhaseEndISO = text.trim();
      clockEl.textContent = new Date(serverPhaseEndISO).toLocaleTimeString();
      return { ok:true };
    }

    // Batch winners in ONE query using `in` (instead of 16 requests)
    async function getWinnersBatch(phaseKeys, {signal}) {
      if (!phaseKeys.length) return { ok:true };
      const inList = phaseKeys.map(k => `"${k}"`).join(',');
      const url = `${SUPABASE_URL}/rest/v1/winners?select=color,phase_key&phase_key=in.(${encodeURIComponent(inList)})`;
      const res = await fetch(url, {
        headers: { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${SUPABASE_ANON_KEY}` },
        signal
      });
      if (!res.ok) return { ok:false };
      const rows = await res.json();
      // paint winners onto rows (id = `row-${slot}`)
      const byKey = new Map(rows.map(r => [r.phase_key, r.color]));
      document.querySelectorAll('[data-phase-key]').forEach(el => {
        const k = el.getAttribute('data-phase-key');
        const color = byKey.get(k);
        if (color) {
          el.dataset.winner = color;
          el.classList.add('done');
        }
      });
      return { ok:true };
    }

    // Single, guarded phase_votes poll (no overlaps)
    let lastPhaseCountAt = 0;
    async function pollPhaseVotes({signal}) {
      // limit to once per second regardless of backoff schedule guard
      const now = performance.now();
      if (now - lastPhaseCountAt < 1000) return true;
      lastPhaseCountAt = now;

      const url = `${SUPABASE_URL}/rest/v1/phase_votes?select=vote`;
      const res = await fetch(url, {
        headers: { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${SUPABASE_ANON_KEY}`, Prefer: "count=exact" },
        signal
      });
      if (!res.ok) return false;

      // (Optional) if you just need the tally, you could switch to:
      //   select=vote,count:count().eq.vote.true  (or a view)
      // to reduce payload size.

      // noop: your UI likely listens elsewhere; we log to show it worked
      log('phase_votes OK');
      return true;
    }

    /******** Rendering ********/
    // IMPORTANT: guard image src reassignments (this eliminates the duplicate Picsum loads)
    function ensureImg(el, src) {
      if (el.getAttribute('src') !== src) {
        el.setAttribute('src', src);
      }
    }

    // Example renderer (replace with your real bracket render)
    function renderBracket(phaseKey) {
      currentPhaseKey = phaseKey;
      const rows = Array.from({length: 32}, (_, i) => ({
        slot: i+1,
        phase_key: `${phaseKey}::r32_${i+1}`,
        imgA: `https://picsum.photos/id/${10 + (i%16)*1}/1600/1200?v=2025-10-16-04`,
        imgB: `https://picsum.photos/id/${11 + (i%16)*1}/1600/1200?v=2025-10-16-04`,
      }));
      brows.innerHTML = ""; // (if you virtualize, keep nodes and patch instead)
      for (const r of rows) {
        const card = document.createElement('article');
        card.className = 'brow';
        card.dataset.phaseKey = r.phase_key;

        const h = document.createElement('header');
        h.textContent = r.phase_key;
        card.appendChild(h);

        const a = document.createElement('img');
        const b = document.createElement('img');
        // guarded assignments:
        ensureImg(a, r.imgA);
        ensureImg(b, r.imgB);
        card.append(a, b);
        brows.appendChild(card);
      }
      applyShowDone(); // respect toggle after rerender
    }

    /******** Hide “done” rows toggle ********/
    function applyShowDone(){
      const hide = showDone.checked;
      brows.querySelectorAll('.brow').forEach(n => {
        if (hide && n.classList.contains('done')) n.classList.add('hide');
        else n.classList.remove('hide');
      });
    }
    showDone.addEventListener('change', applyShowDone);

    /******** Boot ********/
    // One timer to get phase info
    const phaseInfoPoller = makePoller(getServerPhaseInfo, { minMs: 3000 });
    // One timer for votes
    const votesPoller = makePoller(pollPhaseVotes, { minMs: 1200 });

    // When phase changes, re-render and batch query winners once (no storms)
    let lastPhaseRendered = null;
    async function watchPhaseChangeLoop(){
      // very light loop driven by the server phase end string
      const prev = serverPhaseEndISO;
      await getServerPhaseInfo({signal: new AbortController().signal});
      if (serverPhaseEndISO && serverPhaseEndISO !== prev) {
        renderBracket(serverPhaseEndISO); // use ISO as key seed
        // Collect all current phase keys and fetch winners in one go
        const keys = Array.from(brows.querySelectorAll('[data-phase-key]')).map(n => n.dataset.phaseKey);
        await getWinnersBatch(keys, {signal: new AbortController().signal});
        lastPhaseRendered = serverPhaseEndISO;
        log('Phase advanced → re-rendered + winners batched');
      }
      setTimeout(watchPhaseChangeLoop, 2000);
    }

    // Start
    renderBracket("boot");
    phaseInfoPoller.start();
    votesPoller.start();
    watchPhaseChangeLoop();

    // Safety: kill timers on unload
    window.addEventListener('beforeunload', () => {
      phaseInfoPoller.stop();
      votesPoller.stop();
    });
  </script>
</body>
</html>