<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space ‚Äî Matchup</title>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
:root{ --green:#39ff14; --green-bright:#7dff62; --bg:#000; --ink:#e5e5e5; --card:#0b0b0b; --border:#153b16; --muted:#8aff8a; --maxw:980px; --danger:#ff3b3b; }
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:var(--maxw);margin:16px auto 64px;padding:0 16px}

/* top bar */
.scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
.btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;cursor:pointer;text-decoration:none;display:inline-block;text-align:center}
.btn:hover{box-shadow:0 0 12px rgba(57,255,20,.18)}
.btn:disabled{opacity:.45;cursor:not-allowed;box-shadow:none}
.tiny{display:flex;gap:8px;align-items:center;font-variant-numeric:tabular-nums;font-size:12px;color:var(--muted)}
.clock{font-weight:700;border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge{border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge.warn{border-color:#3b1616;color:#ff6b6b}
.badge.ok{border-color:#153b16;color:#8aff8a}

/* current match tiles */
.tile{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:rgba(7,7,7,.6);margin-top:16px;position:relative}
.tile.decided::after{
  content:"DECIDED";
  position:absolute; bottom:10px; left:10px;
  background:rgba(0,0,0,.6);
  border:1px solid var(--danger); color:#ff6b6b;
  font-weight:700; letter-spacing:2px; font-size:12px;
  padding:4px 8px; border-radius:8px; pointer-events:none;
}

/* Fullscreen control on each image */
.artbox{position:relative}
.art{aspect-ratio:4/3;width:100%;height:auto;display:block;object-fit:cover}
.fsbtn{
  position:absolute; top:8px; right:8px;
  background:rgba(0,0,0,.6); color:var(--green);
  border:1px solid var(--green); border-radius:8px;
  padding:4px 8px; cursor:pointer; font-size:14px; line-height:1;
}

/* fullscreen overlay */
#fsOverlay{
  position:fixed; inset:0; display:none;
  background:rgba(0,0,0,.95);
  align-items:center; justify-content:center;
  z-index:10000;
}
#fsOverlay.show{display:flex}
#fsImage{
  max-width:95%; max-height:95%;
  box-shadow:0 0 40px rgba(57,255,20,.25);
  border:1px solid var(--green); border-radius:12px;
}
#fsClose{
  position:absolute; top:12px; right:14px; z-index:1;
  border:1px solid var(--green); background:rgba(0,0,0,.6); color:var(--green);
  border-radius:8px; padding:4px 10px; cursor:pointer; font-size:16px;
}

.caption{display:block;text-align:center;font-size:12px;color:var(--muted);padding:6px 8px;border-top:1px dashed var(--border)}
.meta{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-top:1px solid var(--border)}
.btn.primary.selected{background:rgba(57,255,20,.22);color:var(--ink);box-shadow:0 0 18px rgba(125,255,98,.35), inset 0 0 12px rgba(57,255,20,.15)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:14px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071c07;color:var(--green);border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:none;box-shadow:0 0 18px rgba(57,255,20,.18);z-index:50}
.toast.show{display:block}

/* ===== Winner Overlay (art clean, frame, typewriter) ===== */
#overlay{
  position:fixed; inset:0; display:none;
  background:rgba(0,0,0,.92);
  align-items:center; justify-content:center;
  z-index:9999; overflow:hidden;
}
#overlay.show{display:flex}
#confetti{position:absolute; inset:0; pointer-events:none; z-index:3}

/* stage + art */
.overlay-bg{position:absolute; inset:0; overflow:hidden}
.overlay-stage{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:2}
.art-wrap{position:relative; display:inline-block; max-width:92vw; max-height:78vh}
.art-wrap img{max-width:100%; max-height:100%; object-fit:contain; display:block}

/* GLITCHY SCANLINE FRAME (around the image, not over it) */
.scanline-frame{ --frame:28px; pointer-events:none; position:absolute; inset:0; }
.scanline-frame .band{
  position:absolute; background:
    repeating-linear-gradient(to right,
      rgba(57,255,20,.38) 0 2px, transparent 2px 4px),
    linear-gradient(90deg, rgba(0,0,0,.35), rgba(0,0,0,.35));
  filter: drop-shadow(0 0 8px rgba(57,255,20,.35));
  animation: glitchShift 1.2s steps(6,end) infinite, flicker 2.6s steps(20,end) infinite;
}
.scanline-frame .top{   left:calc(-1*var(--frame)); right:calc(-1*var(--frame)); top:calc(-1*var(--frame)); height:var(--frame); }
.scanline-frame .bottom{left:calc(-1*var(--frame)); right:calc(-1*var(--frame)); bottom:calc(-1*var(--frame)); height:var(--frame); }
.scanline-frame .left{  top:calc(-1*var(--frame)); bottom:calc(-1*var(--frame)); left:calc(-1*var(--frame)); width:var(--frame); background:
    repeating-linear-gradient(to bottom,
      rgba(57,255,20,.38) 0 2px, transparent 2px 4px),
    linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.35)); }
.scanline-frame .right{ top:calc(-1*var(--frame)); bottom:calc(-1*var(--frame)); right:calc(-1*var(--frame)); width:var(--frame); background:
    repeating-linear-gradient(to bottom,
      rgba(57,255,20,.38) 0 2px, transparent 2px 4px),
    linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.35)); }

@keyframes glitchShift{
  0%{ background-position:0 0, 0 0 }
  50%{ background-position:12px 0, 0 0 }
  100%{ background-position:0 0, 0 0 }
}
@keyframes flicker{
  0%,100%{ opacity:1 }
  5%{ opacity:.75 }
  10%{ opacity:.9 }
  15%{ opacity:.6 }
  22%{ opacity:.95 }
  35%{ opacity:.7 }
  55%{ opacity:1 }
}

/* ambient layers BEHIND image */
.scanlines-behind{position:absolute; inset:0; z-index:1; background:repeating-linear-gradient(to bottom, rgba(0,0,0,.25) 0, rgba(0,0,0,.25) 2px, transparent 3px, transparent 4px)}
.vignette{position:absolute; inset:-10%; z-index:1; background:radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,.6) 100%)}

/* champion card pinned to bottom */
.overlay-card{
  position:absolute; left:50%; bottom:24px; transform:translateX(-50%);
  max-width:min(820px,92vw);
  border:1px solid var(--green); background:rgba(7,7,7,.72);
  border-radius:18px; padding:22px 18px;
  box-shadow:0 0 40px rgba(57,255,20,.25);
  text-align:center; z-index:4;
}
.overlay-card h1{margin:0 8px 6px; letter-spacing:2px; font-size:clamp(28px,6vw,54px); text-transform:uppercase}
.overlay-card .sub{color:var(--muted); margin:0 8px 8px; font-size:clamp(12px,2.4vw,14px); min-height:1.4em}
.overlay-card .motto{color:var(--green-bright); font-weight:700; letter-spacing:.5px; min-height:1.4em}

/* typewriter look + caret */
.typewriter-text{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  letter-spacing: 0;
  line-height: 1.35;
}
.type-caret{ border-right:2px solid var(--green); animation: caretBlink .9s steps(1,end) infinite; }
@keyframes caretBlink{ 50%{ border-right-color:transparent } }

#overlayClose{
  position:absolute; right:14px; top:12px; z-index:5;
  border:1px solid var(--green); background:rgba(0,0,0,.6); color:var(--green);
  border-radius:10px; padding:6px 10px; cursor:pointer
}

/* BRACKET under the current match */
.bracket{margin-top:20px; border:1px solid var(--border); border-radius:14px; background:rgba(7,7,7,.5); overflow:hidden}
.bracket-head{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--border)}
.bracket-title{font-weight:700; font-size:18px}
.switch{display:flex; align-items:center; gap:8px; color:var(--muted); font-size:13px}

/* compact rows (no expand) */
.brow{position:relative; display:grid; grid-template-columns:auto auto 1fr auto; gap:10px 12px; padding:12px 14px; border-top:1px solid var(--border); cursor:pointer; align-items:center}
.brow:first-child{border-top:0}
.brow.active{outline:2px solid var(--danger); outline-offset:-2px; background:rgba(255,59,59,.07)}
.brow.decided::after{
  content:"DECIDED";
  position:absolute; right:14px; top:50%; transform:translateY(-50%);
  font-weight:900; letter-spacing:2px; border:2px solid var(--danger);
  color:#ff6b6b; padding:2px 10px; border-radius:10px; opacity:.95; pointer-events:none;
}
.brow.decided .bline, .brow.decided .bpill, .brow.decided .title{color:#7a7a7a}
.brow.decided .bscore{opacity:.7}

.thumb2{display:flex; gap:8px}
.thumb{width:44px;height:44px;border-radius:10px;overflow:hidden;border:1px solid var(--border);background:rgba(0,0,0,.35)}
.thumb img{width:100%;height:100%;object-fit:cover;display:block}
.bmeta{display:flex; flex-direction:column; gap:4px; min-width:0}
.bline{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
.bbadge{border:1px solid var(--border); border-radius:999px; padding:2px 8px; font-size:12px}
.bpill{color:var(--muted); font-size:13px}
.bscore{font-variant-numeric:tabular-nums; font-size:18px; justify-self:end}
.title{font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
.small{font-size:12px; color:var(--muted)}
.tabs{display:none}
</style>
</head>
<body>
  <div class="wrap">
    <div class="scorebar">
      <div class="tiny">
        <strong>Decision in</strong>
        <span id="clock" class="clock">Sync‚Ä¶</span>
        <span id="state" class="clock">‚Äî</span>
        <span id="phaseKey" class="clock">phase: ‚Äî</span>
        <span id="loginBadge" class="badge">checking auth‚Ä¶</span>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">‚è∏Ô∏è Pause</button>
        <a class="btn" href="./winners.html">üèÅ Winners</a>
      </div>
    </div>

    <!-- Current Match -->
    <div class="tile" id="tileA" data-color="red">
      <div class="artbox">
        <img id="imgA" class="art" alt="Entry Left"/>
        <button class="fsbtn" data-target="imgA" title="View fullscreen">‚õ∂</button>
      </div>
      <div class="caption" id="countA">0 votes</div>
      <div class="meta">
        <span id="labelA">Left</span>
        <button class="btn primary" id="voteA">Vote This</button>
      </div>
    </div>

    <div class="tile" id="tileB" data-color="blue">
      <div class="artbox">
        <img id="imgB" class="art" alt="Entry Right"/>
        <button class="fsbtn" data-target="imgB" title="View fullscreen">‚õ∂</button>
      </div>
      <div class="caption" id="countB">0 votes</div>
      <div class="meta">
        <span id="labelB">Right</span>
        <button class="btn primary" id="voteB">Vote This</button>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="submitBtn" disabled>‚úÖ Submit Vote</button>
    </div>

    <!-- Bracket list -->
    <section class="bracket" id="bracket">
      <div class="bracket-head">
        <div class="bracket-title">Bracket</div>
        <label class="switch">
          <input id="showDone" type="checkbox" />
          <span>Show finished rounds</span>
        </label>
      </div>
      <div id="brows"></div>
    </section>
  </div>

  <div id="toast" class="toast"></div>

  <!-- FINAL OVERLAY -->
  <div id="overlay">
    <canvas id="confetti"></canvas>
    <div class="overlay-bg">
      <div class="scanlines-behind"></div>
      <div class="vignette"></div>

      <div class="overlay-stage">
        <div class="art-wrap">
          <img id="overlayArtImg" alt="Winning Art"/>
          <div class="scanline-frame">
            <div class="band top"></div>
            <div class="band bottom"></div>
            <div class="band left"></div>
            <div class="band right"></div>
          </div>
        </div>
      </div>
    </div>

    <button id="overlayClose" class="btn">‚úï</button>
    <div class="overlay-card" id="overlayCard">
      <h1 id="overlayTitle">CHAMPION</h1>
      <div class="sub typewriter-text" id="overlaySubtitle"></div>
      <div class="motto typewriter-text" id="overlayMotto"></div>
    </div>
  </div>

  <!-- Fullscreen overlay -->
  <div id="fsOverlay">
    <button id="fsClose">‚úï</button>
    <img id="fsImage" alt="Fullscreen Art"/>
  </div>

<script>
/* ---------- Setup ---------- */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer`;
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const clockEl = document.getElementById('clock');
const stateEl = document.getElementById('state');
const phaseBadge = document.getElementById('phaseKey');
const loginBadge = document.getElementById('loginBadge');
const pauseBtn = document.getElementById('btnPause');
const toastEl = document.getElementById('toast');
function toast(msg, ms=1400){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); }
const iso = (d)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,'Z');

const imgA  = document.getElementById('imgA');
const imgB  = document.getElementById('imgB');
const labelA = document.getElementById('labelA');
const labelB = document.getElementById('labelB');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');
const voteA = document.getElementById('voteA');
const voteB = document.getElementById('voteB');
const submitBtn = document.getElementById('submitBtn');

const overlay = document.getElementById('overlay');
const overlayArtImg = document.getElementById('overlayArtImg');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySubtitle = document.getElementById('overlaySubtitle');
const overlayMotto = document.getElementById('overlayMotto');
const overlayClose = document.getElementById('overlayClose');
const confettiCanvas = document.getElementById('confetti');

/* Fullscreen overlay refs */
const fsOverlay = document.getElementById('fsOverlay');
const fsImage   = document.getElementById('fsImage');
const fsClose   = document.getElementById('fsClose');

/* bracket DOM */
const brows = document.getElementById('brows');
const showDone = document.getElementById('showDone');

/* ---------- State ---------- */
let paused=false, serverPhaseEndISO=null, currentPhaseKey=null, prevPhaseKey=null, prevPrevPhaseKey=null, periodSec=20, remainingSec=null, lastSyncAt=0, lastCountsAt=0;
let currentUid=null, chosen=null;

/** Stages: 'qf' | 'sf' | 'final' */
let stage='qf';
let overlayGateBase=null; // base ISO allowed to trigger champion

// Which battle the main tiles are showing
let activeSlot='qf1'; // qf1..qf4, sf1..sf2, final

// Freeze images per battle: "<baseISO>::slot" ‚Üí {A,B}
const imgCache = new Map();
let lastPaintedBattleKey=null;

/* ---------- Helpers ---------- */
async function getUidOrNull(){ const {data:{session}}=await supabase.auth.getSession(); return session?.user?.id ?? null; }
function paintLoginBadge(){ if(currentUid){loginBadge.textContent='logged in'; loginBadge.classList.add('ok'); loginBadge.classList.remove('warn');} else {loginBadge.textContent='not logged in'; loginBadge.classList.add('warn'); loginBadge.classList.remove('ok');} }

async function callEdge(method='GET', body=null){
  const res = await fetch(EDGE_URL,{method,headers:{'Content-Type':'application/json','Authorization':`Bearer ${SUPABASE_ANON_KEY}`,'apikey':SUPABASE_ANON_KEY},body:body?JSON.stringify(body):null});
  const raw = await res.text(); let j=null; try{ j=JSON.parse(raw);}catch{}
  if(!res.ok) throw new Error((j&&j.error)||raw||'edge error');
  return j?.state || j || {};
}
const normalize=(s)=>({phase_end_at:s.phase_end_at??null, period_sec:s.period_sec??20, paused:!!s.paused, remaining_sec:(typeof s.remaining_sec==='number')?s.remaining_sec:null});

function seedUrlFromKey(baseISO, suffix){ const s=encodeURIComponent(`${baseISO}-${suffix}`); return `https://picsum.photos/seed/${s}/1600/1200`; }

/* Slot ‚Üí seed suffixes */
const QF_SEEDS = {
  qf1: ['A1','B1'],
  qf2: ['A2','B2'],
  qf3: ['A3','B3'],
  qf4: ['A4','B4'],
};
/* SF depends on QF winners */
const SF_PAIRS = {
  sf1: ['qf1','qf2'],
  sf2: ['qf3','qf4'],
};

/* Key helpers */
function keyOf(slot, baseISO){ return `${baseISO}::${slot}`; }
function baseFromKey(k){ return (k||'').split('::')[0] || ''; }

/* ---------- Stage detection ---------- */
async function detectStage(){
  // If we have 2 SF winners from prev phase => we are in FINAL stage
  if (prevPhaseKey){
    const sfKeys = ['sf1','sf2'].map(s=>keyOf(s, prevPhaseKey));
    const { data: sfW } = await supabase.from('winners').select('phase_key').in('phase_key', sfKeys);
    if ((sfW||[]).length === 2) return 'final';
  }
  // If we have 4 QF winners from prev phase => we are in SF stage
  if (prevPhaseKey){
    const qfKeys = ['qf1','qf2','qf3','qf4'].map(s=>keyOf(s, prevPhaseKey));
    const { data: qfW } = await supabase.from('winners').select('phase_key').in('phase_key', qfKeys);
    if ((qfW||[]).length === 4) return 'sf';
  }
  // Otherwise, we're running QFs in the current phase
  return 'qf';
}

/* ---------- Base resolution for any slot ---------- */
function baseForSlot(slot){
  if (slot.startsWith('qf')){
    if (stage==='qf') return currentPhaseKey;
    if (stage==='sf') return prevPhaseKey;       // QFs happened last phase
    if (stage==='final') return prevPrevPhaseKey;// QFs happened two phases ago
  }
  if (slot.startsWith('sf')){
    if (stage==='qf') return currentPhaseKey;    // Will be TBD visuals; seeds still derived from current
    if (stage==='sf') return currentPhaseKey;    // Active
    if (stage==='final') return prevPhaseKey;    // Semis just finished last phase
  }
  // final
  return currentPhaseKey;
}

function currentBattleKey(){ const base=baseForSlot(activeSlot); return base ? keyOf(activeSlot, base) : null; }

/* ---------- Count votes for a key ---------- */
const fmtVotes=(n)=>`${n} ${n===1?'vote':'votes'}`;
async function countVotesFor(phaseKey){
  const { data, error } = await supabase.from('phase_votes').select('vote').eq('phase_key', phaseKey);
  if (error) throw error;
  let r=0,b=0; (data||[]).forEach(row=>{ if(row.vote==='red') r++; else if(row.vote==='blue') b++; });
  return {r,b};
}

/* ---------- Decide & persist winner for a key ---------- */
async function decideAndPersistWinner(phaseKeyISO){
  const { r, b } = await countVotesFor(phaseKeyISO);
  const color = (r===b) ? (Math.random()<0.5?'red':'blue') : (r>b?'red':'blue');
  const { error:insErr } = await supabase.from('winners').insert({phase_key: phaseKeyISO, color}).select().single();
  if (insErr){
    const { data } = await supabase.from('winners').select('color').eq('phase_key', phaseKeyISO).limit(1);
    const c=(data?.[0]?.color||'').toLowerCase();
    if (c==='red'||c==='blue') return c;
  }
  return color;
}

/* ---------- Winner lookups ---------- */
async function winnerColor(slot, base){
  const { data } = await supabase.from('winners').select('color').eq('phase_key', keyOf(slot, base)).maybeSingle();
  return (data?.color||null);
}

/* ---------- Build image sources for each slot ---------- */
async function sourcesFor(slot){
  const base = baseForSlot(slot);
  if (!base) return {A:'',B:''};

  // Cached?
  const cacheKey = keyOf(slot, base);
  if (imgCache.has(cacheKey)) return imgCache.get(cacheKey);

  // QF seeds are static from seedUrl
  if (slot.startsWith('qf')){
    const [sa,sb] = QF_SEEDS[slot];
    const pack = { A: seedUrlFromKey(base, sa), B: seedUrlFromKey(base, sb) };
    imgCache.set(cacheKey, pack);
    return pack;
  }

  // SF: winners of two QFs
  if (slot.startsWith('sf')){
    const [qfa, qfb] = SF_PAIRS[slot];
    const wa = await winnerColor(qfa, base);
    const wb = await winnerColor(qfb, base);
    // If winners not known yet, use seeds as placeholders
    const leftSeed  = wa==='red' ? QF_SEEDS[qfa][0] : (wa==='blue' ? QF_SEEDS[qfa][1] : QF_SEEDS[qfa][0]);
    const rightSeed = wb==='red' ? QF_SEEDS[qfb][0] : (wb==='blue' ? QF_SEEDS[qfb][1] : QF_SEEDS[qfb][1]);
    const pack = { A: seedUrlFromKey(base, leftSeed), B: seedUrlFromKey(base, rightSeed) };
    imgCache.set(cacheKey, pack);
    return pack;
  }

  // FINAL: winners of the two SFs
  if (slot==='final'){
    const w1 = await winnerColor('sf1', base);
    const w2 = await winnerColor('sf2', base);
    // If SF winners not known, fall back to SF computed sources
    let left, right;
    if (!w1 || !w2){
      const s1 = await sourcesFor('sf1');
      const s2 = await sourcesFor('sf2');
      left = s1.A; right = s2.A; // placeholder
    } else {
      // resolve back to which QF side produced each SF winner to pick consistent seed
      // We lean on sourcesFor(sfX) which already froze A/B from QF winners:
      const s1 = await sourcesFor('sf1');
      const s2 = await sourcesFor('sf2');
      left  = (w1==='red') ? s1.A : s1.B;
      right = (w2==='red') ? s2.A : s2.B;
    }
    const pack = { A:left, B:right };
    imgCache.set(cacheKey, pack);
    return pack;
  }

  return {A:'',B:''};
}

/* ---------- Paint current images ---------- */
async function paintImagesForActive(){
  const k = currentBattleKey();
  if (!k) return;

  const pack = await sourcesFor(activeSlot);
  imgA.src = pack.A || '';
  imgB.src = pack.B || '';

  if (activeSlot.startsWith('qf')){
    const n = activeSlot.slice(2);
    labelA.textContent=`QF ${n} ‚Äî Left`;
    labelB.textContent=`QF ${n} ‚Äî Right`;
  } else if (activeSlot.startsWith('sf')){
    const n = activeSlot.slice(2);
    labelA.textContent=`SF ${n} ‚Äî Left`;
    labelB.textContent=`SF ${n} ‚Äî Right`;
  } else {
    labelA.textContent='Final ‚Äî Left';
    labelB.textContent='Final ‚Äî Right';
  }

  imgA.loading='eager'; imgB.loading='eager'; imgA.decoding='async'; imgB.decoding='async';
  lastPaintedBattleKey=k;

  renderBracket();
  applyVotingLockUI();
}

/* ---------- Vote counts & UI ---------- */
async function refreshVoteCounts(){
  try{
    const key=currentBattleKey();
    if(!key){ countA.textContent='0 votes'; countB.textContent='0 votes'; return; }
    const {r,b}=await countVotesFor(key);
    countA.textContent=fmtVotes(r);
    countB.textContent=fmtVotes(b);
    lastCountsAt=Date.now();
    updateBracketScores();
  }catch{}
}

/* Voting lock: past rounds lock when we advance stages */
function votingLockedFor(slot){
  if (stage==='qf') return !slot.startsWith('qf'); // SF/Final closed
  if (stage==='sf') return slot.startsWith('qf') || slot==='final'; // only SF open
  if (stage==='final') return slot!=='final'; // only final open
  return true;
}
function setStateUI(){ stateEl.textContent = paused ? 'PAUSED' : 'LIVE'; pauseBtn.textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'; phaseBadge.textContent='phase: '+(currentPhaseKey||'‚Äî'); }
function applyVotingLockUI(){
  const locked = votingLockedFor(activeSlot);
  [voteA, voteB, submitBtn].forEach(b=> b.disabled = locked || !currentUid);
  document.getElementById('tileA').classList.toggle('decided', locked);
  document.getElementById('tileB').classList.toggle('decided', locked);
  submitBtn.textContent = locked ? 'Voting closed' : '‚úÖ Submit Vote';
}

/* ---------- Confetti (one burst; stop after 5s) ---------- */
let _confettiRaf=null;
function startConfetti(){
  const ctx=confettiCanvas.getContext('2d');
  const W=()=> (confettiCanvas.width = innerWidth);
  const H=()=> (confettiCanvas.height = innerHeight);
  W(); H();

  const cx = confettiCanvas.width/2;
  const cy = confettiCanvas.height/3;

  const N = 280;
  const parts = Array.from({length:N}, ()=> {
    const ang = Math.random()*Math.PI*2;
    const spd = 3 + Math.random()*7;
    return {
      x: cx, y: cy,
      vx: Math.cos(ang)*spd,
      vy: Math.sin(ang)*spd,
      w: 3+Math.floor(Math.random()*7),
      h: 3+Math.floor(Math.random()*7),
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.3,
      color: ['#39ff14','#7dff62','#00ffd5','#baffc9','#eaff00'][Math.floor(Math.random()*5)]
    };
  });

  function step(){
    W(); H();
    ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
    parts.forEach(p=>{
      p.vy += 0.04;
      p.vx *= 0.995; p.vy *= 0.995;
      p.x += p.vx; p.y += p.vy; p.rot += p.vr;

      if (p.x < -20) p.x = confettiCanvas.width + 20;
      if (p.x > confettiCanvas.width + 20) p.x = -20;
      if (p.y < -20) p.y = confettiCanvas.height + 20;
      if (p.y > confettiCanvas.height + 20) p.y = -20;

      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.fillStyle=p.color; ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
      ctx.restore();
    });
    _confettiRaf = requestAnimationFrame(step);
  }
  cancelAnimationFrame(_confettiRaf);
  step();
  setTimeout(()=> stopConfetti(), 5000);
}
function stopConfetti(){
  if (_confettiRaf) cancelAnimationFrame(_confettiRaf);
  _confettiRaf = null;
  const c=confettiCanvas.getContext('2d');
  c.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
}

/* ---------- Typewriter ---------- */
let _typewriterToken = 0;
async function typewriter(el, text, speed=85){
  const myToken = ++_typewriterToken;
  el.textContent = '';
  el.classList.add('type-caret');
  for (let i=0;i<text.length;i++){
    if (myToken !== _typewriterToken) return;
    el.textContent += text[i];
    await new Promise(r=>setTimeout(r, speed));
  }
  if (myToken === _typewriterToken) el.classList.remove('type-caret');
}

/* ---------- Champion overlay ---------- */
let _openChampionBase = null;
function showChampion(color, finalBaseISO){
  if (_openChampionBase === finalBaseISO && overlay.classList.contains('show')) return;
  _openChampionBase = finalBaseISO;

  const cached = imgCache.get(keyOf('final', finalBaseISO)) || {};
  const src = (color==='red') ? (cached.A || imgA.src) : (cached.B || imgB.src);
  overlayArtImg.src = src;

  overlayTitle.textContent = 'CHAMPION';
  const sub   = (color==='red') ? 'The left side devours the bracket.' : 'The right side devours the bracket.';
  const motto = 'Glory to the machine. Your art devours the bracket';

  overlaySubtitle.textContent = '';
  overlayMotto.textContent = '';

  overlay.classList.add('show');
  startConfetti();

  (async ()=>{
    await typewriter(overlaySubtitle, sub,   95);
    await typewriter(overlayMotto,   motto,  85);
  })();
}

overlayClose.onclick=()=>{ 
  overlay.classList.remove('show'); 
  stopConfetti(); 
  overlayArtImg.removeAttribute('src');
  overlaySubtitle.textContent = '';
  overlayMotto.textContent = '';
  _typewriterToken++;
  _openChampionBase = null;
};

/* ---------- Timer / phase handling ---------- */
async function fetchState(){
  const s = normalize(await callEdge('GET'));
  const prevEnd = serverPhaseEndISO;

  serverPhaseEndISO = s.phase_end_at;
  paused = s.paused;
  remainingSec = s.remaining_sec;
  periodSec = s.period_sec ?? 20;
  lastSyncAt = Date.now();

  currentPhaseKey = serverPhaseEndISO ? iso(serverPhaseEndISO) : null;
  prevPhaseKey = currentPhaseKey && periodSec ? iso(Date.parse(currentPhaseKey) - periodSec*1000) : null;
  prevPrevPhaseKey = currentPhaseKey && periodSec ? iso(Date.parse(currentPhaseKey) - 2*periodSec*1000) : null;

  setStateUI();

  // Detect current stage *after* we maybe persisted just-finished matches
  // but first, react to phase flip (persist winners for the phase that just ended)
  if (prevEnd && serverPhaseEndISO && prevEnd !== serverPhaseEndISO){
    const justEndedBase = iso(prevEnd);

    // Figure out what stage we *were* in at justEndedBase by looking one phase before it
    // If the phase that ended had SF open, we should see QF winners from its prev phase.
    // We'll infer using the same rules as detectStage but relative to justEndedBase.
    const priorToEnded = iso(Date.parse(justEndedBase) - periodSec*1000);

    // Count winners for prior phase:
    let endedStage = 'qf';
    {
      const sfKeys = ['sf1','sf2'].map(s=>keyOf(s, priorToEnded));
      const { data: sfW } = await supabase.from('winners').select('phase_key').in('phase_key', sfKeys);
      if ((sfW||[]).length===2) endedStage='final';
      else {
        const qfKeys = ['qf1','qf2','qf3','qf4'].map(s=>keyOf(s, priorToEnded));
        const { data: qfW } = await supabase.from('winners').select('phase_key').in('phase_key', qfKeys);
        if ((qfW||[]).length===4) endedStage='sf';
        else endedStage='qf';
      }
    }

    if (endedStage==='final'){
      // FINAL just ended at justEndedBase
      const finalKey = keyOf('final', justEndedBase);
      const color = await decideAndPersistWinner(finalKey);
      if (!imgCache.has(finalKey)){
        const pack = await sourcesFor('final'); // uses base resolution; okay since we cache by key
        if (pack) imgCache.set(finalKey, pack);
      }
      if (overlayGateBase === justEndedBase) showChampion(color, justEndedBase);

      // Loop back to QFs fresh
      overlayGateBase = null;
      activeSlot = 'qf1';
      imgCache.clear(); lastPaintedBattleKey=null;
    } else if (endedStage==='sf'){
      // SF just ended at justEndedBase ‚Üí persist both SF winners
      await decideAndPersistWinner(keyOf('sf1', justEndedBase));
      await decideAndPersistWinner(keyOf('sf2', justEndedBase));

      // Move INTO Final (new current phase)
      overlayGateBase = currentPhaseKey; // final that just started now
      activeSlot = 'final';
      const pack = await sourcesFor('final');
      if (pack) imgCache.set(keyOf('final', currentPhaseKey), pack);
      lastPaintedBattleKey=null;
    } else {
      // QFs just ended at justEndedBase ‚Üí persist qf1..qf4
      for (const qf of ['qf1','qf2','qf3','qf4']){
        await decideAndPersistWinner(keyOf(qf, justEndedBase));
      }
      // Move to Semis
      activeSlot = 'sf1';
      lastPaintedBattleKey=null;
    }
  }

  // What stage are we in *now*?
  stage = await detectStage();

  await paintImagesForActive();
  await refreshVoteCounts();
  renderBracket();
  applyVotingLockUI();
}

/* ---------- Bracket Rendering ---------- */
function rowId(slot){ return `row-${slot}`; }
function humanRound(slot){
  if (slot.startsWith('qf')) return 'QF';
  if (slot.startsWith('sf')) return 'SF';
  return 'Final';
}
function slotTitle(slot){
  if (slot.startsWith('qf')) return `Seed ${slot==='qf1'?'A vs B': slot==='qf2'?'C vs D': slot==='qf3'?'E vs F':'G vs H'}`;
  if (slot.startsWith('sf')){
    return slot==='sf1' ? 'W(QF1) vs W(QF2)' : 'W(QF3) vs W(QF4)';
  }
  return 'W(SF1) vs W(SF2)';
}
function isDecided(slot){
  if (stage==='qf') return !slot.startsWith('qf');
  if (stage==='sf') return slot.startsWith('qf') || slot==='final';
  if (stage==='final') return slot!=='final';
  return true;
}

async function thumbsFor(slot){
  const base = baseForSlot(slot);
  if (!base) return {A:'',B:''};
  const key = keyOf(slot, base);
  if (imgCache.has(key)) return imgCache.get(key);
  const pack = await sourcesFor(slot);
  imgCache.set(key, pack);
  return pack;
}

function switchTo(slot){
  activeSlot = slot;
  clearSelection();
  lastPaintedBattleKey=null;
  paintImagesForActive();
  refreshVoteCounts();
  highlightActiveRow();
  applyVotingLockUI();
}

function highlightActiveRow(){
  document.querySelectorAll('.brow').forEach(el=>el.classList.remove('active'));
  const r = document.getElementById(rowId(activeSlot));
  r && r.classList.add('active');
}

async function updateBracketScores(){
  const all = ['qf1','qf2','qf3','qf4','sf1','sf2','final'];
  for (const slot of all){
    const base = baseForSlot(slot);
    if (!base) continue;
    const key = keyOf(slot, base);
    const sEl = document.querySelector(`#${rowId(slot)} .bscore`);
    if (!sEl) continue;
    try{
      const {r,b}=await countVotesFor(key);
      sEl.textContent = `${r} - ${b}`;
    }catch{
      sEl.textContent = `0 - 0`;
    }
  }
}

async function renderBracket(){
  const slots = ['qf1','qf2','qf3','qf4','sf1','sf2','final'];
  const rows = await Promise.all(slots.map(async (slot)=>{
    const thumbs = await thumbsFor(slot);
    const decided = isDecided(slot);
    return `
      <div class="brow ${decided?'decided':''}" id="${rowId(slot)}" data-slot="${slot}">
        <div class="bbadge">${humanRound(slot)}</div>
        <div class="thumb2">
          <div class="thumb">${thumbs.A ? `<img src="${thumbs.A}" alt="">` : ''}</div>
          <div class="thumb">${thumbs.B ? `<img src="${thumbs.B}" alt="">` : ''}</div>
        </div>
        <div class="bmeta">
          <div class="title">${slotTitle(slot)}</div>
          <div class="bline">
            <span class="bpill">${decided?'round decided':'uses global'}</span>
          </div>
        </div>
        <div class="bscore">0 - 0</div>
      </div>
    `;
  }));

  brows.innerHTML = rows.join('');
  highlightActiveRow();
  updateBracketScores();

  brows.querySelectorAll('.brow').forEach(row=>{
    row.addEventListener('click',()=> switchTo(row.dataset.slot));
  });
}

/* ---------- Loops ---------- */
let rafId=null;
function stop(){ if(rafId) cancelAnimationFrame(rafId); rafId=null; }
async function start(){
  stop();
  const loop = async ()=>{
    if (paused){
      const remCalc = currentPhaseKey ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      const sec = (typeof remainingSec==='number' && !Number.isNaN(remainingSec)) ? Number(remainingSec) : Math.ceil(remCalc/1000);
      clockEl.textContent = String(Math.max(0, Math.ceil(sec)));
      if (Date.now()-lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
    } else {
      const rem = serverPhaseEndISO ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      clockEl.textContent = String(Math.ceil(rem/1000));
      if (rem<=0 || Date.now()-lastSyncAt>5000) { try{ await fetchState(); }catch{} }
      if (Date.now()-lastCountsAt>2000) refreshVoteCounts();
    }
    rafId = requestAnimationFrame(loop);
  };
  rafId = requestAnimationFrame(loop);
}

/* ---------- Realtime ---------- */
supabase.channel('winners-final-overlay')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners'},(payload)=>{
    const key = payload?.new?.phase_key || '';
    const color = (payload?.new?.color||'').toLowerCase();
    if (!key.endsWith('::final')) return;
    const base = key.split('::')[0];
    if (!overlayGateBase || base !== overlayGateBase) return;
    if (!(color==='red'||color==='blue')) return;

    if (!imgCache.has(keyOf('final', base))){
      sourcesFor('final').then(pack=>{
        if (pack) imgCache.set(keyOf('final', base), pack);
        showChampion(color, base);
      });
    } else {
      showChampion(color, base);
    }
  }).subscribe();

supabase.channel('phase-votes-live')
  .on('postgres_changes',{event:'*',schema:'public',table:'phase_votes'}, async (payload)=>{
    const pk = payload?.new?.phase_key || payload?.old?.phase_key;
    if (!pk) return;
    updateBracketScores();
    const want = currentBattleKey();
    if (pk && want && pk===want) await refreshVoteCounts();
  }).subscribe();

/* ---------- Controls / Voting ---------- */
pauseBtn.onclick = async ()=>{ try{ if (paused) await callEdge('POST',{action:'resume'}); else await callEdge('POST',{action:'pause'}); await fetchState(); toast('OK'); }catch{ toast('Pause/resume failed'); }};

function clearSelection(){ voteA.classList.remove('selected'); voteB.classList.remove('selected'); chosen=null; submitBtn.textContent='‚úÖ Submit Vote'; submitBtn.disabled=!currentUid; }
voteA.onclick=()=>{ if (votingLockedFor(activeSlot)) return toast('Voting closed'); chosen='red'; voteA.classList.add('selected'); voteB.classList.remove('selected'); submitBtn.disabled=!currentUid; };
voteB.onclick=()=>{ if (votingLockedFor(activeSlot)) return toast('Voting closed'); chosen='blue'; voteB.classList.add('selected'); voteA.classList.remove('selected'); submitBtn.disabled=!currentUid; };
submitBtn.onclick=async()=>{
  if (votingLockedFor(activeSlot)) return toast('Voting closed');
  const key=currentBattleKey();
  if (!chosen || !key) return;
  if (!currentUid){ toast('Log in to vote'); return; }
  try{
    const { error } = await supabase.from('phase_votes').upsert(
      { phase_key:key, vote:chosen, user_id: currentUid },
      { onConflict:'phase_key,user_id' }
    );
    if (error) throw error;
    toast('‚úî Vote submitted');
    submitBtn.textContent='‚úî Voted';
    submitBtn.disabled=true;
    refreshVoteCounts();
  }catch{ toast('Vote failed'); }
};

/* ---------- Boot ---------- */
(async()=>{
  currentUid = await getUidOrNull(); paintLoginBadge();
  supabase.auth.onAuthStateChange((_evt, session)=>{ currentUid=session?.user?.id ?? null; paintLoginBadge(); submitBtn.disabled=!chosen||!currentUid; });

  await fetchState();
  // default to first open round at current stage
  activeSlot = (stage==='qf') ? 'qf1' : (stage==='sf' ? 'sf1' : 'final');
  await paintImagesForActive();
  await start();
})();
</script>
</body>
</html>