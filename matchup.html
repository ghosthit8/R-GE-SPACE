<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space ‚Äî Matchup (2-Round Bracket)</title>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
:root{ --green:#39ff14; --green-bright:#7dff62; --bg:#000; --ink:#e5e5e5; --card:#0b0b0b; --border:#153b16; --muted:#8aff8a; --maxw:980px; }
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:var(--maxw);margin:16px auto 64px;padding:0 16px}
.scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
.btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;cursor:pointer;text-decoration:none;display:inline-block;text-align:center}
.btn:hover{box-shadow:0 0 12px rgba(57,255,20,.18)}
.tiny{display:flex;gap:8px;align-items:center;font-variant-numeric:tabular-nums;font-size:12px;color:var(--muted)}
.clock{font-weight:700;border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.tile{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:rgba(7,7,7,.6);margin-top:16px;position:relative}
.art{aspect-ratio:4/3;width:100%;height:auto;display:block;object-fit:cover}
.caption{display:block;text-align:center;font-size:12px;color:var(--muted);padding:6px 8px;border-top:1px dashed var(--border)}
.meta{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-top:1px solid var(--border)}
.btn.primary.selected{background:rgba(57,255,20,.22);color:var(--ink);box-shadow:0 0 18px rgba(125,255,98,.35), inset 0 0 12px rgba(57,255,20,.15)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:14px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071c07;color:var(--green);border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:none;box-shadow:0 0 18px rgba(57,255,20,.18);z-index:50}
.toast.show{display:block}
.badge{border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge.warn{border-color:#3b1616;color:#ff6b6b}
.badge.ok{border-color:#153b16;color:#8aff8a}

/* bracket nav */
.tabs{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:12px}
.tab{border:1px solid var(--border);padding:6px 10px;border-radius:10px;cursor:pointer;background:rgba(7,7,7,.35);color:var(--muted);font-size:13px}
.tab.active{border-color:var(--green);color:var(--green)}
.tab[disabled]{opacity:.4;cursor:not-allowed}

/* Small Winner FX (tile pulse) */
@keyframes winPulse { 0% {box-shadow:0 0 0 rgba(125,255,98,0); transform:scale(1)} 50% {box-shadow:0 0 36px rgba(125,255,98,.45); transform:scale(1.01)} 100% {box-shadow:0 0 0 rgba(125,255,98,0); transform:scale(1)} }
.tile.win .art{animation:winPulse 1200ms ease-in-out 2}
.tile.win::after{content:"üèÅ WINNER"; position:absolute; right:10px; top:10px; background:rgba(7,28,7,.9); border:1px solid var(--border); padding:6px 10px; border-radius:10px; font-weight:700}

/* ====== BIG OVERLAY ====== */
#overlay{position:fixed; inset:0; display:none; z-index:9999; background:rgba(0,0,0,0.92)}
#overlay.show{display:block}
.overlay-bg{position:absolute; inset:0; overflow:hidden; filter:contrast(1.05) saturate(1.1)}
.overlay-art{position:absolute; inset:0; background-size:cover; background-position:center; background-repeat:no-repeat}
.overlay-art.split{background:linear-gradient(90deg,#a60000 50%, #0058a6 50%)}
.scanlines{position:absolute; inset:0; background:repeating-linear-gradient(to bottom, rgba(0,0,0,.25) 0px, rgba(0,0,0,.25) 2px, rgba(0,0,0,0) 3px, rgba(0,0,0,0) 4px); mix-blend-mode:multiply; pointer-events:none}
.vignette{position:absolute; inset:-10%; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,.6) 100%)}
@keyframes titleJitter{0%,100%{transform:translate(0,0)}20%{transform:translate(1px,-1px)}40%{transform:translate(-1px,1px)}60%{transform:translate(1px,1px)}80%{transform:translate(-1px,-1px)}}
.overlay-card{position:relative; max-width:min(820px, 92vw); margin:8vh auto 4vh; border:1px solid var(--green); background:rgba(7,7,7,.72); border-radius:18px; padding:22px 18px; box-shadow:0 0 40px rgba(57,255,20,.25); animation:titleJitter 2200ms steps(2,end) infinite}
.overlay-card h1{margin:0 0 6px; text-align:center; letter-spacing:2px; font-size:clamp(28px,6vw,54px); text-transform:uppercase}
.overlay-card .sub{text-align:center; color:var(--muted); margin-bottom:12px; font-size:clamp(12px,2.4vw,14px)}
.overlay-card .motto{text-align:center; margin-top:8px; color:var(--green-bright); font-weight:700; letter-spacing:.5px}
#overlayClose{position:absolute; right:14px; top:12px; z-index:2; border:1px solid var(--green); background:rgba(0,0,0,.6); color:var(--green); border-radius:10px; padding:6px 10px; cursor:pointer}
#confetti{position:absolute; inset:0; pointer-events:none}
.overlay-card.tie{border-color:#4e4e4e; box-shadow:0 0 40px rgba(130,130,130,.25)}
.overlay-card.tie h1{color:#d4d4d4}
.overlay-card.tie .motto{color:#cfcfcf}
</style>
</head>
<body>
  <div class="wrap">
    <div class="scorebar">
      <div class="tiny">
        <strong>Decision in</strong>
        <span id="clock" class="clock">Sync‚Ä¶</span>
        <span id="state" class="clock">‚Äî</span>
        <span id="phaseKey" class="clock">phase: ‚Äî</span>
        <span id="loginBadge" class="badge">checking auth‚Ä¶</span>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">‚è∏Ô∏è Pause</button>
        <button id="btnForce" class="btn">üèÅ Force Decide</button>
        <a class="btn" id="openWinnersLink" href="./winners.html" target="_self" rel="noopener">üèÅ Winners</a>
        <button class="btn" id="goWinners" type="button">üß∞ Open Winners</button>
      </div>
    </div>

    <!-- bracket nav -->
    <div class="tabs">
      <button class="tab" id="tabSf1">Round 1 ¬∑ Semi 1</button>
      <button class="tab" id="tabSf2">Round 1 ¬∑ Semi 2</button>
      <button class="tab" id="tabFinal" disabled>Round 2 ¬∑ Final</button>
    </div>

    <!-- ACTIVE BATTLE DISPLAY -->
    <div class="tile" id="tileA" data-color="red">
      <img id="imgA" class="art" alt="Entry Left"/>
      <div class="caption" id="countA">0 votes</div>
      <div class="meta">
        <span id="labelA">Left</span>
        <button class="btn primary" id="voteA">Vote This</button>
      </div>
    </div>

    <div class="tile" id="tileB" data-color="blue">
      <img id="imgB" class="art" alt="Entry Right"/>
      <div class="caption" id="countB">0 votes</div>
      <div class="meta">
        <span id="labelB">Right</span>
        <button class="btn primary" id="voteB">Vote This</button>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="submitBtn" disabled>‚úÖ Submit Vote</button>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <!-- ===== BIG OVERLAY (Final only) ===== -->
  <div id="overlay">
    <canvas id="confetti"></canvas>
    <div class="overlay-bg">
      <div id="overlayArt" class="overlay-art"></div>
      <div class="scanlines"></div>
      <div class="vignette"></div>
    </div>
    <button id="overlayClose" class="btn">‚úï</button>
    <div id="overlayCard" class="overlay-card">
      <h1 id="overlayTitle">CHAMPION</h1>
      <div class="sub" id="overlaySubtitle">Rage Space</div>
      <div class="motto">Glory to the machine. Your art devours the bracket</div>
    </div>
  </div>

<script>
/* ---------- Winners navigation helper ---------- */
(function(){
  const btn = document.getElementById('goWinners');
  if (!btn) return;
  btn.addEventListener('click', function(ev){
    ev.preventDefault();
    const folderHref = location.pathname.replace(/[^/]*$/, '') + 'winners.html';
    const parts = location.pathname.split('/').filter(Boolean);
    const repoRoot = parts.length ? `/${parts[0]}/` : '/';
    const rootHref = `${repoRoot}winners.html`;
    try { window.location.assign(folderHref); } catch { window.location.href = folderHref; }
    setTimeout(()=>{ try{ window.location.replace(rootHref); } catch{ window.location.href = rootHref; } }, 150);
  }, {passive:false});
})();

/* =========================
   App logic
========================= */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer`;
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const clockEl = document.getElementById('clock');
const stateEl = document.getElementById('state');
const phaseBadge = document.getElementById('phaseKey');
const loginBadge = document.getElementById('loginBadge');
const pauseBtn = document.getElementById('btnPause');
const forceBtn = document.getElementById('btnForce');
const submitBtn   = document.getElementById('submitBtn');

const tileA = document.getElementById('tileA');
const tileB = document.getElementById('tileB');
const imgA  = document.getElementById('imgA');
const imgB  = document.getElementById('imgB');
const labelA = document.getElementById('labelA');
const labelB = document.getElementById('labelB');
const voteA = document.getElementById('voteA');
const voteB = document.getElementById('voteB');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');

const toastEl = document.getElementById('toast');

const overlay = document.getElementById('overlay');
const overlayClose = document.getElementById('overlayClose');
const overlayArt = document.getElementById('overlayArt');
const overlayCard = document.getElementById('overlayCard');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySubtitle = document.getElementById('overlaySubtitle');
const confetti = document.getElementById('confetti');

function toast(msg, ms=1600){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), ms); }
const iso = (d)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,'Z');

/* ===== BRACKET KEYS =====
   Phase alternates: Round 1 (semis) ‚Üí Round 2 (final)
   We derive keys like:
   - <currentPhaseEndISO>::sf1
   - <currentPhaseEndISO>::sf2
   - <currentPhaseEndISO>::final
   Final‚Äôs entrants are the winners from previous phase‚Äôs sf1/sf2.
*/
let paused = false;
let serverPhaseEndISO = null; // raw current phase end
let currentPhaseKey = null;   // always live phase (ISO end)
let prevPhaseKey = null;      // computed from remaining_sec/period_sec
let remainingSec = null;
let lastSyncAt = 0;
let lastCountsAt = 0;
let chosen = null;
let currentUid = null;
let periodSec = 20; // UI expects 20s per your setup; will be overwritten by edge state if provided

// UI selection: 'sf1' | 'sf2' | 'final'
let activeSlot = 'sf1';
const tabSf1 = document.getElementById('tabSf1');
const tabSf2 = document.getElementById('tabSf2');
const tabFinal = document.getElementById('tabFinal');

/* ===== AUTH ===== */
async function getUidOrNull() {
  const { data: { session } } = await supabase.auth.getSession();
  return session?.user?.id ?? null;
}
function paintLoginBadge() {
  if (currentUid) { loginBadge.textContent = "logged in"; loginBadge.classList.remove('warn'); loginBadge.classList.add('ok'); }
  else { loginBadge.textContent = "not logged in"; loginBadge.classList.remove('ok'); loginBadge.classList.add('warn'); }
}

/* ===== EDGE ===== */
async function callEdge(method='GET', body=null){
  const res = await fetch(EDGE_URL, {
    method,
    headers: {'Content-Type':'application/json','Authorization':`Bearer ${SUPABASE_ANON_KEY}`,'apikey': SUPABASE_ANON_KEY},
    body: body ? JSON.stringify(body) : null
  });
  const raw = await res.text(); let j=null; try{ j=JSON.parse(raw); }catch{}
  if(!res.ok) throw new Error((j && j.error) || raw || 'edge error');
  return j?.state || j || {};
}
const normalize = (s)=>({
  phase_end_at: s.phase_end_at ?? null,
  period_sec: s.period_sec ?? 20,
  paused: !!s.paused,
  remaining_sec: (typeof s.remaining_sec === 'number') ? s.remaining_sec : null
});

/* ===== IMAGE SEEDING ===== */
function seedUrlFromKey(phaseKeyISO, suffix){
  const s = encodeURIComponent(`${phaseKeyISO}-${suffix}`);
  return `https://picsum.photos/seed/${s}/1600/1200`;
}
function setActiveTabUI(){
  [tabSf1,tabSf2,tabFinal].forEach(b=>b.classList.remove('active'));
  if (activeSlot==='sf1') tabSf1.classList.add('active');
  else if (activeSlot==='sf2') tabSf2.classList.add('active');
  else tabFinal.classList.add('active');
}

function semiKeysFor(baseISO){
  return { sf1:`${baseISO}::sf1`, sf2:`${baseISO}::sf2` };
}
function finalKeyFor(baseISO){
  return `${baseISO}::final`;
}

/* Determine if current phase is Final stage.
   If winners for the *previous* base‚Äôs semis exist, we‚Äôre in Final now. */
async function detectStage(){
  if (!currentPhaseKey || !prevPhaseKey) return {stage:'semis', finalsReady:false};
  const { sf1, sf2 } = semiKeysFor(prevPhaseKey);
  const { data, error } = await supabase
    .from('winners')
    .select('phase_key,color')
    .in('phase_key',[sf1,sf2]);
  if (error) return {stage:'semis', finalsReady:false};
  const haveBoth = (data||[]).length === 2 && data.every(r => r.color && (r.color==='red'||r.color==='blue'));
  return {stage: haveBoth ? 'final':'semis', finalsReady: haveBoth};
}

/* Winners of previous semis ‚Üí final image sources */
async function getFinalEntrantSources(){
  const { sf1, sf2 } = semiKeysFor(prevPhaseKey);
  const { data } = await supabase.from('winners').select('phase_key,color').in('phase_key',[sf1,sf2]);
  const map = Object.fromEntries((data||[]).map(r=>[r.phase_key, r.color]));
  const c1 = map[sf1]; const c2 = map[sf2];
  if (!c1 || !c2) return null;
  // Entrant images come from winners‚Äô original semi images
  const src1 = seedUrlFromKey(prevPhaseKey, c1==='red' ? 'A':'B');
  const src2 = seedUrlFromKey(prevPhaseKey, c2==='red' ? 'A':'B');
  return { src1, src2, c1, c2 };
}

function setImagesForActive(){
  if (!currentPhaseKey) return;

  if (activeSlot === 'sf1'){
    imgA.src = seedUrlFromKey(currentPhaseKey,'A1');
    imgB.src = seedUrlFromKey(currentPhaseKey,'B1');
    labelA.textContent = 'Semi 1 ‚Äî Left';
    labelB.textContent = 'Semi 1 ‚Äî Right';
  } else if (activeSlot === 'sf2'){
    imgA.src = seedUrlFromKey(currentPhaseKey,'A2');
    imgB.src = seedUrlFromKey(currentPhaseKey,'B2');
    labelA.textContent = 'Semi 2 ‚Äî Left';
    labelB.textContent = 'Semi 2 ‚Äî Right';
  } else {
    // Final pulls winners from previous phase
    imgA.src = '';
    imgB.src = '';
    labelA.textContent = 'Final ‚Äî Left';
    labelB.textContent = 'Final ‚Äî Right';
    // Fetch async and then paint
    getFinalEntrantSources().then(s=>{
      if (!s) { imgA.src = seedUrlFromKey(prevPhaseKey,'A'); imgB.src = seedUrlFromKey(prevPhaseKey,'B'); return;}
      imgA.src = s.src1; imgB.src = s.src2;
    });
  }
  imgA.loading='eager'; imgB.loading='eager'; imgA.decoding='async'; imgB.decoding='async';
}

/* ===== VOTES ===== */
const fmtVotes = (n)=> `${n} ${n===1?'vote':'votes'}`;
function currentBattleKey(){
  if (!currentPhaseKey) return null;
  if (activeSlot==='final') return finalKeyFor(currentPhaseKey);
  // semis use the *current* base
  const { sf1, sf2 } = semiKeysFor(currentPhaseKey);
  return activeSlot==='sf1' ? sf1 : sf2;
}
async function countVotesFor(key){
  const { data, error } = await supabase.from('phase_votes').select('vote').eq('phase_key', key);
  if (error) throw error;
  let r=0,b=0; (data||[]).forEach(row=>{ if(row.vote==='red') r++; else if(row.vote==='blue') b++; });
  return {r,b};
}
async function refreshVoteCounts(){
  try{
    const key = currentBattleKey();
    if(!key){ countA.textContent='0 votes'; countB.textContent='0 votes'; return; }
    const { r, b } = await countVotesFor(key);
    countA.textContent = fmtVotes(r);
    countB.textContent = fmtVotes(b);
    lastCountsAt = Date.now();
  }catch(e){}
}

/* ===== WINNER / OVERLAY (Final only) ===== */
function clearWinFX(){ tileA.classList.remove('win'); tileB.classList.remove('win'); }
function openWinnerOverlayFinal(color){
  const src = (color==='red') ? imgA.src : imgB.src;
  overlayArt.className = 'overlay-art';
  overlayArt.style.backgroundImage = `url("${src}")`;
  overlayCard.className = 'overlay-card';
  overlayTitle.textContent = 'CHAMPION';
  overlaySubtitle.textContent = (color==='red' ? 'Final: Left prevails' : 'Final: Right prevails');
  overlay.classList.add('show'); startConfetti({mode:'win'});
}
function openTieRandomOverlayFinal(color){
  const src = (color==='red') ? imgA.src : imgB.src;
  const which = (color==='red') ? 'Final: Left' : 'Final: Right';
  overlayArt.className='overlay-art';
  overlayArt.style.backgroundImage=`url("${src}")`;
  overlayCard.className='overlay-card';
  overlayTitle.textContent = `Tie... random winner picked: ${which}`;
  overlaySubtitle.textContent = (color==='red' ? 'Final: Left prevails' : 'Final: Right prevails');
  overlay.classList.add('show'); startConfetti({mode:'win'});
}
function closeOverlay(){ overlay.classList.remove('show'); stopConfetti(); }
overlayClose.addEventListener('click', closeOverlay);

/* Confetti */
function startConfetti({mode='win'}={}){ const ctx=confetti.getContext('2d'); let raf; const palette = mode==='win'?['#39ff14','#7dff62','#00ffd5','#baffc9','#eaff00']:['#cfcfcf','#a0a0a0','#6ad1ff','#39ff14']; const parts=Array.from({length:mode==='win'?220:120},()=>({x:Math.random()*innerWidth,y:-20-Math.random()*innerHeight*0.3,vx:(Math.random()-0.5)*2,vy:1.2+Math.random()*2.6,w:3+Math.floor(Math.random()*7),h:3+Math.floor(Math.random()*7),rot:Math.random()*Math.PI,vr:(Math.random()-0.5)*0.2,color:palette[Math.floor(Math.random()*palette.length)]})); function step(){ confetti.width=innerWidth; confetti.height=innerHeight; ctx.clearRect(0,0,confetti.width,confetti.height); parts.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.rot+=p.vr; if(p.y>innerHeight+20){p.y=-10;p.x=Math.random()*innerWidth;} ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.rot);ctx.fillStyle=p.color;ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);ctx.restore();}); raf=requestAnimationFrame(step);} step(); confetti._stop=()=>{cancelAnimationFrame(raf);const c=confetti.getContext('2d');c.clearRect(0,0,confetti.width,confetti.height);} }
function stopConfetti(){ confetti._stop && confetti._stop(); }

/* ===== STATE/TIMER ===== */
function setStateUI(){ stateEl.textContent = paused ? 'PAUSED' : 'LIVE'; pauseBtn.textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'; phaseBadge.textContent = 'phase: ' + (currentPhaseKey || '‚Äî'); }

async function fetchState(){
  const s = normalize(await callEdge('GET'));
  const prevEnd = serverPhaseEndISO;
  serverPhaseEndISO = s.phase_end_at;
  paused = s.paused;
  remainingSec = s.remaining_sec;
  periodSec = s.period_sec ?? 20;
  lastSyncAt = Date.now();

  // derive current and prev phase keys
  currentPhaseKey = serverPhaseEndISO ? iso(serverPhaseEndISO) : null;
  prevPhaseKey = currentPhaseKey && periodSec ? iso(Date.parse(currentPhaseKey) - periodSec*1000) : null;

  setStateUI();

  // Did we just flip?
  if (prevEnd && serverPhaseEndISO && prevEnd !== serverPhaseEndISO){
    // A phase just finished. Figure out which one ended (semis or final) and finalize accordingly.
    const endedISO = iso(prevEnd);
    // If the *current* phase is Final stage, the ended one was Semis.
    const { stage } = await detectStage();
    if (stage === 'final'){
      // finalize both semis (no big overlay)
      const { sf1, sf2 } = semiKeysFor(endedISO);
      await finalizeWinnerNoOverlay(sf1);
      await finalizeWinnerNoOverlay(sf2);
    } else {
      // finalize the final (show overlay)
      const fKey = finalKeyFor(endedISO);
      await finalizeWinnerFinalOverlay(fKey);
    }
  }

  // enable/disable tabs based on stage
  const { stage, finalsReady } = await detectStage();
  tabFinal.disabled = (stage !== 'final');
  // if we are in semis but user was on "final", nudge back to sf1
  if (stage==='semis' && activeSlot==='final'){ activeSlot='sf1'; setActiveTabUI(); setImagesForActive(); }
  if (stage==='final' && activeSlot!=='final'){ /* keep whatever user selected; they can click final when ready */ }

  setImagesForActive();
  refreshVoteCounts();
}

let rafId = null;
function stop(){ if(rafId) cancelAnimationFrame(rafId); rafId=null; }
async function start(){
  stop();
  const loop = async ()=>{
    if (paused){
      const remCalc = currentPhaseKey ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      const sec = (typeof remainingSec === 'number' && !Number.isNaN(remainingSec)) ? Number(remainingSec) : Math.ceil(remCalc/1000);
      clockEl.textContent = String(Math.max(0, Math.ceil(sec)));
      if (Date.now() - lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
    } else {
      const rem = serverPhaseEndISO ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      clockEl.textContent = String(Math.ceil(rem/1000));
      if (rem <= 0 || Date.now()-lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
      if (Date.now() - lastCountsAt > 2000) refreshVoteCounts();
    }
    rafId = requestAnimationFrame(loop);
  };
  rafId = requestAnimationFrame(loop);
}

/* ===== WINNER DECISION (strict; tie ‚áí random) ===== */
async function decideAndPersistWinner(phaseKeyISO){
  const { r, b } = await countVotesFor(phaseKeyISO);
  let color;
  if (r === b){ color = (Math.random()<0.5)?'red':'blue'; }
  else { color = (r>b)?'red':'blue'; }

  // Try to persist; tolerate races
  const { error: insErr } = await supabase.from('winners').insert({ phase_key: phaseKeyISO, color }).select().single();
  if (insErr){
    const { data } = await supabase.from('winners').select('color').eq('phase_key', phaseKeyISO).limit(1);
    const c = (data?.[0]?.color || '').toLowerCase();
    if (c==='red'||c==='blue') return { color:c, tied:(r===b) };
  }
  return { color, tied:(r===b) };
}

async function finalizeWinnerNoOverlay(phaseKeyISO){
  try{ await decideAndPersistWinner(phaseKeyISO); }catch(_){}
}
async function finalizeWinnerFinalOverlay(phaseKeyISO){
  try{
    const { r, b } = await countVotesFor(phaseKeyISO);
    const decided = await decideAndPersistWinner(phaseKeyISO);
    if (decided.tied){
      openTieRandomOverlayFinal(decided.color);
    } else {
      openWinnerOverlayFinal(decided.color);
    }
  }catch(_e){}
}

/* --- Realtime reactions ---
   - For semis winners: no big overlay (we stay quiet).
   - For final winner: show big overlay.
*/
supabase.channel('winners-phase-2round')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners'}, async (payload)=>{
    const key = payload?.new?.phase_key || '';
    if (!key) return;
    if (key.endsWith('::final')){
      const color = (payload?.new?.color || '').toLowerCase();
      if (color==='red'||color==='blue'){
        openWinnerOverlayFinal(color);
      }
    }
  }).subscribe();

/* --- Realtime counts for currently active battle only --- */
supabase.channel('phase-votes-live-2round')
  .on('postgres_changes',{event:'*',schema:'public',table:'phase_votes'}, async (payload)=>{
    try{
      const pk = payload?.new?.phase_key || payload?.old?.phase_key;
      const want = currentBattleKey();
      if (pk && want && pk===want) await refreshVoteCounts();
    }catch(e){}
  }).subscribe();

/* --- Controls --- */
pauseBtn.onclick = async ()=>{ try{ if (paused) await callEdge('POST',{action:'resume'}); else await callEdge('POST',{action:'pause'}); await fetchState(); toast('OK'); }catch(e){ toast('Pause/resume failed'); }};
forceBtn.onclick = async ()=>{ try{ await callEdge('POST',{force:true}); await fetchState(); toast('Forced decision'); }catch(e){ toast('Force failed'); }};

/* --- Voting UX (A ‚Üí red, B ‚Üí blue) --- */
function clearSelection(){ voteA.classList.remove('selected'); voteB.classList.remove('selected'); chosen=null; submitBtn.textContent='‚úÖ Submit Vote'; submitBtn.disabled = !currentUid; }
voteA.onclick  = ()=>{ chosen='red';  voteA.classList.add('selected');  voteB.classList.remove('selected'); submitBtn.disabled = !currentUid; if(!currentUid) toast('Log in to vote'); };
voteB.onclick  = ()=>{ chosen='blue'; voteB.classList.add('selected');  voteA.classList.remove('selected'); submitBtn.disabled = !currentUid; if(!currentUid) toast('Log in to vote'); };
submitBtn.onclick = async ()=>{
  const key = currentBattleKey();
  if (!chosen || !key) return;
  if (!currentUid) { toast('Log in to vote'); return; }
  try{
    const { error } = await supabase.from('phase_votes').upsert(
      { phase_key: key, vote: chosen, user_id: currentUid },
      { onConflict:'phase_key,user_id' }
    );
    if (error) throw error;
    toast('‚úî Vote submitted');
    submitBtn.textContent = '‚úî Voted';
    submitBtn.disabled = true;
    refreshVoteCounts();
  }catch(e){ toast('Vote failed'); }
};

/* --- Tabs --- */
function switchTab(slot){
  activeSlot = slot;
  setActiveTabUI();
  clearSelection();
  setImagesForActive();
  refreshVoteCounts();
}
tabSf1.onclick = ()=> switchTab('sf1');
tabSf2.onclick = ()=> switchTab('sf2');
tabFinal.onclick = ()=> { if (!tabFinal.disabled) switchTab('final'); else toast('Final begins next round'); };

/* ===== Overlay helpers reused ===== */
function startConfetti({mode='win'}={}){ const ctx=confetti.getContext('2d'); let raf; const palette = mode==='win'?['#39ff14','#7dff62','#00ffd5','#baffc9','#eaff00']:['#cfcfcf','#a0a0a0','#6ad1ff','#39ff14']; const parts=Array.from({length:mode==='win'?220:120},()=>({x:Math.random()*innerWidth,y:-20-Math.random()*innerHeight*0.3,vx:(Math.random()-0.5)*2,vy:1.2+Math.random()*2.6,w:3+Math.floor(Math.random()*7),h:3+Math.floor(Math.random()*7),rot:Math.random()*Math.PI,vr:(Math.random()-0.5)*0.2,color:palette[Math.floor(Math.random()*palette.length)]})); function step(){ confetti.width=innerWidth; confetti.height=innerHeight; ctx.clearRect(0,0,confetti.width,confetti.height); parts.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.rot+=p.vr; if(p.y>innerHeight+20){p.y=-10;p.x=Math.random()*innerWidth;} ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.rot);ctx.fillStyle=p.color;ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);ctx.restore();}); raf=requestAnimationFrame(step);} step(); confetti._stop=()=>{cancelAnimationFrame(raf);const c=confetti.getContext('2d');c.clearRect(0,0,confetti.width,confetti.height);} }
function stopConfetti(){ confetti._stop && confetti._stop(); }

/* --- Boot --- */
(async()=>{
  try{
    currentUid = await getUidOrNull(); paintLoginBadge();
    supabase.auth.onAuthStateChange(async (_evt, session) => { currentUid = session?.user?.id ?? null; paintLoginBadge(); submitBtn.disabled = !chosen || !currentUid; });

    await fetchState();
    setActiveTabUI();
    setImagesForActive();
    await start();
  }catch(e){
    clockEl.textContent='ERR'; stateEl.textContent='ERR';
  }
})();
</script>
</body>
</html>