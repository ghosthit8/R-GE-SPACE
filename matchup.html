<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space — Matchup</title>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
:root{
  --green:#39ff14; --green-bright:#7dff62;
  --bg:#000; --ink:#e5e5e5;
  --card:#0b0b0b; --border:#153b16; --muted:#8aff8a; --maxw:980px;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:var(--maxw);margin:16px auto 64px;padding:0 16px}
.scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:8px 12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
.btn{border:1px solid var(--green);color:var(--green);background:transparent;padding:8px 12px;border-radius:10px;cursor:pointer;user-select:none;white-space:nowrap;text-decoration:none;display:inline-block;text-align:center}
.btn:hover{box-shadow:0 0 12px rgba(57,255,20,.3)}
.btn[disabled]{opacity:.5;cursor:not-allowed}
.badge{font-size:12px;opacity:.85;border:1px dashed var(--border);padding:4px 8px;border-radius:6px}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:16px}
.tile{position:relative;border:1px solid var(--border);border-radius:16px;overflow:hidden;background:#050505;min-height:240px}
.tile .img{position:absolute;inset:0;background:#111}
.tile img{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;filter:saturate(1.05) contrast(1.05)}
.tile .cap{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);padding:6px 10px;border-radius:10px;border:1px solid rgba(57,255,20,.25);font-weight:600}
.tile.win{outline:2px solid var(--green-bright);box-shadow:0 0 24px rgba(57,255,20,.35) inset,0 0 32px rgba(57,255,20,.2)}
.pick{display:flex;gap:8px;align-items:center;justify-content:center;padding:12px}
.pill{border:1px solid var(--border);border-radius:999px;overflow:hidden;display:inline-flex}
.pill .seg{padding:8px 12px;cursor:pointer}
.pill .seg.active{background:rgba(57,255,20,.08)}
.note{font-size:12px;opacity:.75}
.bar{height:6px;background:linear-gradient(90deg,#a60000,#0058a6);border-radius:6px;margin:0 8px;flex:1;opacity:.75}
.kv{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.kv .k{opacity:.75}
.kv .v{font-weight:600}
small.muted{opacity:.7}

/* Overlay modal */
.overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.82);z-index:50}
.overlay.show{display:flex}
.overlay-card{position:relative;width:min(920px,96vw);border-radius:18px;border:1px solid var(--border);background:#060606;overflow:hidden;box-shadow:0 0 24px rgba(57,255,20,.15)}
.overlay-art{position:relative;height:min(58vh,520px);background:#000}
.overlay-title{padding:14px 16px 8px;font-size:28px;font-weight:900;letter-spacing:.5px}
.overlay-sub{padding:0 16px 16px;font-size:14px;opacity:.85}
.overlay-x{position:absolute;top:10px;right:10px}
.overlay .scanlines{pointer-events:none}

/* Confetti canvas */
#confetti{position:fixed;inset:0;display:none;z-index:60;pointer-events:none}

/* Analog-ish scanline streaks */
.overlay-art::after{
  content:"";
  position:absolute;inset:0;
  background:
    radial-gradient(ellipse at center, rgba(0,0,0,.0) 0%, rgba(0,0,0,.35) 60%, rgba(0,0,0,.75) 100%),
    repeating-linear-gradient( to bottom, rgba(255,255,255,.05) 0px, rgba(255,255,255,.05) 2px, rgba(0,0,0,0) 3px, rgba(0,0,0,0) 4px );
  mix-blend-mode:overlay;
  pointer-events:none;
}
.overlay-card.tie .overlay-art::before{
  content:"T I E";
  position:absolute;inset:auto 16px 16px auto;color:#fff;font-weight:900;opacity:.2;font-size:40px;letter-spacing:6px
}

/* Misc */
h1{font-size:18px;margin:0;font-weight:800;letter-spacing:.5px}
.timer{font-variant-numeric:tabular-nums;font-weight:900;letter-spacing:1px;min-width:3ch;text-align:right}
.mono{font-family:ui-monospace,Consolas,monospace}
hr{border:none;border-top:1px dashed var(--border);margin:12px 0}
a{color:var(--green);text-decoration-color:rgba(57,255,20,.55)}
.overlay-art{
  background-size:cover; background-position:center; background-repeat:no-repeat;
}
.overlay-art.split{
  background: linear-gradient(90deg,#a60000 50%, #0058a6 50%);
}

/* Subtle scanlines + vignette for analog vibe */
.scanlines{
  position:absolute; inset:0;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(0,0,0,0.25) 0px,
      rgba(0,0,0,0.25) 2px,
      rgba(0,0,0,0.0) 3px,
      rgba(0,0,0,0.0) 4px
    );
  pointer-events:none;
  mix-blend-mode:soft-light;
  opacity:.6;
}
.vignette{
  position:absolute; inset:0;
  background: radial-gradient(circle at center, rgba(0,0,0,0) 40%, rgba(0,0,0,.5) 100%);
  pointer-events:none;
}
</style>
</head>
<body>
<canvas id="confetti"></canvas>
<div class="wrap">
  <div class="scorebar">
    <div class="kv">
      <span class="k">Phase ends:</span>
      <span id="phase" class="v mono">—</span>
    </div>
    <div class="kv">
      <span class="k">Timer:</span>
      <span id="clock" class="v timer">—</span>
    </div>
    <div class="kv">
      <span class="k">State:</span>
      <span id="state" class="v">sync…</span>
    </div>
    <div class="kv"><span class="k">A votes</span><span id="countA" class="v">0</span></div>
    <div class="bar"></div>
    <div class="kv"><span class="k">B votes</span><span id="countB" class="v">0</span></div>
    <div class="kv"><span class="k">You:</span><span id="loginBadge" class="badge">guest</span></div>
  </div>

  <div class="grid">
    <div id="tileA" class="tile">
      <div class="img"><img id="imgA" alt="Entry A"/></div>
      <div class="cap">Entry A</div>
    </div>
    <div id="tileB" class="tile">
      <div class="img"><img id="imgB" alt="Entry B"/></div>
      <div class="cap">Entry B</div>
    </div>
  </div>

  <div class="pick">
    <div class="pill">
      <div id="pickA" class="seg">Vote A</div>
      <div id="pickB" class="seg">Vote B</div>
    </div>
    <button id="submit" class="btn">Submit vote</button>
    <span class="note">Change picks freely until submit.</span>
  </div>

  <hr/>

  <div class="kv" style="gap:12px">
    <button id="pause" class="btn">Pause / Resume</button>
    <button id="force" class="btn">Force decide</button>
    <a href="./winners.html" class="btn">Winners</a>
    <small class="muted">Admin controls shown for dev.</small>
  </div>
</div>

<!-- Overlay -->
<div id="overlay" class="overlay">
  <div class="overlay-card" id="overlayCard">
    <div class="overlay-art" id="overlayArt">
      <div class="scanlines"></div>
      <div class="vignette"></div>
      <button id="overlayClose" class="btn overlay-x">✕</button>
    </div>
    <div class="overlay-title" id="overlayTitle">—</div>
    <div class="overlay-sub" id="overlaySubtitle">—</div>
  </div>
</div>

<script>
/* ======= CONFIG ======= */
const SUPABASE_URL  = window.SUPABASE_URL  || 'https://YOUR.supabase.co';
const SUPABASE_ANON = window.SUPABASE_ANON || 'YOUR_ANON';
const EDGE_FN = 'dynamic-task'; // your Edge Function name
const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

// Elements
const phaseEl = document.getElementById('phase');
const clockEl = document.getElementById('clock');
const stateEl = document.getElementById('state');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');
const pickA  = document.getElementById('pickA');
const pickB  = document.getElementById('pickB');
const submitBtn = document.getElementById('submit');
const pauseBtn  = document.getElementById('pause');
const forceBtn  = document.getElementById('force');
const tileA = document.getElementById('tileA');
const tileB = document.getElementById('tileB');
const imgA  = document.getElementById('imgA');
const imgB  = document.getElementById('imgB');

const overlay = document.getElementById('overlay');
const overlayCard = document.getElementById('overlayCard');
const overlayArt  = document.getElementById('overlayArt');
const overlayTitle= document.getElementById('overlayTitle');
const overlaySubtitle = document.getElementById('overlaySubtitle');
const confetti = document.getElementById('confetti');

// State
let serverPhaseEndISO = null;
let lastFinishedKey = null;
let paused = false;
let chosen = null;
let currentUid = null;
let lastCountsAt = 0;

/* ======= HELPERS ======= */
const $ = (q)=>document.querySelector(q);
const toIso = (d)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,'Z');
const fmtVotes = (n)=> `${n} vote${n===1?'':'s'}`;

function toast(msg){
  console.log('[toast]', msg);
}

// quick auth helper for badge (anon ok)
function paintLoginBadge(){
  const el = document.getElementById('loginBadge');
  el.textContent = currentUid ? currentUid.slice(0,8) : 'guest';
}

/* ======= WINNER / TIE VISUALS ======= */
function clearWinFX(){ tileA.classList.remove('win'); tileB.classList.remove('win'); }
function playWinnerFX(color){
  clearWinFX();
  if(color==='red') tileA.classList.add('win');
  if(color==='blue') tileB.classList.add('win');
  openWinnerOverlay(color);
}
function showTieBanner(){
  clearWinFX();
  openTieOverlay();
}

/* Overlay open/close */
function openWinnerOverlay(color){
  const src = (color==='red') ? imgA.src : imgB.src;
  overlayArt.className = 'overlay-art';
  overlayArt.style.backgroundImage = `url("${src}")`;
  overlayCard.className = 'overlay-card';
  overlayTitle.textContent = 'CHAMPION';
  overlaySubtitle.textContent = (color==='red' ? 'Entry A prevails' : 'Entry B prevails');
  overlay.classList.add('show');
  startConfetti({mode:'win'});
}
function openTieOverlay(){
  overlayArt.className = 'overlay-art split';
  overlayArt.style.backgroundImage = '';
  overlayCard.className = 'overlay-card tie';
  overlayTitle.textContent = 'TIE';
  overlaySubtitle.textContent = 'No winner for this round';
  overlay.classList.add('show');
  startConfetti({mode:'tie'});
}
function playTieRandomFX(color){
  clearWinFX();
  if(color==='red') tileA.classList.add('win');
  if(color==='blue') tileB.classList.add('win');
  openTieRandomOverlay(color);
}

function openTieRandomOverlay(color){
  const src = (color==='red') ? imgA.src : imgB.src;
  overlayArt.className = 'overlay-art';
  overlayArt.style.backgroundImage = `url("${src}")`;
  overlayCard.className = 'overlay-card';
  const which = (color==='red') ? 'Entry A' : 'Entry B';
  overlayTitle.textContent = `Tie... random winner picked: ${which}`;
  overlaySubtitle.textContent = (color==='red' ? 'Entry A prevails' : 'Entry B prevails');
  overlay.classList.add('show');
  startConfetti({mode:'win'});
}
function closeOverlay(){
  overlay.classList.remove('show');
  stopConfetti();
}
document.getElementById('overlayClose').addEventListener('click', closeOverlay);

/* Cyberpunk/analog confetti (pixel shards + flicker) */
function startConfetti({mode='win'}={}){
  const ctx = confetti.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const resize = ()=>{
    confetti.width = Math.floor(innerWidth * dpr);
    confetti.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  };
  resize(); confetti.style.display='block';
  let parts = Array.from({length:160}, (_,i)=>({
    x: Math.random()*innerWidth,
    y: Math.random()*innerHeight,
    vx:(Math.random()-.5)*3,
    vy:(Math.random()*-2)-1,
    s: Math.random()*3+1,
    a: 1,
    t: Math.random()*Math.PI*2
  }));
  let raf;
  const tick = ()=>{
    ctx.clearRect(0,0,confetti.width,confetti.height);
    parts.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.03; p.a*=.995; p.t+=.05;
      ctx.globalAlpha = Math.max(p.a,0);
      ctx.fillRect(p.x, p.y, p.s, p.s);
    });
    raf = requestAnimationFrame(tick);
  };
  window.addEventListener('resize', resize);
  tick();
  confetti._stop = ()=>{ cancelAnimationFrame(raf); confetti.style.display='none'; ctx.clearRect(0,0,confetti.width,confetti.height); };
}
function stopConfetti(){ confetti._stop && confetti._stop(); }

/* ======= IMAGE SEEDING ======= */
function seedUrl(phaseKeyISO, suffix){
  // Deterministic "random" artsy photos per phase
  const s = encodeURIComponent(`${phaseKeyISO}-${suffix}`);
  // Bigger than tile to look crisp in overlay too
  return `https://picsum.photos/seed/${s}/1600/1200`;
}
function setImagesForPhase(phaseKeyISO){
  imgA.src = seedUrl(phaseKeyISO, 'A');
  imgB.src = seedUrl(phaseKeyISO, 'B');
}

/* ======= STATE FETCH / TIMER ======= */
async function fetchState(){
  const { data, error } = await client
    .from('shared_timer')
    .select('phase_end, state, paused')
    .limit(1);

  if (error) throw error;
  const row = data?.[0];
  if (!row){ phaseEl.textContent='—'; clockEl.textContent='—'; stateEl.textContent='—'; return; }

  serverPhaseEndISO = row.phase_end;
  phaseEl.textContent = new Date(serverPhaseEndISO).toLocaleString();
  paused = !!row.paused;
  stateEl.textContent = row.state || '—';

  // immediately seed images for current phase
  setImagesForPhase(toIso(serverPhaseEndISO));
}

function secondsLeft(){
  if (!serverPhaseEndISO) return 0;
  const now = Date.now();
  const end = new Date(serverPhaseEndISO).getTime();
  return Math.max(0, Math.ceil((end - now)/1000));
}

let tickRaf;
async function tick(){
  if (paused){ clockEl.textContent = 'PAUSE'; tickRaf=requestAnimationFrame(tick); return; }
  const s = secondsLeft();
  clockEl.textContent = s.toString().padStart(2,'0');

  // Update live counts ~every 1.5s
  if (Date.now() - lastCountsAt > 1500) { await refreshCounts(); }

  if (s<=0){
    await onZero();
  }else{
    tickRaf=requestAnimationFrame(tick);
  }
}

async function onZero(){
  cancelAnimationFrame(tickRaf);
  clockEl.textContent = '00';
  // read the finished key (the phase we just ended)
  lastFinishedKey = toIso(serverPhaseEndISO);
  try{
    await finalizeWinnerForKey(lastFinishedKey);
  }catch(e){}
}

async function start(){ cancelAnimationFrame(tickRaf); await fetchState(); tick(); }
async function refreshCounts(){
  try{
    if (!serverPhaseEndISO){ countA.textContent = '0 votes'; countB.textContent = '0 votes'; return; }
    const phaseKey = toIso(serverPhaseEndISO);
    const { r, b } = await countVotesForPhase(phaseKey);
    countA.textContent  = fmtVotes(r);
    countB.textContent  = fmtVotes(b);
    lastCountsAt = Date.now();
  }catch(e){}
}

/* ======= IMAGE SEEDING ======= */
function seedUrl(phaseKeyISO, suffix){
  // Deterministic "random" artsy photos per phase
  const s = encodeURIComponent(`${phaseKeyISO}-${suffix}`);
  // Bigger than tile to look crisp in overlay too
  return `https://picsum.photos/seed/${s}/1600/1200`;
}
function setImagesForPhase(phaseKeyISO){
  imgA.src = seedUrl(phaseKeyISO, 'A');
  imgB.src = seedUrl(phaseKeyISO, 'B');
}

/* ======= DATA OPS ======= */
async function callEdge(method='POST', body){
  const res = await fetch(`${SUPABASE_URL}/functions/v1/${EDGE_FN}`, {
    method,
    headers: { 'Authorization': `Bearer ${SUPABASE_ANON}`, 'Content-Type':'application/json' },
    body: body ? JSON.stringify(body) : undefined
  });
  if (!res.ok) throw new Error('edge fail');
  return res.json().catch(()=>({}));
}

async function getSession(){
  const { data:{ session } } = await client.auth.getSession();
  return session;
}

async function ensureAuth(){
  const { data: { user } } = await client.auth.getUser();
  if (user){ currentUid = user.id; paintLoginBadge(); return; }
  const res = await client.auth.signInAnonymously();
  if (!res?.data?.user) throw new Error('auth');
  currentUid = res.data.user.id; paintLoginBadge();
}

async function submitVote(color){
  if (!currentUid || !serverPhaseEndISO) return;
  const phaseKey = toIso(serverPhaseEndISO);
  const { error } = await client.from('phase_votes').upsert({
    phase_key: phaseKey,
    user_id: currentUid,
    vote: color
  }, { onConflict: 'phase_key,user_id' });
  if (error){ toast('vote failed'); return; }
  toast('vote submitted');
  await refreshCounts();
}

async function clearMyVote(){
  if (!currentUid || !serverPhaseEndISO) return;
  const phaseKey = toIso(serverPhaseEndISO);
  await client.from('phase_votes').delete().match({ phase_key: phaseKey, user_id: currentUid });
}

async function refreshPickUI(){
  pickA.classList.toggle('active', chosen==='red');
  pickB.classList.toggle('active', chosen==='blue');
  submitBtn.disabled = !chosen || !currentUid;
}

async function countVotesForPhase(phaseKeyISO){
  const { data, error } = await client.from('phase_votes').select('vote').eq('phase_key', phaseKeyISO);
  if (error) throw error;
  let r=0, b=0; (data||[]).forEach(row => { if(row.vote==='red') r++; else if(row.vote==='blue') b++; });
  return {r,b};
}

/* ======= DECISION ======= */
async function finalizeWinnerForKey(phaseKeyISO){
  try{
    const { r, b } = await countVotesForPhase(phaseKeyISO);

    // If a row already exists, just show it (if tie, show tie-random banner with stored color)
    {
      const { data, error } = await client
        .from('winners')
        .select('color')
        .eq('phase_key', phaseKeyISO)
        .limit(1);
      if (error) throw error;

      const existing = (data?.[0]?.color || '').toLowerCase();
      if (existing === 'red' || existing === 'blue'){
        if (r === b) { playTieRandomFX(existing); return; }
        playWinnerFX(existing);
        return;
      }
    }

    // Decide winner (tie => random)
    let color;
    if (r === b){
      color = (Math.random() < 0.5) ? 'red' : 'blue';
    } else {
      color = (r > b) ? 'red' : 'blue';
    }

    // Try to write
    const { error: insErr } = await client
      .from('winners')
      .insert({ phase_key: phaseKeyISO, color })
      .select()
      .single();

    if (insErr){
      // Someone else may have written; read back
      const { data } = await client
        .from('winners')
        .select('color')
        .eq('phase_key', phaseKeyISO)
        .limit(1);
      const c = (data?.[0]?.color || '').toLowerCase();

      if (r === b && (c === 'red' || c === 'blue')) { playTieRandomFX(c); return; }
      if (c === 'red' || c === 'blue') { playWinnerFX(c); return; }

      // Fallback display only
      if (r === b){ playTieRandomFX(color); return; }
      playWinnerFX(color);
      return;
    }

    if (r === b) playTieRandomFX(color);
    else playWinnerFX(color);

  }catch(e){
    // Robust fallbacks
    try{
      const { r, b } = await countVotesForPhase(phaseKeyISO);
      const { data } = await client
        .from('winners')
        .select('color')
        .eq('phase_key', phaseKeyISO)
        .limit(1);
      const c = (data?.[0]?.color || '').toLowerCase();
      if (r === b && (c==='red'||c==='blue')) playTieRandomFX(c);
      else if (c==='red'||c==='blue') playWinnerFX(c);
      else if (r === b) playTieRandomFX((Math.random()<0.5)?'red':'blue');
      else playWinnerFX((r>b)?'red':'blue');
    }catch(_){}
  }
}

/* --- Realtime: winners --- */
client.channel('winners-phase')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners'}, async (payload)=>{
  const rowKey = payload?.new?.phase_key;
  const color  = (payload?.new?.color || '').toLowerCase();
  if (!rowKey || !lastFinishedKey) return;
  if (toIso(rowKey) !== toIso(lastFinishedKey)) return;

  try{
    const { r, b } = await countVotesForPhase(lastFinishedKey);
    if (r === b && (color==='red' || color==='blue')) { playTieRandomFX(color); return; }
    if (color === 'red' || color === 'blue'){ playWinnerFX(color); }
  }catch(_){
    if (color === 'red' || color === 'blue') playWinnerFX(color);
  }
}).subscribe();

/* --- Realtime: live vote counts for current phase --- */
client.channel('votes-phase')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'phase_votes'}, refreshCounts)
  .on('postgres_changes',{event:'UPDATE',schema:'public',table:'phase_votes'}, refreshCounts)
  .on('postgres_changes',{event:'DELETE',schema:'public',table:'phase_votes'}, refreshCounts)
  .subscribe();

/* ======= UI PICK / SUBMIT ======= */
pickA.onclick = ()=>{ chosen='red'; refreshPickUI(); };
pickB.onclick = ()=>{ chosen='blue'; refreshPickUI(); };
submitBtn.onclick = async ()=>{ if (chosen) await submitVote(chosen); };

/* ======= CONTROLS ======= */
pauseBtn.onclick = async ()=>{
  try{
    const res = await callEdge('POST',{togglePause:true});
    paused = !!res?.paused; stateEl.textContent = res?.state ?? stateEl.textContent;
    toast('OK');
  }catch(e){ toast('Pause/resume failed'); }
};
forceBtn.onclick = async ()=>{
  try{
    await callEdge('POST',{force:true});
    await fetchState();
    toast('Forced decision');
  }catch(e){ toast('Force failed'); }
};

/* ======= BOOT ======= */
(async ()=>{
  try{
    await ensureAuth();
    client.auth.onAuthStateChange((_event, session)=>{
      currentUid = session?.user?.id ?? null;
      paintLoginBadge();
      submitBtn.disabled = !chosen || !currentUid;
    });
    await fetchState(); 
    // Ensure images set immediately on first load if state present
    if (serverPhaseEndISO) setImagesForPhase(toIso(serverPhaseEndISO));
    await start();
  }catch(e){
    clockEl.textContent='ERR'; stateEl.textContent='ERR';
  }
})();
</script>
</body>
</html>