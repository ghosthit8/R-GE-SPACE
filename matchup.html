<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Supabase Global 10s Timer</title>
  <style>
    html,body { height:100%; margin:0; font-family:system-ui, Arial, sans-serif; background:#0b0b0b; color:#fff; }
    .wrap { height:100%; display:grid; place-items:center; gap:16px; }
    .clock { font-size: clamp(48px, 12vw, 160px); font-weight: 800; letter-spacing: 0.02em; }
    .row { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
    button { background:#1f1f1f; color:#fff; border:1px solid #333; border-radius:10px; padding:8px 12px; cursor:pointer; }
    button:hover { background:#262626; }
    .muted { opacity:0.7; font-size:14px; }
    .tag { font-size:12px; padding:2px 6px; border:1px solid #444; border-radius:999px; }
    .error { color:#ff6b6b; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="clock" id="clock">—</div>
    <div class="row">
      <button id="refresh">Sync</button>
      <button id="force">Force next (test)</button>
      <button id="pause">Pause</button>
      <span class="muted" id="info"></span>
      <span class="tag" id="status">LIVE</span>
    </div>
  </div>

  <script>
    // Your Edge Function URL (public or include auth headers if Verify JWT is ON)
    const EDGE_URL = "https://tuqvpcevrhciursxrgav.supabase.co/functions/v1/global-timer";
    // If Verify JWT is ON, uncomment and add headers in fetch calls:
    // const ANON = "YOUR_SUPABASE_ANON_KEY";
    // const AUTH = { apikey: ANON, Authorization: `Bearer ${ANON}` };

    let phaseEndISO = null;     // authoritative end time from server
    let periodSec   = 10;
    let serverPaused = false;   // authoritative pause flag from server
    let lastSyncAt  = 0;

    // UI + freeze buffer
    const clockEl  = document.getElementById('clock');
    const infoEl   = document.getElementById('info');
    const statusEl = document.getElementById('status');
    const pauseBtn = document.getElementById('pause');
    let frozenSecs = null;      // number to display while paused (frozen)

    function remainingSecsFromNow() {
      if (!phaseEndISO) return null;
      const endMs = Date.parse(phaseEndISO);
      const remMs = Math.max(0, endMs - Date.now());
      return Math.ceil(remMs / 1000);
    }

    function setPausedUI() {
      statusEl.textContent = 'PAUSED';
      pauseBtn.textContent = 'Resume';
    }
    function setLiveUI() {
      statusEl.textContent = 'LIVE';
      pauseBtn.textContent = 'Pause';
    }

    function applyState(json) {
      const s = json.state;
      phaseEndISO  = s.phase_end_at;
      periodSec    = s.period_sec;
      const wasPaused = serverPaused;
      serverPaused = !!s.paused;

      // if we just transitioned into paused (from server or after POST), capture the current number
      if (!wasPaused && serverPaused) {
        frozenSecs = remainingSecsFromNow();
      }
      // if we just resumed, clear the freeze
      if (wasPaused && !serverPaused) {
        frozenSecs = null;
      }

      if (serverPaused) setPausedUI(); else setLiveUI();

      infoEl.textContent =
        `period=${periodSec}s | phase_end_at=${phaseEndISO} | paused=${serverPaused}`;
      lastSyncAt = Date.now();
    }

    async function callAPI(method = 'GET', body = null) {
      const res = await fetch(EDGE_URL, {
        method,
        headers: {
          'Content-Type': 'application/json',
          // ...AUTH,
        },
        body: body ? JSON.stringify(body) : null
      });
      const txt = await res.text();
      let json;
      try { json = JSON.parse(txt); } catch { throw new Error('Server did not return JSON'); }
      if (!res.ok) throw new Error(json?.error || res.statusText);
      return json;
    }

    async function fetchState() {
      const json = await callAPI('GET');
      applyState(json);
    }

    function tick() {
      if (serverPaused) {
        // show the exact frozen number captured at pause time
        if (typeof frozenSecs === 'number' && isFinite(frozenSecs)) {
          clockEl.textContent = String(frozenSecs);
        } else {
          // fallback if we didn't capture yet
          const nowFreeze = remainingSecsFromNow();
          frozenSecs = nowFreeze ?? 0;
          clockEl.textContent = String(frozenSecs);
        }
      } else if (phaseEndISO) {
        const secs = remainingSecsFromNow();
        clockEl.textContent = String(secs ?? '…');

        // re-sync at zero so the server can roll forward
        if ((secs ?? 0) <= 0) {
          fetchState().catch(console.error);
        }
      } else {
        clockEl.textContent = '…';
      }

      // background re-sync every ~5s to catch external changes
      if (Date.now() - lastSyncAt > 5000) {
        fetchState().catch(console.warn);
      }

      requestAnimationFrame(tick);
    }

    // Buttons
    document.getElementById('refresh').addEventListener('click', () =>
      fetchState().catch(err => alert(err.message))
    );

    document.getElementById('force').addEventListener('click', async () => {
      try {
        const json = await callAPI('POST', { force: true });
        applyState(json);
      } catch (e) { alert(e.message); }
    });

    // Toggle GLOBAL pause/resume
    pauseBtn.addEventListener('click', async () => {
      try {
        const desired = !serverPaused;

        // optimistic UI: capture number and flip immediately
        if (desired) {
          frozenSecs = remainingSecsFromNow();
          setPausedUI();
        } else {
          frozenSecs = null;
          setLiveUI();
        }
        serverPaused = desired;

        // tell the server
        const json = await callAPI('POST', { pause: desired });
        // reconcile with server truth (in case of race)
        applyState(json);
      } catch (e) {
        alert(e.message);
        // recover by pulling the authoritative state
        fetchState().catch(console.error);
      }
    });

    // boot
    fetchState().then(draw).catch((e) => {
      clockEl.textContent = 'ERR';
      infoEl.textContent = e.message;
      infoEl.classList.add('error');
      console.error(e);
    });

    function draw() { tick(); } // alias for readability
  </script>
</body>
</html>