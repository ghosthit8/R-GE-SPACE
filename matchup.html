<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rage Space — Matchup (4-up, 2-up view)</title>
  <style>
    :root { --fg:#e5e7eb; --bg:#0b0d0f; --accent:#39ff14; --muted:#8b8b8b; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,Segoe UI,Roboto,Inter,ui-sans-serif; }
    .wrap { max-width:700px; margin:0 auto; padding:16px 12px 96px; }
    h1 { margin:0 0 10px; font-size:20px; font-weight:700; letter-spacing:.5px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .timer { font-variant-numeric: tabular-nums; font-weight:700; font-size:32px; line-height:1; padding:8px 14px; border:1px solid #20242a; border-radius:12px; background:#0f1318; }
    .state { color:var(--muted); font-size:12px; }

    .card { margin-top:12px; border:1px solid #20242a; border-radius:16px; overflow:hidden; background:#0f1318; }
    .imgBox { position:relative; width:100%; aspect-ratio:3/4; background:#111; display:grid; place-items:center; }
    .imgBox img { width:100%; height:100%; object-fit:cover; display:block; }
    .fullscreenBtn { position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.55); color:var(--accent); border:1px solid var(--accent); border-radius:8px; font-size:14px; padding:4px 8px; cursor:pointer; font-weight:700; }
    .bar { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; gap:8px; border-top:1px solid #20242a; }
    .label { text-transform:uppercase; letter-spacing:.12em; font-weight:700; font-size:12px; color:#a1a1a1; }
    .counts { font-variant-numeric: tabular-nums; font-weight:700; }
    .btn, .vote, .linkbtn, .backbtn { appearance:none; border:1px solid #24303a; background:#131920; color:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:700; text-decoration:none; display:inline-flex; align-items:center; }
    .btn.ghost { color:#a0aec0; }
    button.vote { padding:10px 14px; }
    button.vote:disabled { opacity:.6; cursor:default; }

    .thumbs-wrap { margin-top:16px; }
    .thumbs-title { font-size:12px; opacity:.6; margin-bottom:6px; }
    .thumbs { display:flex; gap:10px; flex-wrap:wrap; }
    .thumb { width:110px; border:1px solid #20242a; border-radius:12px; overflow:hidden; background:#0f1318; cursor:pointer; }
    .thumb.active { border-color:var(--accent); box-shadow:0 0 0 1px rgba(57,255,20,.3); }
    .thumb-img { width:100%; aspect-ratio:3/4; background:#111; display:grid; place-items:center; }
    .thumb-img img { width:100%; height:100%; object-fit:cover; }
    .thumb-label { padding:4px 6px 6px; font-size:11px; display:flex; justify-content:space-between; align-items:center; }
    .thumb-count { font-variant-numeric: tabular-nums; font-weight:700; }

    .winner { margin-top:14px; padding:10px 12px; border:1px dashed #2a343f; border-radius:12px; color:#cbd5e1; font-size:14px; }
    .winner b { color:#39ff14; }

    /* FINAL BOX */
    .final-card { margin-top:14px; }
    .final-inner { display:flex; gap:12px; flex-wrap:wrap; padding:12px; }
    .final-slot { flex:1 1 150px; background:#0b0f13; border:1px dashed #20242a; border-radius:10px; padding:8px; text-align:center; }
    .final-slot .label { display:block; margin-bottom:4px; }
    .final-slot .thumb-final { width:100%; aspect-ratio:3/4; background:#000; border-radius:8px; overflow:hidden; display:grid; place-items:center; }
    .final-slot .thumb-final img { width:100%; height:100%; object-fit:cover; }
    .final-footer { padding:0 12px 12px; font-size:12px; color:#9aa0a6; }

    .fullscreen-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); justify-content:center; align-items:center; z-index:9999; }
    .fullscreen-overlay img { max-width:90%; max-height:90%; border-radius:8px; }
    .fullscreen-overlay button { position:absolute; top:20px; right:20px; background:#111; border:1px solid var(--accent); color:var(--accent); padding:6px 10px; border-radius:6px; font-weight:700; cursor:pointer; }
    .hint { margin-top:10px; color:#9aa0a6; font-size:12px; }
    .debugbox { position:fixed; left:0; right:0; bottom:0; background:rgba(0,0,0,.75); color:#9ca3af; font-size:11px; padding:6px 10px; border-top:1px solid #111; }
    #thumbFinal { display:none; }
  </style>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="wrap">
    <h1>Rage Space — Matchup (4-up, 2-up view)</h1>

    <div class="header">
      <div class="row">
        <div class="timer" id="tRemain">60.0</div>
        <div class="state" id="tMeta">syncing…</div>
      </div>
      <div class="row">
        <button id="forceQueue" class="btn ghost">Pull Now</button>
        <button id="resetPair" class="btn ghost">Reset Pair</button>
        <a class="backbtn" href="menu.html">← Menu</a>
        <a class="linkbtn" href="winners.html">Winners</a>
      </div>
    </div>

    <!-- ACTIVE MATCH AREA -->
    <div class="card" id="activeTop">
      <div class="imgBox">
        <img id="imgActive1" alt="Active seed 1">
        <button class="fullscreenBtn" onclick="openFull('active1')">⤢</button>
      </div>
      <div class="bar">
        <div class="label" id="labelActive1">Seed A</div>
        <div class="counts" id="countActive1">0</div>
        <button class="vote" id="btnActive1">Vote</button>
      </div>
    </div>

    <div class="card" id="activeBottom">
      <div class="imgBox">
        <img id="imgActive2" alt="Active seed 2">
        <button class="fullscreenBtn" onclick="openFull('active2')">⤢</button>
      </div>
      <div class="bar">
        <div class="label" id="labelActive2">Seed B</div>
        <div class="counts" id="countActive2">0</div>
        <button class="vote" id="btnActive2">Vote</button>
      </div>
    </div>

    <!-- OTHER MATCHES -->
    <div class="thumbs-wrap">
      <div class="thumbs-title">Other round</div>
      <div class="thumbs">
        <div class="thumb" id="thumbAB">
          <div class="thumb-img"><img id="thumbABimg" alt="A vs B"></div>
          <div class="thumb-label">
            <span>A vs B</span>
            <span class="thumb-count" id="thumbABcount">0-0</span>
          </div>
        </div>
        <div class="thumb" id="thumbCD">
          <div class="thumb-img"><img id="thumbCDimg" alt="C vs D"></div>
          <div class="thumb-label">
            <span>C vs D</span>
            <span class="thumb-count" id="thumbCDcount">0-0</span>
          </div>
        </div>
        <div class="thumb" id="thumbFinal">
          <div class="thumb-img"><img id="thumbFinalImg" alt="Final"></div>
          <div class="thumb-label">
            <span>Final</span>
            <span class="thumb-count" id="thumbFinalCount">0-0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="winner" id="winnerText">No winner yet — semis running.</div>

    <!-- FINAL BOX -->
    <div class="card final-card" id="finalCard">
      <div class="bar">
        <div class="label">Final</div>
        <div style="font-size:12px;color:#a1a1a1;">Decides at 0s</div>
      </div>
      <div class="final-inner">
        <div class="final-slot">
          <span class="label">Winner of A vs B</span>
          <div class="thumb-final">
            <img id="finalImg1" alt="Final slot 1">
          </div>
        </div>
        <div class="final-slot">
          <span class="label">Winner of C vs D</span>
          <div class="thumb-final">
            <img id="finalImg2" alt="Final slot 2">
          </div>
        </div>
      </div>
      <div class="final-footer" id="finalFooter">Waiting for semis…</div>
    </div>

    <div class="hint">
      4 images → 2 semis → one semi at a time. At ~30s we lock semis & show Final; at 0s we record the winner.
    </div>
  </div>

  <div class="fullscreen-overlay" id="overlay">
    <button id="closeFull">✕ Close</button>
    <img id="fullImg" src="">
  </div>

  <div class="debugbox" id="debugBox">debug: idle…</div>

  <script>
    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const FUNCTION_URL = `${SUPABASE_URL}/functions/v1/global-timer-v2`;

    const RSID_KEY = "rsid_v2";
    let RSID = localStorage.getItem(RSID_KEY);
    if (!RSID) { RSID = (crypto.randomUUID?.() || Math.random().toString(36).slice(2)+Date.now()); localStorage.setItem(RSID_KEY, RSID); }

    const elRemain = document.getElementById("tRemain");
    const elMeta   = document.getElementById("tMeta");
    const dbg      = document.getElementById("debugBox");
    const winnerText = document.getElementById("winnerText");

    const imgActive1 = document.getElementById("imgActive1");
    const imgActive2 = document.getElementById("imgActive2");
    const labelActive1 = document.getElementById("labelActive1");
    const labelActive2 = document.getElementById("labelActive2");
    const countActive1 = document.getElementById("countActive1");
    const countActive2 = document.getElementById("countActive2");
    const btnActive1 = document.getElementById("btnActive1");
    const btnActive2 = document.getElementById("btnActive2");

    const thumbAB = document.getElementById("thumbAB");
    const thumbABimg = document.getElementById("thumbABimg");
    const thumbABcount = document.getElementById("thumbABcount");
    const thumbCD = document.getElementById("thumbCD");
    const thumbCDimg = document.getElementById("thumbCDimg");
    const thumbCDcount = document.getElementById("thumbCDcount");
    const thumbFinal = document.getElementById("thumbFinal");
    const thumbFinalImg = document.getElementById("thumbFinalImg");
    const thumbFinalCount = document.getElementById("thumbFinalCount");

    const finalImg1 = document.getElementById("finalImg1");
    const finalImg2 = document.getElementById("finalImg2");
    const finalFooter = document.getElementById("finalFooter");

    const overlay  = document.getElementById("overlay");
    const fullImg  = document.getElementById("fullImg");
    const btnClose = document.getElementById("closeFull"); btnClose.onclick = () => overlay.style.display = 'none';

    const forceBtn = document.getElementById("forceQueue");
    const resetBtn = document.getElementById("resetPair");

    function placeholder(letter){
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="720" height="960"><rect width="100%" height="100%" fill="#000"/><text x="50%" y="50%" fill="#39ff14" font-size="90" font-family="monospace" text-anchor="middle" dominant-baseline="middle">${letter}</text></svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    let state = {
      base_iso: null, ends_at: null, period_sec: 60,
      seed_a_url: null, seed_b_url: null, seed_c_url: null, seed_d_url: null,
      seed_a_count: 0, seed_b_count: 0, seed_c_count: 0, seed_d_count: 0,
      mid_done: false, mid_winner_1_url: null, mid_winner_2_url: null,
    };

    // ---------- VOTE MEMORY ----------
    const VOTE_MEMORY_KEY = "rs_vote_memory_v2";
    function readMem(baseIso){ try { return JSON.parse(localStorage.getItem(VOTE_MEMORY_KEY)||"{}")[baseIso]||{}; } catch { return {}; } }
    function writeMem(baseIso,key,val){ const all = (()=>{try{return JSON.parse(localStorage.getItem(VOTE_MEMORY_KEY)||"{}");}catch{return {};}})(); all[baseIso]=Object.assign({},all[baseIso]||{}, {[key]:val}); localStorage.setItem(VOTE_MEMORY_KEY, JSON.stringify(all)); }
    function pruneVoteMem(keep){ const all = (()=>{try{return JSON.parse(localStorage.getItem(VOTE_MEMORY_KEY)||"{}");}catch{return {};}})(); for(const k of Object.keys(all)) if(k!==keep) delete all[k]; localStorage.setItem(VOTE_MEMORY_KEY, JSON.stringify(all)); }
    function phaseKeyFor(active){ if (state.mid_done) return "ab_final"; const g = active==="cd" ? "cd" : "ab"; return `${g}_semi`; }

    // ---------- SEMI SNAPSHOT ----------
    const SEMI_SNAPSHOT_KEY = "rs_semi_snapshot_v2";
    function readSnap(baseIso){ try { return JSON.parse(localStorage.getItem(SEMI_SNAPSHOT_KEY)||"{}")[baseIso]||null; } catch { return null; } }
    function writeSnap(baseIso, snap){ const all = (()=>{try{return JSON.parse(localStorage.getItem(SEMI_SNAPSHOT_KEY)||"{}");}catch{return {};}})(); all[baseIso]=snap; localStorage.setItem(SEMI_SNAPSHOT_KEY, JSON.stringify(all)); }
    function pruneSnap(keep){ const all = (()=>{try{return JSON.parse(localStorage.getItem(SEMI_SNAPSHOT_KEY)||"{}");}catch{return {};}})(); for(const k of Object.keys(all)) if(k!==keep) delete all[k]; localStorage.setItem(SEMI_SNAPSHOT_KEY, JSON.stringify(all)); }

    function ensureSemiSnapshot(){
      if (!state.base_iso || state.mid_done) return;
      const existing = readSnap(state.base_iso) || { ab:{}, cd:{} };
      const next = {
        ab: { a_url: state.seed_a_url, b_url: state.seed_b_url, a_count: state.seed_a_count, b_count: state.seed_b_count },
        cd: { c_url: state.seed_c_url, d_url: state.seed_d_url, c_count: state.seed_c_count, d_count: state.seed_d_count }
      };
      const changed =
        !existing.ab ||
        existing.ab.a_url !== next.ab.a_url ||
        existing.ab.b_url !== next.ab.b_url ||
        existing.ab.a_count !== next.ab.a_count ||
        existing.ab.b_count !== next.ab.b_count ||
        !existing.cd ||
        existing.cd.c_url !== next.cd.c_url ||
        existing.cd.d_url !== next.cd.d_url ||
        existing.cd.c_count !== next.cd.c_count ||
        existing.cd.d_count !== next.cd.d_count;
      if (changed) writeSnap(state.base_iso, next);
    }

    async function recoverSemisFromWinners(){
      if (!state.base_iso || !state.mid_done) return;
      const snap = readSnap(state.base_iso);
      const zeroAB = !snap || ((snap.ab?.a_count ?? 0) === 0 && (snap.ab?.b_count ?? 0) === 0);
      const zeroCD = !snap || ((snap.cd?.c_count ?? 0) === 0 && (snap.cd?.d_count ?? 0) === 0);
      if (snap && !zeroAB && !zeroCD) return;
      try {
        const res = await fetch(`${FUNCTION_URL}?winners=1&limit=50`);
        const data = await res.json();
        const list = Array.isArray(data.winners) ? data.winners : [];
        const s1 = list.find(w => w.base_iso === state.base_iso + "::semi1");
        const s2 = list.find(w => w.base_iso === state.base_iso + "::semi2");
        const next = {
          ab: {
            a_url: (snap?.ab?.a_url) || state.seed_a_url || state.mid_winner_1_url || placeholder("?"),
            b_url: (snap?.ab?.b_url) || state.seed_b_url || placeholder("?"),
            a_count: s1?.red_count  ?? snap?.ab?.a_count ?? 0,
            b_count: s1?.blue_count ?? snap?.ab?.b_count ?? 0,
          },
          cd: {
            c_url: (snap?.cd?.c_url) || state.seed_c_url || state.mid_winner_2_url || placeholder("?"),
            d_url: (snap?.cd?.d_url) || state.seed_d_url || placeholder("?"),
            c_count: s2?.red_count  ?? snap?.cd?.c_count ?? 0,
            d_count: s2?.blue_count ?? snap?.cd?.d_count ?? 0,
          }
        };
        writeSnap(state.base_iso, next);
        renderActive();
      } catch (e) {
        console.log("recoverSemisFromWinners error", e);
      }
    }

    // ---------- FINAL LABELS (NEW) ----------
    function computeFinalLabels(){
      const snap = readSnap(state.base_iso || "");
      let left = "Final — slot 1";
      let right = "Final — slot 2";
      if (snap) {
        if (state.mid_winner_1_url) {
          if (snap.ab?.a_url && state.mid_winner_1_url === snap.ab.a_url) left = "Seed A";
          else if (snap.ab?.b_url && state.mid_winner_1_url === snap.ab.b_url) left = "Seed B";
        }
        if (state.mid_winner_2_url) {
          if (snap.cd?.c_url && state.mid_winner_2_url === snap.cd.c_url) right = "Seed C";
          else if (snap.cd?.d_url && state.mid_winner_2_url === snap.cd.d_url) right = "Seed D";
        }
      }
      return { left, right };
    }

    // ---------- APPLY VOTE MEMORY (PATCHED for Final labels) ----------
    function applyVoteMemory(){
      const mem = readMem(state.base_iso||"");
      const key = phaseKeyFor(activeMatch);

      if (activeMatch === "final") {
        const { left, right } = computeFinalLabels();
        const picked = mem[key];
        labelActive1.textContent = left  + (picked==="red"  ? " • you voted" : "");
        labelActive2.textContent = right + (picked==="blue" ? " • you voted" : "");
      } else {
        const baseLA1 = (activeMatch==="cd")?"Seed C":"Seed A";
        const baseLA2 = (activeMatch==="cd")?"Seed D":"Seed B";
        const picked = mem[key];
        labelActive1.textContent = baseLA1 + (picked==="red" ?" • you voted":"");
        labelActive2.textContent = baseLA2 + (picked==="blue"?" • you voted":"");
      }

      const already = (mem[key] === "red" || mem[key] === "blue");
      btnActive1.disabled = already;
      btnActive2.disabled = already;
    }

    // triggers
    let semiTriggered = false, finalTriggered = false, lastSemiPoll = 0;
    let fetching = false;
    let activeMatch = "ab"; // "ab" | "cd" | "final"

    function renderFinal() {
      if (!state.mid_done) {
        finalImg1.src = placeholder("?");
        finalImg2.src = placeholder("?");
        finalFooter.textContent = "Waiting for semis…";
        thumbFinal.style.display = "none";
        return;
      }
      finalImg1.src = state.mid_winner_1_url || placeholder("?");
      finalImg2.src = state.mid_winner_2_url || placeholder("?");
      thumbFinalImg.src = state.mid_winner_1_url || placeholder("?");
      thumbFinalCount.textContent = (state.seed_a_count ?? 0) + "-" + (state.seed_b_count ?? 0);
      thumbFinal.style.display = "block";
      finalFooter.textContent = (state.mid_winner_1_url && state.mid_winner_2_url)
        ? "Final is ready — will be decided at 0s."
        : "Semis partly done — waiting for other semi…";
    }

    function renderActive(){
      const snap = readSnap(state.base_iso||"");

      if (activeMatch === "ab") {
        const aImg = state.mid_done ? (snap?.ab?.a_url || placeholder("A")) : (state.seed_a_url || placeholder("A"));
        const bImg = state.mid_done ? (snap?.ab?.b_url || placeholder("B")) : (state.seed_b_url || placeholder("B"));
        const aCt  = state.mid_done ? (snap?.ab?.a_count ?? 0) : (state.seed_a_count ?? 0);
        const bCt  = state.mid_done ? (snap?.ab?.b_count ?? 0) : (state.seed_b_count ?? 0);
        imgActive1.src = aImg; imgActive2.src = bImg;
        labelActive1.textContent = "Seed A"; labelActive2.textContent = "Seed B";
        countActive1.textContent = aCt; countActive2.textContent = bCt;
        thumbAB.classList.add("active"); thumbCD.classList.remove("active"); thumbFinal.classList.remove("active");
      } else if (activeMatch === "cd") {
        const cImg = state.mid_done ? (snap?.cd?.c_url || placeholder("C")) : (state.seed_c_url || placeholder("C"));
        const dImg = state.mid_done ? (snap?.cd?.d_url || placeholder("D")) : (state.seed_d_url || placeholder("D"));
        const cCt  = state.mid_done ? (snap?.cd?.c_count ?? 0) : (state.seed_c_count ?? 0);
        const dCt  = state.mid_done ? (snap?.cd?.d_count ?? 0) : (state.seed_d_count ?? 0);
        imgActive1.src = cImg; imgActive2.src = dImg;
        labelActive1.textContent = "Seed C"; labelActive2.textContent = "Seed D";
        countActive1.textContent = cCt; countActive2.textContent = dCt;
        thumbCD.classList.add("active"); thumbAB.classList.remove("active"); thumbFinal.classList.remove("active");
      } else {
        // FINAL view — counts come from A/B after mid-cut (server resets to 0-0)
        imgActive1.src = state.mid_winner_1_url || placeholder("?");
        imgActive2.src = state.mid_winner_2_url || placeholder("?");
        const fl = computeFinalLabels();
        labelActive1.textContent = fl.left;
        labelActive2.textContent = fl.right;
        countActive1.textContent = state.seed_a_count ?? 0;
        countActive2.textContent = state.seed_b_count ?? 0;
        thumbFinal.classList.add("active"); thumbAB.classList.remove("active"); thumbCD.classList.remove("active");
      }

      // Thumbs: show *semi* snapshots once Final starts, else live semis
      if (state.mid_done && snap) {
        thumbABimg.src = snap.ab?.a_url || placeholder("A");
        thumbABcount.textContent = (snap.ab?.a_count ?? 0) + "-" + (snap.ab?.b_count ?? 0);
        thumbCDimg.src = snap.cd?.c_url || placeholder("C");
        thumbCDcount.textContent = (snap.cd?.c_count ?? 0) + "-" + (snap.cd?.d_count ?? 0);
      } else {
        thumbABimg.src = state.seed_a_url || placeholder("A");
        thumbABcount.textContent = (state.seed_a_count ?? 0) + "-" + (state.seed_b_count ?? 0);
        thumbCDimg.src = state.seed_c_url || placeholder("C");
        thumbCDcount.textContent = (state.seed_c_count ?? 0) + "-" + (state.seed_d_count ?? 0);
      }

      renderFinal();
      applyVoteMemory();
    }

    window.openFull = (which) => { fullImg.src = (which==='active1'? imgActive1.src: imgActive2.src); overlay.style.display='flex'; };
    thumbAB.addEventListener("click", () => { activeMatch = "ab"; renderActive(); });
    thumbCD.addEventListener("click", () => { activeMatch = "cd"; renderActive(); });
    thumbFinal.addEventListener("click", () => { if (!state.mid_done) return; activeMatch = "final"; renderActive(); });

    async function sendVote(whichSide){
      let side = activeMatch;
      const color = whichSide === "right" ? "blue" : "red";
      if (side === "final") side = "ab"; // final writes to A/B
      const voterId = `${RSID}-${state.base_iso || "noiso"}-${side}-${state.mid_done ? "final" : "semi"}`;
      const tokenSide = state.mid_done ? "ab_final" : `${side === "cd" ? "cd" : "ab"}_semi`;

      try {
        const res = await fetch(FUNCTION_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json', 'x-rsid': voterId },
          body: JSON.stringify({ color, side })
        });
        const data = await res.json();

        if ((res.ok && !data.ignored) || (data?.ignored && data?.reason === "already_voted_this_match")) {
          writeMem(state.base_iso || "", tokenSide, color);
        }
        if (data.ignored && data.reason === "already_voted_this_match") { dbg.textContent = "debug: already voted on " + side; applyVoteMemory(); return; }
        if (!res.ok) throw new Error(data.error || "vote failed");

        state.seed_a_count = data.seed_a_count ?? state.seed_a_count;
        state.seed_b_count = data.seed_b_count ?? state.seed_b_count;
        state.seed_c_count = data.seed_c_count ?? state.seed_c_count;
        state.seed_d_count = data.seed_d_count ?? state.seed_d_count;

        await fetchState(true);
        dbg.textContent = "debug: vote ok ("+color+"/"+side+")";
      } catch (err) {
        console.error(err);
        dbg.textContent = "debug: vote error → " + err.message;
      } finally {
        applyVoteMemory();
      }
    }

    btnActive1.onclick = () => sendVote("left");
    btnActive2.onclick = () => sendVote("right");

    async function fetchState(force=false){
      if (fetching) return;
      fetching = true;
      try {
        const res = await fetch(FUNCTION_URL);
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || JSON.stringify(data));

        const prevBase = state.base_iso;
        const newRound = prevBase && prevBase !== data.base_iso;

        state = data;
        elMeta.textContent = `cycle: ${data.base_iso}`;

        if (data.mid_done) winnerText.textContent = 'Semis decided — final at 0s.';
        else winnerText.textContent = 'Semis running…';

        if (newRound) {
          activeMatch = "ab";
          semiTriggered = false; finalTriggered = false; lastSemiPoll = 0;
          pruneVoteMem(data.base_iso); pruneSnap(data.base_iso);
        }

        ensureSemiSnapshot();
        if (state.mid_done) recoverSemisFromWinners();

        if (state.mid_done) {
          const snap = readSnap(state.base_iso);
          if (snap &&
              (snap.ab?.a_count ?? 0) === 0 && (snap.ab?.b_count ?? 0) === 0 &&
              (snap.cd?.c_count ?? 0) === 0 && (snap.cd?.d_count ?? 0) === 0) {
            recoverSemisFromWinners();
          }
        }

        renderActive();
        dbg.textContent = "debug: ok " + new Date().toLocaleTimeString();
      } catch(e) {
        console.error(e);
        dbg.textContent = "debug: GET error → " + (e.message || JSON.stringify(e));
        renderActive();
      } finally {
        fetching = false;
      }
    }

    function tick(){
      if (!state?.ends_at) return requestAnimationFrame(tick);
      const remain = new Date(state.ends_at).getTime() - Date.now();
      const ms = Math.max(0, remain);
      elRemain.textContent = (ms/1000).toFixed(1);
      const halfMs = (state.period_sec || 60) * 1000 / 2;

      if (ms <= halfMs + 200 && !state.mid_done) winnerText.textContent = 'Semis about to be decided…';

      if (ms <= halfMs && !state.mid_done) {
        const now = Date.now();
        if (!semiTriggered || now - lastSemiPoll > 1500) {
          semiTriggered = true; lastSemiPoll = now;
          fetch(FUNCTION_URL).then(r=>r.json()).then(data=>{
            state=data; if (data.mid_done) winnerText.textContent='Semis decided — final at 0s.';
            renderActive();
            dbg.textContent = "debug: semi sync via GET (post-30s loop)";
          }).catch(err=>{ dbg.textContent = "debug: semi GET error → " + err.message; });
        }
      }

      if (ms <= 0 && state.mid_done && !finalTriggered) {
        finalTriggered = true;
        fetch(FUNCTION_URL).then(r=>r.json()).then(data=>{
          state=data; renderActive(); dbg.textContent="debug: final synced at 0s";
        }).catch(err=>{ dbg.textContent="debug: final GET error → " + err.message; });
      }

      if (ms <= -900) { fetchState().catch(()=>{}); }

      requestAnimationFrame(tick);
    }

    forceBtn.addEventListener('click', ()=> fetchState(true));
    resetBtn.addEventListener('click', ()=> fetchState(true));

    supabase.channel('cycles-v2-live')
      .on('postgres_changes', { event:'UPDATE', schema:'public', table:'cycles_v2' }, async ()=>{ await fetchState(true); })
      .subscribe();

    supabase.channel('matchup-sync')
      .on('postgres_changes', { event:'UPDATE', schema:'public', table:'art_queue', filter:'status=in.(locked,used)' }, async ()=>{ await fetchState(true); })
      .subscribe();

    fetchState(true).then(()=>tick());
  </script>
</body>
</html>