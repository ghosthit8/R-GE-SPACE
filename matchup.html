<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rage Space — Matchup (Queue-first + Hybrid + 0s finalize)</title>
  <style>
    :root { --fg:#e5e7eb; --bg:#0b0d0f; --accent:#39ff14; --muted:#8b8b8b; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,Segoe UI,Roboto,Inter,ui-sans-serif; }
    .wrap { max-width:700px; margin:0 auto; padding:16px 12px 28px; }
    h1 { margin:0 0 10px; font-size:20px; font-weight:700; letter-spacing:.5px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .timer { font-variant-numeric: tabular-nums; font-weight:700; font-size:32px; line-height:1; padding:8px 14px; border:1px solid #20242a; border-radius:12px; background:#0f1318; }
    .state { color:var(--muted); font-size:12px; }
    .card { margin-top:12px; border:1px solid #20242a; border-radius:16px; overflow:hidden; background:#0f1318; }
    .imgBox { position:relative; width:100%; aspect-ratio:3/4; background:#111; display:grid; place-items:center; }
    .imgBox img { width:100%; height:100%; object-fit:cover; display:block; }
    .fullscreenBtn { position:absolute; top:8px; right:8px; background:rgba(0,0,0,.7); color:#e5e7eb; border:1px solid #3a3f46; border-radius:10px; font-size:12px; padding:6px 8px; cursor:pointer; }
    .fullscreenBtn:hover { box-shadow:0 0 8px rgba(57,255,20,.35); color:#39ff14; border-color:#39ff14; }
    .vote { position:absolute; bottom:8px; right:8px; background:#0b0f14; border:1px solid #27323a; color:#39ff14; border-radius:12px; font-weight:700; padding:8px 12px; cursor:pointer; }
    .vote[disabled] { opacity:.5; cursor:not-allowed; }
    .bar { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; gap:8px; border-top:1px solid #20242a; }
    .label { text-transform:uppercase; letter-spacing:.12em; font-weight:700; font-size:12px; color:#a1a1a1; }
    .counts { font-variant-numeric: tabular-nums; font-weight:700; }
    .btn, .vote, .linkbtn, .backbtn { appearance:none; border:1px solid #27323a; background:#131920; color:#fff; padding:8px 12px; border-radius:12px; text-decoration:none; cursor:pointer; }
    .btn:hover, .linkbtn:hover, .backbtn:hover { box-shadow:0 0 10px rgba(57,255,20,.25); color:#39ff14; border-color:#39ff14; }
    .nav { display:flex; gap:8px; }
    .winner { color:#39ff14; font-weight:700; }
    #overlay { position:fixed; inset:0; background:rgba(0,0,0,.9); display:none; place-items:center; z-index:9999; }
    #overlay img { max-width:95vw; max-height:92vh; display:block; border:1px solid #27323a; border-radius:14px; }
    #closeFull { position:fixed; top:10px; right:10px; z-index:10000; }
    .tools { display:flex; gap:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>Rage Space — Matchup</h1>
      <div class="nav">
        <a href="menu.html" class="btn backbtn">← Menu</a>
        <a href="submit.html" class="btn linkbtn">Submit →</a>
      </div>
    </div>

    <div class="row" style="gap:12px">
      <div class="timer" id="tRemain">—</div>
      <div class="state" id="tMeta">…</div>
      <div class="tools">
        <button id="forceQueue" class="btn">Force Queue</button>
        <button id="resetPair" class="btn">Reset Pair</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="row" style="justify-content:space-between; padding:10px 12px">
        <div class="label">Round</div>
        <div id="stage" class="label" style="color:#fff; letter-spacing:.06em">R32</div>
      </div>
      <div class="row" style="gap:10px; padding:10px 12px">
        <div class="imgBox" style="flex:1; min-width:0">
          <img id="imgA" alt="Red seed"/>
          <button class="fullscreenBtn" onclick="openFull('A')">Fullscreen</button>
          <button id="btnA" class="vote">Vote Red</button>
        </div>
        <div class="imgBox" style="flex:1; min-width:0">
          <img id="imgB" alt="Blue seed"/>
          <button class="fullscreenBtn" onclick="openFull('B')">Fullscreen</button>
          <button id="btnB" class="vote">Vote Blue</button>
        </div>
      </div>
      <div class="bar">
        <div>
          <span class="label">Red</span> <span class="counts" id="countA">0</span>
        </div>
        <div class="winner" id="winnerText">—</div>
        <div>
          <span class="label">Blue</span> <span class="counts" id="countB">0</span>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay">
    <img id="fullImg" alt="Full image"/>
    <button id="closeFull" class="btn">✕ Close</button>
  </div>

  <script>
    // --- Supabase config ---
    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const FUNCTION_URL = `${SUPABASE_URL}/functions/v1/global-timer-v2`;

    // --- Storage ---
    const BUCKET = "art-uploads";
    const UPLOAD_DIR = ""; // recursive scan start

    // --- Local state / helpers ---
    const RSID_KEY = "rsid_v2";
    let RSID = localStorage.getItem(RSID_KEY);
    if (!RSID) { RSID = (crypto.randomUUID?.() || Math.random().toString(36).slice(2)+Date.now()); localStorage.setItem(RSID_KEY, RSID); }
    const votedKey = (b) => `voted:${b}`;
    const hasVoted = (b) => localStorage.getItem(votedKey(b)) === "1";
    const markVoted = (b) => localStorage.setItem(votedKey(b), "1");

    const PAIR_KEY   = (b) => `pair:${b}`;                // { redUrl, blueUrl, redPath?, bluePath?, redQueueId?, blueQueueId? }
    const CLAIM_KEY  = (b) => `bucket_claimed:${b}`;      // "1" when we've chosen images this round
    const DELETE_KEY = (b) => `bucket_to_delete:${b}`;    // JSON [paths...] (bucket only)
    const ZERO_DELETE_DID = (b) => `zero_deleted:${b}`;   // run once per base

    const loadPair  = (b) => { try { return JSON.parse(localStorage.getItem(PAIR_KEY(b))||"null"); } catch { return null; } };
    const savePair  = (b, p) => { if (p?.redUrl && p?.blueUrl) localStorage.setItem(PAIR_KEY(b), JSON.stringify(p)); };
    const clearPair = (b) => localStorage.removeItem(PAIR_KEY(b));

    const elRemain = document.getElementById("tRemain");
    const elMeta   = document.getElementById("tMeta");
    const imgA     = document.getElementById("imgA");
    const imgB     = document.getElementById("imgB");
    const cA       = document.getElementById("countA");
    const cB       = document.getElementById("countB");
    const btnA     = document.getElementById("btnA");
    const btnB     = document.getElementById("btnB");
    const winnerText = document.getElementById("winnerText");
    const overlay  = document.getElementById("overlay");
    const fullImg  = document.getElementById("fullImg");
    const btnClose = document.getElementById("closeFull");
    const forceBtn = document.getElementById("forceQueue");
    const resetBtn = document.getElementById("resetPair");

    btnClose.onclick = () => overlay.style.display = 'none';
    function openFull(which){ fullImg.src = which==='A'?imgA.src:imgB.src; overlay.style.display='flex'; }
    window.openFull = (w)=>{ openFull(w); };

    function setVoteButtons(enabled){ btnA.disabled = btnB.disabled = !enabled; }
    btnA.onclick = () => !btnA.disabled && sendVote('red');
    btnB.onclick = () => !btnB.disabled && sendVote('blue');

    function tbdPlaceholder() {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="720" height="960">
        <rect width="100%" height="100%" fill="#000"/>
        <text x="50%" y="50%" fill="#39ff14" font-size="90" font-family="monospace" text-anchor="middle" dominant-baseline="middle">? tbd</text>
      </svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    async function listAllFiles(dir = "") {
      const out = [];
      let cursor = dir;
      for (let i=0;i<80;i++){
        const { data, error } = await supabase.storage.from(BUCKET).list(cursor, { limit: 100 });
        if (error) { console.warn("[STORAGE] list error", cursor || "(root)", error); break; }
        if (!data || !data.length) break;
        for (const entry of data) {
          if (entry.name.endsWith('/') || entry.id?.endsWith('/')) {
            const next = (cursor ? cursor + '/' : '') + (entry.name || entry.id);
            const { data: sub, error: e2 } = await supabase.storage.from(BUCKET).list(next, { limit: 100 });
            if (!e2 && sub && sub.length){
              for (const s of sub){
                if (!s.name.endsWith('/')) out.push((next ? next + '/' : '') + (s.name || s.id));
              }
            }
          } else {
            out.push((cursor ? cursor + '/' : '') + (entry.name || entry.id));
          }
        }
        break; // shallow list (we use simple directory layout)
      }
      return out;
    }

    async function publicUrl(path){
      const { data } = supabase.storage.from(BUCKET).getPublicUrl(path);
      return data.publicUrl;
    }
    async function deletePaths(paths=[]){
      if (!paths.length) return;
      const { error } = await supabase.storage.from(BUCKET).remove(paths);
      if (error) console.warn('[STORAGE] delete error', error);
      else console.log('[STORAGE] deleted', paths);
    }
    async function deleteEmptyFolders(dir = "") {
      const { data, error } = await supabase.storage.from(BUCKET).list(dir, { limit: 100 });
      if (error) { console.warn("[STORAGE] list error while cleaning", dir || "(root)", error); return; }
      if (!data || !data.length) return;
      let sawFile = false;
      for (const d of data) {
        if (!d.name?.endsWith('/')) { sawFile = true; break; }
      }
      if (!sawFile && dir) {
        // Supabase Storage doesn’t expose folder delete directly; skip
      }
    }

    async function markQueueUsed(ids=[]){
      if (!ids.length) return;
      const { error } = await supabase.from('art_queue').update({ status:'used', used_at: new Date().toISOString() }).in('id', ids);
      if (error) console.warn('[QUEUE] used update error', error);
    }

    async function claimFromQueue(base_iso){
      const { data, error } = await supabase.rpc('claim_two_queue_items', { base_iso });
      if (error) { console.warn('[QUEUE] claim RPC error', error); return []; }
      return data || [];
    }

    async function sendVote(color){
      const res = await fetch(FUNCTION_URL, {
        method:'POST',
        headers:{ 'content-type':'application/json', 'x-rsid': RSID },
        body: JSON.stringify({ color })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'vote failed');
      if (data.ignored && data.reason==='already_voted') return setVoteButtons(false);
      if (!data.ignored){
        markVoted(state.base_iso);
        setVoteButtons(false);
        cA.textContent = data.red_count;
        cB.textContent = data.blue_count;
      }
    }

    function showWinner(winner){
      if (!winner){ winnerText.textContent='No winner yet — first round in progress.'; return; }
      const by = winner.decided_by==='random_tie' ? 'random tie' : 'votes';
      const name = winner.winner_color==='red' ? 
        'Red' : 'Blue';
      const r = winner.red_count ?? winner.seed_a_count ?? 0;
      const b = winner.blue_count ?? winner.seed_b_count ?? 0;
      winnerText.textContent = `${name} won by ${by} (${r}–${b})`;
    }

    // initial placeholder to avoid flashing empty
    imgA.src = tbdPlaceholder();
    imgB.src = tbdPlaceholder();

    // global state for GET loop
    let state = { base_iso:null, ends_at:null, period_sec:60, red_url:'', blue_url:'', red_count:0, blue_count:0, last_winner:null };
    let fetching = false;

    async function fetchState(forcePull=false){
      if (fetching) return; fetching = true;
      try{
        const res = await fetch(FUNCTION_URL);
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'GET failed');

        const prevBase = state.base_iso;
        const newRound = prevBase && prevBase !== data.base_iso;
        state = data;

        if (newRound) {
          // backup delete of bucket files from previous base
          const toDelete = JSON.parse(localStorage.getItem(DELETE_KEY(prevBase) || 'null') || 'null');
          if (Array.isArray(toDelete) && toDelete.length) {
            deletePaths(toDelete).catch(()=>{});
            deleteEmptyFolders().catch(()=>{});
          }
          // backup: mark previously locked queue items as used
          const lockedPrev = loadPair(prevBase);
          const usedIds = [lockedPrev?.redQueueId, lockedPrev?.blueQueueId].filter(Boolean);
          if (usedIds.length) await markQueueUsed(usedIds);

          // local cleanup
          localStorage.removeItem(DELETE_KEY(prevBase));
          localStorage.removeItem(CLAIM_KEY(prevBase));
          localStorage.removeItem(ZERO_DELETE_DID(prevBase));
          clearPair(prevBase);
          setVoteButtons(!hasVoted(state.base_iso));
        }

        // Determine images for this round
        let redUrl, blueUrl, redPath=null, bluePath=null, redQueueId=null, blueQueueId=null;

        // Use locked pair if present
        const locked = loadPair(state.base_iso);
        if (locked?.redUrl && locked?.blueUrl){
          redUrl = locked.redUrl; blueUrl = locked.blueUrl;
          redPath = locked.redPath || null; bluePath = locked.bluePath || null;
          redQueueId = locked.redQueueId || null; blueQueueId = locked.blueQueueId || null;
          console.log('[PAIR] using locked pair for', state.base_iso);
        }

        const alreadyClaimed = !!localStorage.getItem(CLAIM_KEY(state.base_iso));
        const shouldPull = forcePull || newRound || (!alreadyClaimed && !locked);

        if (shouldPull){
          // Try to assemble a pair preferring queue; top-up from bucket if needed
          try {
            const claims = await claimFromQueue(state.base_iso);
            const gotFromQueue = Array.isArray(claims) ? claims : [];
            if (gotFromQueue.length){
              const [a,b] = gotFromQueue;
              redUrl = a?.image_url || redUrl; redQueueId = a?.id || redQueueId;
              blueUrl = b?.image_url || blueUrl; blueQueueId = b?.id || blueQueueId;
              console.log('[QUEUE] claimed', gotFromQueue.map(x=>x.id));
            }
          } catch(e){
            console.warn('[QUEUE] claim error', e);
          }

          // If any side missing, pull from bucket
          if (!redUrl || !blueUrl) {
            const files = await listAllFiles(UPLOAD_DIR);
            // pick any two distinct
            const picks = files.slice(0, 2);
            const urls = await Promise.all(picks.map(p=>publicUrl(p)));
            if (!redUrl) { redUrl = urls[0] || redUrl; redPath = picks[0] || redPath; }
            if (!blueUrl){ blueUrl = urls[1] || blueUrl; bluePath = picks[1] || bluePath; }
            if (redPath || bluePath) {
              const pending = JSON.parse(localStorage.getItem(DELETE_KEY(state.base_iso) || 'null') || '[]');
              const want = [...pending, ...[redPath, bluePath].filter(Boolean)];
              localStorage.setItem(DELETE_KEY(state.base_iso), JSON.stringify(want));
            }
          }

          // Persist locked pair locally (for this base)
          const pair = { redUrl:redUrl||tbdPlaceholder(), blueUrl:blueUrl||tbdPlaceholder(), redPath, bluePath, redQueueId, blueQueueId };
          savePair(state.base_iso, pair);
          localStorage.setItem(CLAIM_KEY(state.base_iso), '1');
        }

        // Paint
        const p = loadPair(state.base_iso);
        const rURL = p?.redUrl || state.red_url || tbdPlaceholder();
        const bURL = p?.blueUrl || state.blue_url || tbdPlaceholder();
        const redUrl = rURL; const blueUrl = bURL;

        imgA.src = redUrl;
        imgB.src = blueUrl;
        cA.textContent = state.red_count;
        cB.textContent = state.blue_count;
        elMeta.textContent = `cycle: ${state.base_iso}`;
        showWinner(state.last_winner);
      }catch(e){
        console.error(e);
      }finally{
        fetching = false;
      }
    }

    function tick(){
      if (!state?.ends_at) return requestAnimationFrame(tick);
      const remain = new Date(state.ends_at).getTime() - Date.now();
      elRemain.textContent = (Math.max(0, remain)/1000).toFixed(1);

      // Finalize at 0s (once per base)
      if (remain <= 0 && state?.base_iso && !localStorage.getItem(ZERO_DELETE_DID(state.base_iso))) {
        (async () => {
          try {
            // bucket delete
            const raw = localStorage.getItem(DELETE_KEY(state.base_iso));
            const paths = raw ? JSON.parse(raw) : [];
            if (Array.isArray(paths) && paths.length) {
              await deletePaths(paths);
              await deleteEmptyFolders();
              console.log('[STORAGE] deleted at 0s', paths);
            }
            // queue rows -> used
            const p = loadPair(state.base_iso);
            const ids = [p?.redQueueId, p?.blueQueueId].filter(Boolean);
            if (ids.length) { await markQueueUsed(ids); console.log('[QUEUE] used at 0s', ids); }

            localStorage.setItem(ZERO_DELETE_DID(state.base_iso), '1');
          } catch(e){ console.warn('[0s finalize error]', e); }
        })();
      }

      requestAnimationFrame(tick);
    }

    // Force tools
    forceBtn.addEventListener('click', async ()=>{
      await fetchState(true);
    });
    resetBtn.addEventListener('click', async ()=>{
      if (!state?.base_iso) return;
      const p = loadPair(state.base_iso);
      if (p?.redQueueId || p?.blueQueueId) {
        const ids = [p.redQueueId, p.blueQueueId].filter(Boolean);
        await markQueueUsed(ids);
      }
      localStorage.removeItem(DELETE_KEY(state.base_iso));
      localStorage.removeItem(CLAIM_KEY(state.base_iso));
      localStorage.removeItem(ZERO_DELETE_DID(state.base_iso));
      clearPair(state.base_iso);
      await fetchState(true);
    });
    document.getElementById('resetPair').addEventListener('click', async ()=>{
      if (!state?.base_iso) return;
      clearPair(state.base_iso);
      await fetchState(false);
    });

    // ---------- Realtime: keep matchup in lockstep with queue ----------
    const queueChannel = supabase
      .channel('matchup-sync')
      .on('postgres_changes',
          { event: 'UPDATE', schema: 'public', table: 'art_queue', filter: 'status=in.(locked,used)' },
          async (payload) => {
            console.log('[SYNC] queue item', payload.new?.id, '→', payload.new?.status, '→ refresh matchup');
            await fetchState(true).catch(()=>{});
          })
      .subscribe((status) => console.log('[Realtime] matchup-sync →', status));

    // ---------- Round-flip instant refresh (detect 0 → period jump) ----------
    let __lastRemain = null;
    function __watchRoundFlip(){
      const n = parseFloat(elRemain.textContent);
      if (!isNaN(n)) {
        if (__lastRemain !== null && __lastRemain <= 0.2 && n > __lastRemain + 0.5) {
          console.log('[SYNC] round start detected — re-fetching');
          fetchState(true).catch(()=>{});
        }
        __lastRemain = n;
      }
      requestAnimationFrame(__watchRoundFlip);
    }
    __watchRoundFlip();

    // Boot
    setInterval(()=> fetchState().catch(()=>{}), 4000);
    (async()=>{ await fetchState(); tick(); })();
  </script>
</body>
</html>