<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rage Space — Matchup</title>

  <!-- (your existing styles/scripts/head content stay the same) -->

  <style>
    /* (your existing CSS stays the same) */
  </style>
</head>

<body>
  <!-- (your existing layout stays the same up here) -->

  <!-- wherever your timer box is, it now reads this: -->
  <!-- NOTE: I preserved the same element/id so your layout doesn’t shift. -->
  <div class="timer" id="tRemain">First to 2 wins</div>

  <!-- (rest of your existing HTML stays the same) -->

  <!-- ================== your existing libs (supabase) ================== -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- ================== UPDATED MAIN LOGIC ================== -->
  <script>
  const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // =========================
  // VOTE-TO-WIN MODE (no edge function, no timer)
  // First image to WIN_TARGET votes wins its match.
  // Matches unlock automatically when BOTH opponents exist.
  // =========================
  const WIN_TARGET = 2;

  const RSID_KEY = "rsid_v2";
  let RSID = localStorage.getItem(RSID_KEY);
  if (!RSID){
    RSID = (crypto.randomUUID?.() || Math.random().toString(36).slice(2)+Date.now());
    localStorage.setItem(RSID_KEY, RSID);
  }

  // UI
  const elRemain = document.getElementById("tRemain");
  const winnerText = document.getElementById("winnerText");
  const currentRoundEl = document.getElementById("currentRound");

  const imgActive1 = document.getElementById("imgActive1");
  const imgActive2 = document.getElementById("imgActive2");
  const vidActive1 = document.getElementById("vidActive1");
  const vidActive2 = document.getElementById("vidActive2");
  const labelActive1 = document.getElementById("labelActive1");
  const labelActive2 = document.getElementById("labelActive2");
  const countActive1 = document.getElementById("countActive1");
  const countActive2 = document.getElementById("countActive2");
  const btnActive1 = document.getElementById("btnActive1");
  const btnActive2 = document.getElementById("btnActive2");
  const metaActive1 = document.getElementById("metaActive1");
  const metaActive2 = document.getElementById("metaActive2");
  const autoBtn1 = document.getElementById("autoActive1");
  const autoBtn2 = document.getElementById("autoActive2");

  const finalImg1 = document.getElementById("finalImg1");
  const finalImg2 = document.getElementById("finalImg2");
  const finalVid1 = document.getElementById("finalVid1");
  const finalVid2 = document.getElementById("finalVid2");
  const finalLeftLabel  = document.getElementById("finalLeftLabel");
  const finalRightLabel = document.getElementById("finalRightLabel");
  const finalFooter = document.getElementById("finalFooter");

  const overlay  = document.getElementById("overlay");
  const fullImg  = document.getElementById("fullImg");
  const fullVideo = document.getElementById("fullVideo");
  const btnClose = document.getElementById("closeFull");
  btnClose.onclick = ()=>{
    overlay.style.display='none';
    try {
      fullVideo.pause();
      fullVideo.removeAttribute('src');
      fullVideo.load();
    } catch(e){}
  };

  const grid = document.getElementById("thumbGrid");

  // Keep the "timer" box but repurpose it.
  if (elRemain) elRemain.textContent = `First to ${WIN_TARGET} wins`;

  // ========= helpers =========
  const lastGoodThumb = {};
  const lastGoodActive = {};

  function isRealUrl(url){
    return typeof url === "string" &&
           url.length > 0 &&
           !url.startsWith("data:image/svg+xml");
  }
  function isVideoUrl(url){
    if (typeof url !== "string") return false;
    const base = url.split("#")[0];
    return /\.(mp4|webm|mov)(\?|$)/i.test(base);
  }
  function placeholder(letter){
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="720" height="960">
      <rect width="100%" height="100%" fill="#000"/>
      <text x="50%" y="50%" fill="#39ff14" font-size="90" font-family="monospace"
        text-anchor="middle" dominant-baseline="middle">${letter}</text>
    </svg>`;
    return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
  }
  function pick(a,b){ return (a!=null && a!=="") ? a : b; }

  function escapeHtml(str){
    return String(str)
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  function renderPieceMeta(container, meta){
    if (!container) return;
    const desc = meta && meta.desc ? String(meta.desc) : "";

    if (!desc){
      container.classList.add("hidden");
      container.innerHTML = "";
      return;
    }

    container.classList.remove("hidden");

    const LIMIT = 260;
    const truncated = desc.length > LIMIT;
    const shortDesc = truncated ? desc.slice(0, LIMIT).trim() + "…" : desc;

    let html = `<div class="piece-desc" data-full="${encodeURIComponent(desc)}" data-limit="${LIMIT}" data-expanded="0">${escapeHtml(shortDesc)}</div>`;
    if (truncated){
      html += `<button class="seeMoreBtn" type="button">See more</button>`;
    }

    container.innerHTML = html;

    const btn = container.querySelector(".seeMoreBtn");
    if (btn){
      btn.addEventListener("click", ()=>{
        const descEl = container.querySelector(".piece-desc");
        if (!descEl) return;
        const expanded = descEl.dataset.expanded === "1";
        const limit = parseInt(descEl.dataset.limit || "260",10);
        const full = decodeURIComponent(descEl.dataset.full || "");
        if (!expanded){
          descEl.textContent = full;
          descEl.dataset.expanded = "1";
          btn.textContent = "See less";
        } else {
          const truncatedAgain = full.length > limit;
          const shortAgain = truncatedAgain ? full.slice(0,limit).trim()+"…" : full;
          descEl.textContent = shortAgain;
          descEl.dataset.expanded = "0";
          btn.textContent = "See more";
        }
      });
    }
  }

  function openFull(which){
    let url = "";
    if (which==="active1"){
      if (!vidActive1.classList.contains("hidden") && vidActive1.src) url = vidActive1.src;
      else url = imgActive1.src;
    } else if (which==="active2"){
      if (!vidActive2.classList.contains("hidden") && vidActive2.src) url = vidActive2.src;
      else url = imgActive2.src;
    }
    if (!url) return;

    const video = isVideoUrl(url);
    if (video){
      fullImg.classList.add("hidden");
      fullVideo.classList.remove("hidden");
      fullVideo.src = url;
      try { fullVideo.play().catch(()=>{}); } catch(e){}
    } else {
      fullVideo.classList.add("hidden");
      try {
        fullVideo.pause();
        fullVideo.removeAttribute("src");
        fullVideo.load();
      } catch(e){}
      fullImg.classList.remove("hidden");
      fullImg.src = url;
    }
    overlay.style.display = 'flex';
  }
  window.openFull = openFull; // keep inline onclicks working

  function setActiveMedia(which, url){
    const img = which==="active1" ? imgActive1 : imgActive2;
    const vid = which==="active1" ? vidActive1 : vidActive2;

    const cacheKey = which;
    let finalUrl = url;

    if (isRealUrl(finalUrl)) {
      lastGoodActive[cacheKey] = finalUrl;
    } else if (lastGoodActive[cacheKey]) {
      finalUrl = lastGoodActive[cacheKey];
    }

    const isVid = isVideoUrl(finalUrl);

    if (isVid){
      img.classList.add("hidden");
      vid.classList.remove("hidden");
      vid.src = finalUrl + "#t=0.1";
      vid.loop = true;
      vid.playsInline = true;
      try { vid.play().catch(()=>{}); } catch(e){}
    } else {
      vid.classList.add("hidden");
      try {
        vid.pause();
        vid.removeAttribute("src");
        vid.load();
      } catch(e){}
      img.classList.remove("hidden");
      img.src = finalUrl || placeholder("?");
    }
  }

  function setFinalMedia(idx, url){
    const img = idx===1 ? finalImg1 : finalImg2;
    const vid = idx===1 ? finalVid1 : finalVid2;
    const isVid = isVideoUrl(url);

    if (isVid){
      img.classList.add("hidden");
      vid.classList.remove("hidden");
      vid.src = url + "#t=0.1";
      vid.loop = true;
      vid.playsInline = true;
      try { vid.play().catch(()=>{}); } catch(e){}
    } else {
      vid.classList.add("hidden");
      try {
        vid.pause();
        vid.removeAttribute("src");
        vid.load();
      } catch(e){}
      img.classList.remove("hidden");
      img.src = url || placeholder("?");
    }
  }

  function pauseOtherVideos(except){
    const vids = [vidActive1, vidActive2, finalVid1, finalVid2, fullVideo];
    vids.forEach(v=>{
      if (!v || v === except) return;
      try { v.pause(); } catch(e){}
    });
  }
  vidActive1.addEventListener("play", ()=> pauseOtherVideos(vidActive1));
  vidActive2.addEventListener("play", ()=> pauseOtherVideos(vidActive2));
  finalVid1.addEventListener("play", ()=> pauseOtherVideos(finalVid1));
  finalVid2.addEventListener("play", ()=> pauseOtherVideos(finalVid2));
  fullVideo.addEventListener("play", ()=> pauseOtherVideos(fullVideo));

  // ========= bracket wiring =========
  // Leaves (R32)
  const order = [
    {key:"final", label:"Final"},
    {key:"s1", label:"Semi 1"},
    {key:"s2", label:"Semi 2"},

    {key:"q1", label:"QF A–B"},
    {key:"q2", label:"QF C–D"},
    {key:"q3", label:"QF E–F"},
    {key:"q4", label:"QF G–H"},

    {key:"r1", label:"R16 A–B"},
    {key:"r2", label:"R16 C–D"},
    {key:"r3", label:"R16 E–F"},
    {key:"r4", label:"R16 G–H"},
    {key:"r5", label:"R16 I–J"},
    {key:"r6", label:"R16 K–L"},
    {key:"r7", label:"R16 M–N"},
    {key:"r8", label:"R16 O–P"},

    {key:"rr1",  label:"R32 1"},
    {key:"rr2",  label:"R32 2"},
    {key:"rr3",  label:"R32 3"},
    {key:"rr4",  label:"R32 4"},
    {key:"rr5",  label:"R32 5"},
    {key:"rr6",  label:"R32 6"},
    {key:"rr7",  label:"R32 7"},
    {key:"rr8",  label:"R32 8"},
    {key:"rr9",  label:"R32 9"},
    {key:"rr10", label:"R32 10"},
    {key:"rr11", label:"R32 11"},
    {key:"rr12", label:"R32 12"},
    {key:"rr13", label:"R32 13"},
    {key:"rr14", label:"R32 14"},
    {key:"rr15", label:"R32 15"},
    {key:"rr16", label:"R32 16"}
  ];

  // child -> parent mapping
  const ADVANCE = {
    rr1:{parent:"r1",  slot:"left"},  rr2:{parent:"r1",  slot:"right"},
    rr3:{parent:"r2",  slot:"left"},  rr4:{parent:"r2",  slot:"right"},
    rr5:{parent:"r3",  slot:"left"},  rr6:{parent:"r3",  slot:"right"},
    rr7:{parent:"r4",  slot:"left"},  rr8:{parent:"r4",  slot:"right"},
    rr9:{parent:"r5",  slot:"left"},  rr10:{parent:"r5", slot:"right"},
    rr11:{parent:"r6", slot:"left"},  rr12:{parent:"r6", slot:"right"},
    rr13:{parent:"r7", slot:"left"},  rr14:{parent:"r7", slot:"right"},
    rr15:{parent:"r8", slot:"left"},  rr16:{parent:"r8", slot:"right"},

    r1:{parent:"q1",  slot:"left"}, r2:{parent:"q1",  slot:"right"},
    r3:{parent:"q2",  slot:"left"}, r4:{parent:"q2",  slot:"right"},
    r5:{parent:"q3",  slot:"left"}, r6:{parent:"q3",  slot:"right"},
    r7:{parent:"q4",  slot:"left"}, r8:{parent:"q4",  slot:"right"},

    q1:{parent:"s1", slot:"left"},  q2:{parent:"s1", slot:"right"},
    q3:{parent:"s2", slot:"left"},  q4:{parent:"s2", slot:"right"},

    s1:{parent:"final", slot:"left"},
    s2:{parent:"final", slot:"right"}
  };

  // ========= local vote memory (per-user / per-cycle) =========
  const VOTE_MEMORY_KEY = "rs_vote_memory_v5";
  let voteUserKey = "guest";

  async function initVoteUserKey(){
    try {
      const { data } = await supabase.auth.getUser();
      const user = data?.user;
      if (user) voteUserKey = user.id || user.email || "user";
      else voteUserKey = "guest";
    } catch(e) {
      voteUserKey = "guest";
    }
  }

  function memRead(cycleId){
    try{
      const all = JSON.parse(localStorage.getItem(VOTE_MEMORY_KEY)||"{}");
      const perUser = all[voteUserKey] || {};
      return perUser[String(cycleId)] || {};
    }catch{
      return {};
    }
  }
  function memWrite(cycleId, matchKey, side){
    const all = (()=>{ try { return JSON.parse(localStorage.getItem(VOTE_MEMORY_KEY)||"{}"); } catch { return {}; }})();
    const perUser = all[voteUserKey] || {};
    const cid = String(cycleId);
    perUser[cid] = Object.assign({}, perUser[cid]||{}, { [matchKey]: side });
    all[voteUserKey] = perUser;
    localStorage.setItem(VOTE_MEMORY_KEY, JSON.stringify(all));
  }

  // ========= data model in memory =========
  let cycle = null;        // current cycles_v2 row
  let cycleId = null;      // cycles_v2.id
  let matches = {};        // match_key -> {left_url,right_url,winner_url,winner_side}
  let counts = {};         // match_key -> {left,right}
  let metaByUrl = {};      // optional, carried from cycles_v2 if you store meta there

  let activeMatch = "rr1";
  let activeLeftUrl = null;
  let activeRightUrl = null;

  // ========= thumbs =========
  const thumbs = {};
  function makeThumb(item){
    const div = document.createElement("div");
    div.className = "thumb";
    div.id = "thumb_"+item.key;
    div.innerHTML = `
      <div class="thumb-img diag">
        <img class="half left"  id="imgL_${item.key}" alt="${item.label} top">
        <img class="half right" id="imgR_${item.key}" alt="${item.label} bottom">
        <video class="half left hidden"  id="vidL_${item.key}" muted playsinline preload="metadata"></video>
        <video class="half right hidden" id="vidR_${item.key}" muted playsinline preload="metadata"></video>
        <div class="video-badge hidden" id="badge_${item.key}">VIDEO</div>
      </div>
      <div class="thumb-label">
        <span>${item.label}</span>
        <span class="thumb-count" id="cnt_${item.key}">0-0</span>
      </div>
    `;
    div.addEventListener("click", ()=>{
      if (thumbs[item.key].box.classList.contains("disabled")) return;
      if (thumbs[item.key].box.classList.contains("hidden")) return;
      activeMatch = item.key;
      renderActive();
    });
    grid.appendChild(div);
    thumbs[item.key] = {
      box:   div,
      imgL:  div.querySelector("#imgL_"+item.key),
      imgR:  div.querySelector("#imgR_"+item.key),
      vidL:  div.querySelector("#vidL_"+item.key),
      vidR:  div.querySelector("#vidR_"+item.key),
      count: div.querySelector("#cnt_"+item.key),
      badge: div.querySelector("#badge_"+item.key)
    };
  }
  order.forEach(makeThumb);

  const hoverEnabled = window.matchMedia && window.matchMedia("(pointer:fine)").matches;
  if (hoverEnabled) {
    for (const k in thumbs) {
      const t = thumbs[k];
      t.box.addEventListener("mouseenter", handleThumbEnter);
      t.box.addEventListener("mouseleave", handleThumbLeave);
    }
  }

  function handleThumbEnter(e){
    const box = e.currentTarget;
    const url = box.dataset.videoUrl;
    if (!url) return;
    const imgWrap = box.querySelector(".thumb-img");
    if (!imgWrap) return;
    if (imgWrap.querySelector("video.thumb-preview")) return;

    const v = document.createElement("video");
    v.className = "thumb-preview";
    v.src = url + "#t=0.1";
    v.muted = true;
    v.loop = true;
    v.playsInline = true;
    imgWrap.appendChild(v);
    try { v.play().catch(()=>{}); } catch(e){}
  }

  function handleThumbLeave(e){
    const box = e.currentTarget;
    const imgWrap = box.querySelector(".thumb-img");
    if (!imgWrap) return;
    const v = imgWrap.querySelector("video.thumb-preview");
    if (!v) return;
    try { v.pause(); } catch(e){}
    v.remove();
  }

  function setThumb(key,leftUrl,rightUrl,leftCt,rightCt,fallback){
    const th = thumbs[key]; if (!th) return;

    const leftKey = key + "_L";
    const rightKey = key + "_R";

    if (isRealUrl(leftUrl)) {
      lastGoodThumb[leftKey] = leftUrl;
    } else if (lastGoodThumb[leftKey]) {
      leftUrl = lastGoodThumb[leftKey];
    }

    if (isRealUrl(rightUrl)) {
      lastGoodThumb[rightKey] = rightUrl;
    } else if (lastGoodThumb[rightKey]) {
      rightUrl = lastGoodThumb[rightKey];
    }

    const leftIsVid = isVideoUrl(leftUrl);
    const rightIsVid = isVideoUrl(rightUrl);
    const hasVideo = leftIsVid || rightIsVid;

    if (leftIsVid) {
      th.imgL.classList.add("hidden");
      th.vidL.classList.remove("hidden");
      th.vidL.src = leftUrl + "#t=0.1";
      th.vidL.preload = "metadata";
      try { th.vidL.pause(); } catch(e){}
    } else {
      th.vidL.classList.add("hidden");
      th.imgL.classList.remove("hidden");
      th.imgL.src = leftUrl || placeholder(fallback||"?");
    }

    if (rightIsVid) {
      th.imgR.classList.add("hidden");
      th.vidR.classList.remove("hidden");
      th.vidR.src = rightUrl + "#t=0.1";
      th.vidR.preload = "metadata";
      try { th.vidR.pause(); } catch(e){}
    } else {
      th.vidR.classList.add("hidden");
      th.imgR.classList.remove("hidden");
      th.imgR.src = rightUrl || placeholder(fallback||"?");
    }

    th.count.textContent = (leftCt??0) + "-" + (rightCt??0);
    if (th.badge) th.badge.classList.toggle("hidden", !hasVideo);

    const box = th.box;
    if (hasVideo) {
      const vidUrl = leftIsVid ? leftUrl : rightUrl;
      box.dataset.videoUrl = vidUrl || "";
    } else {
      delete box.dataset.videoUrl;
    }
  }

  function markActive(){
    for (const k in thumbs) {
      thumbs[k].box.classList.toggle("active", k===activeMatch);
    }
  }

  function isMatchLive(key){
    const m = matches[key];
    if (!m) return false;
    return isRealUrl(m.left_url) && isRealUrl(m.right_url) && !m.winner_url;
  }

  function stageNameFromKey(key){
    if (key.startsWith("rr")) return "Round of 32";
    if (key.startsWith("r")) return "Round of 16";
    if (key.startsWith("q")) return "Quarterfinals";
    if (key.startsWith("s")) return "Semifinals";
    return "Final";
  }

  function updateCurrentRoundLabel(){
    if (!currentRoundEl) return;
    const name = stageNameFromKey(activeMatch);
    currentRoundEl.textContent = "Current round: " + name;
  }

  function renderThumbs(){
    // update all thumbs from matches + counts
    const fallbackMap = {
      rr1:"A", rr2:"C", rr3:"E", rr4:"G", rr5:"I", rr6:"K", rr7:"M", rr8:"O",
      rr9:"Q", rr10:"S", rr11:"U", rr12:"W", rr13:"Y", rr14:"AA", rr15:"AC", rr16:"AE",
      r1:"A", r2:"C", r3:"E", r4:"G", r5:"I", r6:"K", r7:"M", r8:"O",
      q1:"A", q2:"C", q3:"E", q4:"G",
      s1:"S1", s2:"S2",
      final:"F"
    };

    for (const item of order){
      const k = item.key;
      const m = matches[k] || {};
      const c = counts[k] || {left:0,right:0};
      setThumb(k, m.left_url, m.right_url, c.left, c.right, fallbackMap[k] || "?");

      // Hide future matches until both opponents exist (keeps your layout clean).
      const hasBoth = isRealUrl(m.left_url) && isRealUrl(m.right_url);
      const isLeaf = k.startsWith("rr");
      const shouldShow = isLeaf ? hasBoth : (hasBoth || !!m.winner_url);

      thumbs[k].box.classList.toggle("hidden", !shouldShow);

      // Disable if not live (missing opponent or already has winner)
      thumbs[k].box.classList.toggle("disabled", !isMatchLive(k));
    }

    // Ensure we always have some active, visible match selected
    if (thumbs[activeMatch]?.box.classList.contains("hidden") || thumbs[activeMatch]?.box.classList.contains("disabled")) {
      const firstLive = order.map(o=>o.key).find(k => isMatchLive(k) && !thumbs[k].box.classList.contains("hidden"));
      if (firstLive) activeMatch = firstLive;
      else {
        const firstShown = order.map(o=>o.key).find(k => !thumbs[k].box.classList.contains("hidden"));
        if (firstShown) activeMatch = firstShown;
      }
    }

    markActive();
  }

  function setFinalBox(){
    const s1 = matches["s1"] || {};
    const s2 = matches["s2"] || {};
    const final = matches["final"] || {};

    const leftFinal  = final.left_url  || s1.winner_url || null;
    const rightFinal = final.right_url || s2.winner_url || null;

    setFinalMedia(1, leftFinal);
    setFinalMedia(2, rightFinal);

    if (final.winner_url) finalFooter.textContent = "Champion decided. Tap ⤢ for audio.";
    else if (isMatchLive("final")) finalFooter.textContent = `Final is live — first to ${WIN_TARGET} wins.`;
    else if (isMatchLive("s1") || isMatchLive("s2")) finalFooter.textContent = "Semis live — final unlocks when both winners exist.";
    else finalFooter.textContent = "Waiting…";
  }

  function computeOverallStatus(){
    const done = (key)=> !!(matches[key] && matches[key].winner_url);
    const all = (keys)=> keys.every(done);

    const rrKeys = Array.from({length:16},(_,i)=>"rr"+(i+1));
    const rKeys  = Array.from({length:8},(_,i)=>"r"+(i+1));
    const qKeys  = ["q1","q2","q3","q4"];
    const sKeys  = ["s1","s2"];

    const r32Done = all(rrKeys);
    const r16Done = all(rKeys);
    const qDone   = all(qKeys);
    const sDone   = all(sKeys);
    const fDone   = done("final");

    if (fDone) return "Final complete — champion locked.";
    if (sDone) return "Final unlocked (needs votes).";
    if (qDone) return "Semis unlocked as quarter winners appear.";
    if (r16Done) return "Quarters unlocked as R16 winners appear.";
    if (r32Done) return "R16 unlocked as R32 winners appear.";
    return `First to ${WIN_TARGET} votes wins. Matches unlock as soon as both opponents exist.`;
  }

  // ========= DB: bootstrapping =========
  async function loadCurrentCycle(){
    // Try: active cycle → else newest cycle
    let row = null;

    // Attempt a common pattern: is_active column
    try{
      const a = await supabase
        .from("cycles_v2")
        .select("*")
        .eq("is_active", true)
        .order("created_at", { ascending:false })
        .limit(1)
        .maybeSingle();
      if (!a.error && a.data) row = a.data;
    }catch(e){}

    if (!row){
      const b = await supabase
        .from("cycles_v2")
        .select("*")
        .order("created_at", { ascending:false })
        .limit(1)
        .maybeSingle();
      if (b.error) throw b.error;
      row = b.data;
    }

    if (!row) throw new Error("No cycles_v2 row found.");

    cycle = row;
    cycleId = row.id;
    metaByUrl = row.meta_by_url || row.meta_by_url_v2 || row.meta || {};
  }

  function seedUrlsFromCycle(c){
    // This matches your existing column naming.
    const keys = [
      "seed_a_url","seed_b_url","seed_c_url","seed_d_url","seed_e_url","seed_f_url","seed_g_url","seed_h_url",
      "seed_i_url","seed_j_url","seed_k_url","seed_l_url","seed_m_url","seed_n_url","seed_o_url","seed_p_url",
      "seed_q_url","seed_r_url","seed_s_url","seed_t_url","seed_u_url","seed_v_url","seed_w_url","seed_x_url",
      "seed_y_url","seed_z_url","seed_aa_url","seed_ab_url","seed_ac_url","seed_ad_url","seed_ae_url","seed_af_url"
    ];
    return keys.map(k => c?.[k] || null);
  }

  async function ensureMatchesSeeded(){
    // bracket_matches_v2: one row per match key per cycle
    // columns expected:
    // cycle_id (uuid/int), match_key (text), left_url (text), right_url (text),
    // winner_url (text), winner_side (text), updated_at (timestamptz)
    //
    // If you haven't created bracket_matches_v2 yet, you can:
    // 1) Create it in Supabase (recommended), then refresh.
    //
    // Minimal schema suggestion (run in SQL editor):
    //
    // create table if not exists public.bracket_matches_v2 (
    //   id bigserial primary key,
    //   cycle_id uuid not null,
    //   match_key text not null,
    //   left_url text,
    //   right_url text,
    //   winner_url text,
    //   winner_side text,
    //   updated_at timestamptz default now(),
    //   unique (cycle_id, match_key)
    // );
    //
    // enable row level security;
    // -- then add policies as you prefer.
    //
    // phase_votes_v2 should already exist in your project:
    // (cycle_id, match_key, side, voter_id) with unique(cycle_id, match_key, voter_id)

    const existing = await supabase
      .from("bracket_matches_v2")
      .select("match_key,left_url,right_url,winner_url,winner_side")
      .eq("cycle_id", cycleId);

    if (existing.error){
      winnerText.textContent = "Missing table: bracket_matches_v2. Create it (see SQL note in code), then refresh.";
      throw existing.error;
    }

    // build map
    matches = {};
    for (const r of (existing.data||[])){
      matches[r.match_key] = {
        left_url: r.left_url || null,
        right_url: r.right_url || null,
        winner_url: r.winner_url || null,
        winner_side: r.winner_side || null
      };
    }

    // If empty, seed leaves from cycles_v2
    const hasAny = Object.keys(matches).length > 0;
    if (!hasAny){
      const urls = seedUrlsFromCycle(cycle);

      const leafRows = [
        {match_key:"rr1",  left_url:urls[0],  right_url:urls[1]},
        {match_key:"rr2",  left_url:urls[2],  right_url:urls[3]},
        {match_key:"rr3",  left_url:urls[4],  right_url:urls[5]},
        {match_key:"rr4",  left_url:urls[6],  right_url:urls[7]},
        {match_key:"rr5",  left_url:urls[8],  right_url:urls[9]},
        {match_key:"rr6",  left_url:urls[10], right_url:urls[11]},
        {match_key:"rr7",  left_url:urls[12], right_url:urls[13]},
        {match_key:"rr8",  left_url:urls[14], right_url:urls[15]},
        {match_key:"rr9",  left_url:urls[16], right_url:urls[17]},
        {match_key:"rr10", left_url:urls[18], right_url:urls[19]},
        {match_key:"rr11", left_url:urls[20], right_url:urls[21]},
        {match_key:"rr12", left_url:urls[22], right_url:urls[23]},
        {match_key:"rr13", left_url:urls[24], right_url:urls[25]},
        {match_key:"rr14", left_url:urls[26], right_url:urls[27]},
        {match_key:"rr15", left_url:urls[28], right_url:urls[29]},
        {match_key:"rr16", left_url:urls[30], right_url:urls[31]}
      ];

      const allKeys = order.map(o=>o.key);
      const rows = allKeys.map(k=>{
        const leaf = leafRows.find(x=>x.match_key===k);
        return {
          cycle_id: cycleId,
          match_key: k,
          left_url: leaf ? leaf.left_url : null,
          right_url: leaf ? leaf.right_url : null
        };
      });

      const ins = await supabase.from("bracket_matches_v2").insert(rows);
      if (ins.error){
        winnerText.textContent = "Couldn't seed bracket_matches_v2. Check RLS/policies.";
        throw ins.error;
      }

      // reload
      const again = await supabase
        .from("bracket_matches_v2")
        .select("match_key,left_url,right_url,winner_url,winner_side")
        .eq("cycle_id", cycleId);
      if (again.error) throw again.error;

      matches = {};
      for (const r of (again.data||[])){
        matches[r.match_key] = {
          left_url: r.left_url || null,
          right_url: r.right_url || null,
          winner_url: r.winner_url || null,
          winner_side: r.winner_side || null
        };
      }
    }
  }

  async function loadCounts(){
    counts = {};
    for (const item of order){
      counts[item.key] = { left:0, right:0 };
    }

    const v = await supabase
      .from("phase_votes_v2")
      .select("match_key,side")
      .eq("cycle_id", cycleId);

    if (v.error){
      winnerText.textContent = "Couldn't read phase_votes_v2. Check table name + RLS.";
      throw v.error;
    }

    for (const row of (v.data||[])){
      const k = row.match_key;
      const s = row.side;
      if (!counts[k]) counts[k] = {left:0,right:0};
      if (s === "left") counts[k].left++;
      else if (s === "right") counts[k].right++;
    }
  }

  async function refreshAll(){
    await ensureMatchesSeeded();
    await loadCounts();
    winnerText.textContent = computeOverallStatus();
    renderActive();
    updateCurrentRoundLabel();
  }

  // ========= winner + advancement =========
  async function declareWinnerIfNeeded(matchKey){
    const m = matches[matchKey];
    if (!m) return;
    if (!isRealUrl(m.left_url) || !isRealUrl(m.right_url)) return;
    if (m.winner_url) return;

    const c = counts[matchKey] || {left:0,right:0};
    if (c.left < WIN_TARGET && c.right < WIN_TARGET) return;

    const winnerSide = (c.left >= WIN_TARGET) ? "left" : "right";
    const winnerUrl = (winnerSide === "left") ? m.left_url : m.right_url;

    // Conditional update to avoid races:
    const upd = await supabase
      .from("bracket_matches_v2")
      .update({ winner_url: winnerUrl, winner_side: winnerSide, updated_at: new Date().toISOString() })
      .eq("cycle_id", cycleId)
      .eq("match_key", matchKey)
      .is("winner_url", null);

    if (upd.error){
      return;
    }

    matches[matchKey] = Object.assign({}, m, { winner_url: winnerUrl, winner_side: winnerSide });

    const adv = ADVANCE[matchKey];
    if (adv){
      await pushWinnerToParent(adv.parent, adv.slot, winnerUrl);
    }
  }

  async function pushWinnerToParent(parentKey, slot, url){
    if (!parentKey || !slot || !url) return;
    const col = (slot === "left") ? "left_url" : "right_url";

    const upd = await supabase
      .from("bracket_matches_v2")
      .update({ [col]: url, updated_at: new Date().toISOString() })
      .eq("cycle_id", cycleId)
      .eq("match_key", parentKey)
      .is(col, null);

    if (upd.error){
      return;
    }

    const pm = matches[parentKey] || {left_url:null,right_url:null,winner_url:null,winner_side:null};
    pm[col] = url;
    matches[parentKey] = pm;
  }

  async function checkAdvancementChainFrom(matchKey){
    await declareWinnerIfNeeded(matchKey);
  }

  // ========= voting =========
  async function vote(side){
    if (!cycleId) return;

    let user = null;
    try {
      const { data } = await supabase.auth.getUser();
      user = data?.user || null;
    } catch(e) {
      user = null;
    }

    if (!user){
      alert("You need to be signed in to vote.");
      return;
    }

    if (!isMatchLive(activeMatch)){
      alert("This match isn't live yet (waiting for an opponent) or it already has a winner.");
      return;
    }

    const mem = memRead(cycleId);
    if (mem[activeMatch]) return;

    if (!counts[activeMatch]) counts[activeMatch] = {left:0,right:0};
    counts[activeMatch][side] = (counts[activeMatch][side] || 0) + 1;
    renderActive();

    const payload = {
      cycle_id: cycleId,
      match_key: activeMatch,
      side: side,
      voter_id: user.id
    };

    const ins = await supabase.from("phase_votes_v2").insert(payload);

    if (ins.error){
      counts[activeMatch][side] = Math.max(0, (counts[activeMatch][side]||0) - 1);
      renderActive();

      if (String(ins.error.message||"").toLowerCase().includes("duplicate") ||
          String(ins.error.code||"") === "23505"){
        memWrite(cycleId, activeMatch, side);
        renderActive();
        return;
      }

      alert("Vote failed (check RLS / table columns).");
      return;
    }

    memWrite(cycleId, activeMatch, side);

    await loadCounts();
    await checkAdvancementChainFrom(activeMatch);

    winnerText.textContent = computeOverallStatus();
    renderActive();
  }

  btnActive1.onclick = ()=> vote("left");
  btnActive2.onclick = ()=> vote("right");

  // AFK auto-vote is tied to the old timer/edge system. Keep buttons but disable.
  function disableAutoVoteButtons(){
    if (!autoBtn1 || !autoBtn2) return;
    autoBtn1.disabled = true;
    autoBtn2.disabled = true;
    autoBtn1.textContent = "AFK disabled";
    autoBtn2.textContent = "AFK disabled";
  }
  disableAutoVoteButtons();

  // ========= render active match =========
  function renderActive(){
    renderThumbs();
    setFinalBox();

    const mem = (cycleId ? memRead(cycleId) : {});
    const picked = mem[activeMatch];

    const m = matches[activeMatch] || {};
    const c = counts[activeMatch] || {left:0,right:0};

    let leftImg = m.left_url || placeholder("?");
    let rightImg = m.right_url || placeholder("?");

    activeLeftUrl = leftImg;
    activeRightUrl = rightImg;

    setActiveMedia("active1", leftImg);
    setActiveMedia("active2", rightImg);

    const leftMeta = metaByUrl[leftImg] || {};
    const rightMeta = metaByUrl[rightImg] || {};

    function buildLabel(defaultLabel, meta){
      const t = meta && meta.title ? String(meta.title) : "";
      const a = meta && meta.artist ? String(meta.artist) : "";
      if (!t && !a) return defaultLabel;

      let line = "";
      if (t) line += `"${escapeHtml(t)}"`;
      if (a){
        const safeA = escapeHtml(a);
        line += (line ? " · " : "") +
                `<a href="profile.html?u=${safeA}" class="artist-link">@${safeA}</a>`;
      }
      return line;
    }

    const baseLabelLeft  = `${stageNameFromKey(activeMatch)} — Top`;
    const baseLabelRight = `${stageNameFromKey(activeMatch)} — Bottom`;

    let lLab = buildLabel(baseLabelLeft, leftMeta);
    let rLab = buildLabel(baseLabelRight, rightMeta);

    if (picked==="left")  lLab += " • you voted";
    if (picked==="right") rLab += " • you voted";

    if (m.winner_url){
      if (m.winner_side === "left")  lLab += ` • WINNER`;
      if (m.winner_side === "right") rLab += ` • WINNER`;
    }

    labelActive1.innerHTML = lLab;
    labelActive2.innerHTML = rLab;

    countActive1.textContent = c.left || 0;
    countActive2.textContent = c.right || 0;

    renderPieceMeta(metaActive1, leftMeta);
    renderPieceMeta(metaActive2, rightMeta);

    const live = isMatchLive(activeMatch);
    btnActive1.disabled = !!picked || !live;
    btnActive2.disabled = !!picked || !live;

    (function updateArrows(){
      const prevBtn = document.getElementById("prevMatch");
      const nextBtn = document.getElementById("nextMatch");
      if (!prevBtn || !nextBtn) return;

      const keys = order
        .map(o => o.key)
        .filter(k => !thumbs[k].box.classList.contains("disabled")
                  && !thumbs[k].box.classList.contains("hidden"));

      const idx = keys.indexOf(activeMatch);
      prevBtn.disabled = (idx <= 0);
      nextBtn.disabled = (idx === -1 || idx >= keys.length - 1);
    })();
  }

  function gotoMatch(offset) {
    const keys = order
      .map(o => o.key)
      .filter(k => !thumbs[k].box.classList.contains("disabled")
                && !thumbs[k].box.classList.contains("hidden"));

    const idx = keys.indexOf(activeMatch);
    if (idx === -1) return;

    const nextKey = keys[idx + offset];
    if (nextKey) {
      activeMatch = nextKey;
      renderActive();
    }
  }

  const prevBtnEl = document.getElementById("prevMatch");
  const nextBtnEl = document.getElementById("nextMatch");
  if (prevBtnEl && nextBtnEl) {
    prevBtnEl.addEventListener("click", () => gotoMatch(-1));
    nextBtnEl.addEventListener("click", () => gotoMatch(1));
  }

  // ========= realtime =========
  function wireRealtime(){
    supabase.channel("phase-votes-v2-live")
      .on("postgres_changes", { event:"INSERT", schema:"public", table:"phase_votes_v2" }, async (payload)=>{
        if (!cycleId) return;
        if (payload?.new?.cycle_id !== cycleId) return;
        await loadCounts();
        await declareWinnerIfNeeded(payload.new.match_key);
        winnerText.textContent = computeOverallStatus();
        renderActive();
      })
      .subscribe();

    supabase.channel("bracket-matches-v2-live")
      .on("postgres_changes", { event:"UPDATE", schema:"public", table:"bracket_matches_v2" }, async (payload)=>{
        if (!cycleId) return;
        if (payload?.new?.cycle_id !== cycleId) return;
        const k = payload.new.match_key;
        matches[k] = {
          left_url: payload.new.left_url || null,
          right_url: payload.new.right_url || null,
          winner_url: payload.new.winner_url || null,
          winner_side: payload.new.winner_side || null
        };
        winnerText.textContent = computeOverallStatus();
        renderActive();
      })
      .subscribe();
  }

  // ========= init =========
  (async function init(){
    try{
      await initVoteUserKey();
      await loadCurrentCycle();
      await refreshAll();
      wireRealtime();
    }catch(e){
      console.warn(e);
      winnerText.textContent = "Setup error. Open console for details.";
      renderActive();
      updateCurrentRoundLabel();
    }
  })();
  </script>

  <script src="js/auth-guard.js" type="module"></script>

  <!-- ================== RAGE DEBUGGER v2 (fixed button) ================== -->
  <script>
  (function () {
    const MAX_LINES = 2000;
    const EDGE_MATCH = /\/functions\/v1\/global-timer/; // legacy (edge removed)

    // (your existing debugger code continues unchanged)
    // ...
  })();
  </script>
  <!-- ================== /RAGE DEBUGGER v2 ================== -->

</body>
</html>