<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space ‚Äî Matchup</title>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
:root{
  --green:#39ff14; --green-bright:#7dff62;
  --bg:#000; --ink:#e5e5e5;
  --card:#0b0b0b; --border:#153b16; --muted:#8aff8a; --maxw:980px;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:var(--maxw);margin:16px auto 64px;padding:0 16px}
.scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
.btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;cursor:pointer;text-decoration:none;display:inline-block;text-align:center}
.btn:hover{box-shadow:0 0 12px rgba(57,255,20,.18)}
.tiny{display:flex;gap:8px;align-items:center;font-variant-numeric:tabular-nums;font-size:12px;color:var(--muted)}
.clock{font-weight:700;border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.tile{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:rgba(7,7,7,.6);margin-top:16px;position:relative}
.art{aspect-ratio:4/3;width:100%;height:auto;display:block;object-fit:cover}
.caption{display:block;text-align:center;font-size:12px;color:var(--muted);padding:6px 8px;border-top:1px dashed var(--border)}
.meta{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-top:1px solid var(--border)}
.btn.primary.selected{background:rgba(57,255,20,.22);color:var(--ink);box-shadow:0 0 18px rgba(125,255,98,.35), inset 0 0 12px rgba(57,255,20,.15)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:14px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071c07;color:var(--green);border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:none;box-shadow:0 0 18px rgba(57,255,20,.18);z-index:50}
.toast.show{display:block}
.badge{border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge.warn{border-color:#3b1616;color:#ff6b6b}
.badge.ok{border-color:#153b16;color:#8aff8a}

/* Small Winner FX (tile pulse) */
@keyframes winPulse {
  0% { box-shadow: 0 0 0px rgba(125,255,98,.0); transform: scale(1);}
  50% { box-shadow: 0 0 36px rgba(125,255,98,.45); transform: scale(1.01);}
  100% { box-shadow: 0 0 0px rgba(125,255,98,.0); transform: scale(1);}
}
.tile.win .art { animation: winPulse 1200ms ease-in-out 2; }
.tile.win::after{
  content:"üèÅ WINNER";
  position:absolute; right:10px; top:10px;
  background:rgba(7,28,7,.9); border:1px solid var(--border);
  padding:6px 10px; border-radius:10px; font-weight:700;
}

/* ====== BIG OVERLAY BANNER ====== */
#overlay{
  position:fixed; inset:0; display:none; z-index:9999;
  background:rgba(0,0,0,0.92);
}
#overlay.show{ display:block; }

.overlay-bg{
  position:absolute; inset:0; overflow:hidden;
  filter: contrast(1.05) saturate(1.1);
}
/* Winner art backdrop (image fills screen) */
.overlay-art{
  position:absolute; inset:0;
  background-size:cover; background-position:center; background-repeat:no-repeat;
}
.overlay-art.split{
  background: linear-gradient(90deg,#a60000 50%, #0058a6 50%);
}

/* Subtle scanlines + vignette for analog vibe */
.scanlines{
  position:absolute; inset:0;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(0,0,0,0.25) 0px,
      rgba(0,0,0,0.25) 2px,
      rgba(0,0,0,0.0) 3px,
      rgba(0,0,0,0.0) 4px
    );
  mix-blend-mode:multiply;
  pointer-events:none;
}
.vignette{
  position:absolute; inset:-10%;
  background:radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.6) 100%);
  pointer-events:none;
}

/* Glitchy title card */
@keyframes titleJitter {
  0%,100% { transform: translate(0,0); }
  20% { transform: translate(1px,-1px); }
  40% { transform: translate(-1px,1px); }
  60% { transform: translate(1px,1px); }
  80% { transform: translate(-1px,-1px); }
}
.overlay-card{
  position:relative;
  max-width:min(820px, 92vw);
  margin: 8vh auto 4vh auto;
  border:1px solid var(--green);
  background:rgba(7,7,7,.72);
  border-radius:18px;
  padding:22px 18px;
  box-shadow:0 0 40px rgba(57,255,20,.25);
  animation:titleJitter 2200ms steps(2,end) infinite;
}
.overlay-card h1{
  margin:0 0 6px 0; text-align:center; letter-spacing:2px;
  font-size: clamp(28px, 6vw, 54px);
  text-transform:uppercase;
}
.overlay-card .sub{
  text-align:center; color:var(--muted); margin-bottom:12px;
  font-size: clamp(12px, 2.4vw, 14px);
}
.overlay-card .motto{
  text-align:center; margin-top:8px; color:var(--green-bright);
  font-weight:700; letter-spacing:.5px;
}

/* Close button */
#overlayClose{
  position:absolute; right:14px; top:12px; z-index:2;
  border:1px solid var(--green); background:rgba(0,0,0,.6);
  color:var(--green); border-radius:10px; padding:6px 10px; cursor:pointer;
}

/* Confetti canvas fills screen */
#confetti { position:absolute; inset:0; pointer-events:none; }

/* Tie styling tweak */
.overlay-card.tie{
  border-color:#4e4e4e; box-shadow:0 0 40px rgba(130,130,130,.25);
}
.overlay-card.tie h1{ color:#d4d4d4; }
.overlay-card.tie .motto{ color:#cfcfcf; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="scorebar">
      <div class="tiny">
        <strong>Decision in</strong>
        <span id="clock" class="clock">Sync‚Ä¶</span>
        <span id="state" class="clock">‚Äî</span>
        <span id="phaseKey" class="clock">phase: ‚Äî</span>
        <span id="loginBadge" class="badge">checking auth‚Ä¶</span>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">‚è∏Ô∏è Pause</button>
        <button id="btnForce" class="btn">üèÅ Force Decide</button>
        <a class="btn" id="openWinnersLink" href="./winners.html" target="_self" rel="noopener">üèÅ Winners</a>
        <button class="btn" id="goWinners" type="button">üß∞ Open Winners</button>
      </div>
    </div>

    <!-- ENTRY A -->
    <div class="tile" id="tileA" data-color="red">
      <img id="imgA" class="art" alt="Entry A"/>
      <div class="caption" id="countA">0 votes</div>
      <div class="meta">
        <span>Entry A</span>
        <button class="btn primary" id="voteA">Vote This</button>
      </div>
    </div>

    <!-- ENTRY B -->
    <div class="tile" id="tileB" data-color="blue">
      <img id="imgB" class="art" alt="Entry B"/>
      <div class="caption" id="countB">0 votes</div>
      <div class="meta">
        <span>Entry B</span>
        <button class="btn primary" id="voteB">Vote This</button>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="submitBtn" disabled>‚úÖ Submit Vote</button>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <!-- ===== BIG OVERLAY ===== -->
  <div id="overlay">
    <canvas id="confetti"></canvas>
    <div class="overlay-bg">
      <div id="overlayArt" class="overlay-art"></div>
      <div class="scanlines"></div>
      <div class="vignette"></div>
    </div>
    <button id="overlayClose" class="btn">‚úï</button>
    <div id="overlayCard" class="overlay-card">
      <h1 id="overlayTitle">CHAMPION</h1>
      <div class="sub" id="overlaySubtitle">Rage Space</div>
      <div class="motto">Glory to the machine. Your art devours the bracket</div>
    </div>
  </div>

<script>
/* ---------- Winners navigation (unchanged helper) ---------- */
(function(){
  const btn = document.getElementById('goWinners');
  if (!btn) return;
  btn.addEventListener('click', function(ev){
    ev.preventDefault();
    const folderHref = location.pathname.replace(/[^/]*$/, '') + 'winners.html';
    const parts = location.pathname.split('/').filter(Boolean);
    const repoRoot = parts.length ? `/${parts[0]}/` : '/';
    const rootHref = `${repoRoot}winners.html`;
    try { window.location.assign(folderHref); } catch { window.location.href = folderHref; }
    setTimeout(()=>{ try{ window.location.replace(rootHref); } catch{ window.location.href = rootHref; } }, 150);
  }, {passive:false});
})();

/* =========================
   App logic
========================= */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer`;
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const clockEl = document.getElementById('clock');
const stateEl = document.getElementById('state');
const phaseBadge = document.getElementById('phaseKey');
const loginBadge = document.getElementById('loginBadge');
const pauseBtn = document.getElementById('btnPause');
const forceBtn = document.getElementById('btnForce');
const submitBtn   = document.getElementById('submitBtn');

const tileA = document.getElementById('tileA');
const tileB = document.getElementById('tileB');
const imgA  = document.getElementById('imgA');
const imgB  = document.getElementById('imgB');
const voteA = document.getElementById('voteA');
const voteB = document.getElementById('voteB');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');

const toastEl     = document.getElementById('toast');

/* ======= BIG OVERLAY HOOKS ======= */
const overlay = document.getElementById('overlay');
const overlayClose = document.getElementById('overlayClose');
const overlayArt = document.getElementById('overlayArt');
const overlayCard = document.getElementById('overlayCard');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySubtitle = document.getElementById('overlaySubtitle');
const confetti = document.getElementById('confetti');
let confettiRAF = null;

function toast(msg, ms=1600){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), ms); }
const toIso = (d)=> new Date(d).toISOString();

let rafId = null;
let paused = false;
let remainingSec = null;
let serverPhaseEndISO = null;
let lastSyncAt = 0;
let lastCountsAt = 0;
let chosen = null; // 'red' or 'blue' (A=red, B=blue)
let lastFinishedKey = null;
let currentUid = null;

async function getUidOrNull() {
  const { data: { session } } = await supabase.auth.getSession();
  return session?.user?.id ?? null;
}
function paintLoginBadge() {
  if (currentUid) { loginBadge.textContent = "logged in"; loginBadge.classList.remove('warn'); loginBadge.classList.add('ok'); }
  else { loginBadge.textContent = "not logged in"; loginBadge.classList.remove('ok'); loginBadge.classList.add('warn'); }
}

async function callEdge(method='GET', body=null){
  const res = await fetch(EDGE_URL, {
    method,
    headers: {'Content-Type':'application/json','Authorization':`Bearer ${SUPABASE_ANON_KEY}`,'apikey': SUPABASE_ANON_KEY},
    body: body ? JSON.stringify(body) : null
  });
  const raw = await res.text(); let j=null; try{ j=JSON.parse(raw); }catch{}
  if(!res.ok) throw new Error((j && j.error) || raw || 'edge error');
  return j?.state || j || {};
}
const normalize = (s)=>({
  phase_end_at: s.phase_end_at ?? null,
  period_sec: s.period_sec ?? 10,
  paused: !!s.paused,
  remaining_sec: (typeof s.remaining_sec === 'number') ? s.remaining_sec : null
});

const fmtVotes = (n)=> `${n} ${n===1?'vote':'votes'}`;
async function countVotesForPhase(phaseKeyISO){
  const { data, error } = await supabase.from('phase_votes').select('vote').eq('phase_key', phaseKeyISO);
  if (error) throw error;
  let r=0, b=0; (data||[]).forEach(row => { if(row.vote==='red') r++; else if(row.vote==='blue') b++; });
  return {r,b};
}
async function refreshVoteCounts(){
  try{
    if(!serverPhaseEndISO) { countA.textContent = '0 votes'; countB.textContent = '0 votes'; return; }
    const phaseKey = toIso(serverPhaseEndISO);
    const { r, b } = await countVotesForPhase(phaseKey);
    countA.textContent  = fmtVotes(r);
    countB.textContent  = fmtVotes(b);
    lastCountsAt = Date.now();
  }catch(e){}
}

/* ======= IMAGE SEEDING ======= */
function seedUrl(phaseKeyISO, suffix){
  // Deterministic "random" artsy photos per phase
  const s = encodeURIComponent(`${phaseKeyISO}-${suffix}`);
  // Bigger than tile to look crisp in overlay too
  return `https://picsum.photos/seed/${s}/1600/1200`;
}
function setImagesForPhase(phaseKeyISO){
  const srcA = seedUrl(phaseKeyISO, 'A');
  const srcB = seedUrl(phaseKeyISO, 'B');
  imgA.src = srcA; imgB.src = srcB;
  imgA.loading = 'eager'; imgB.loading = 'eager';
  imgA.decoding = 'async'; imgB.decoding = 'async';
}

/* ======= WINNER / TIE VISUALS ======= */
function clearWinFX(){ tileA.classList.remove('win'); tileB.classList.remove('win'); }
function playWinnerFX(color){
  clearWinFX();
  if(color==='red') tileA.classList.add('win');
  if(color==='blue') tileB.classList.add('win');
  openWinnerOverlay(color);
}
function showTieBanner(){
  clearWinFX();
  openTieOverlay();
}

/* NEW: tie ‚Üí random winner banner */
function playTieRandomFX(color){
  clearWinFX();
  if(color==='red') tileA.classList.add('win');
  if(color==='blue') tileB.classList.add('win');
  openTieRandomOverlay(color);
}

/* Overlay open/close */
function openWinnerOverlay(color){
  const src = (color==='red') ? imgA.src : imgB.src;
  overlayArt.className = 'overlay-art';
  overlayArt.style.backgroundImage = `url("${src}")`;
  overlayCard.className = 'overlay-card';
  overlayTitle.textContent = 'CHAMPION';
  overlaySubtitle.textContent = (color==='red' ? 'Entry A prevails' : 'Entry B prevails');
  overlay.classList.add('show');
  startConfetti({mode:'win'});
}
function openTieOverlay(){
  overlayArt.className = 'overlay-art split';
  overlayArt.style.backgroundImage = '';
  overlayCard.className = 'overlay-card tie';
  overlayTitle.textContent = 'TIE';
  overlaySubtitle.textContent = 'No winner for this round';
  overlay.classList.add('show');
  startConfetti({mode:'tie'});
}
/* NEW: specific tie-random overlay with required wording */
function openTieRandomOverlay(color){
  const src = (color==='red') ? imgA.src : imgB.src;
  const which = (color==='red') ? 'Entry A' : 'Entry B';
  overlayArt.className = 'overlay-art';
  overlayArt.style.backgroundImage = `url("${src}")`;
  overlayCard.className = 'overlay-card';
  overlayTitle.textContent = `Tie... random winner picked: ${which}`;
  overlaySubtitle.textContent = (color==='red' ? 'Entry A prevails' : 'Entry B prevails');
  overlay.classList.add('show');
  startConfetti({mode:'win'});
}

function closeOverlay(){
  overlay.classList.remove('show');
  stopConfetti();
}
document.getElementById('overlayClose').addEventListener('click', closeOverlay);

/* Cyberpunk/analog confetti (pixel shards + flicker) */
function startConfetti({mode='win'}={}){
  const ctx = confetti.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const resize = ()=>{
    confetti.width = Math.floor(innerWidth * dpr);
    confetti.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  };
  resize(); window.addEventListener('resize', resize, { once:true });

  const particles = [];
  const count = mode==='win' ? 220 : 120;
  const palette = mode==='win'
    ? ['#39ff14','#7dff62','#00ffd5','#baffc9','#eaff00']
    : ['#cfcfcf','#a0a0a0','#6ad1ff','#39ff14'];

  for (let i=0;i<count;i++){
    particles.push({
      x: Math.random()*innerWidth,
      y: -10 - Math.random()*innerHeight*0.4,
      vx: (Math.random()-0.5)*2.0,
      vy: 1.2 + Math.random()*2.6,
      w: 3 + Math.floor(Math.random()*7),
      h: 3 + Math.floor(Math.random()*7),
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.2,
      color: palette[Math.floor(Math.random()*palette.length)],
      life: 120 + Math.random()*140
    });
  }

  let t=0, flicker=0;
  function step(){
    const w = innerWidth, h = innerHeight;
    confetti.width = w; confetti.height = h;
    ctx.clearRect(0,0,w,h);

    if ((t%30)===0) flicker = Math.random()*0.15;

    particles.forEach(p=>{
      p.x += p.vx; p.y += p.vy; p.rot += p.vr; p.life -= 1;
      if (p.y > h+20) { p.y = -10; p.x = Math.random()*w; }
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });

    ctx.globalAlpha = 0.08 + flicker;
    ctx.fillStyle = '#000';
    const stripe = 4;
    for (let y=0;y<h;y+=stripe){ ctx.fillRect(0,y,w,2); }
    ctx.globalAlpha = 1;

    t++;
    confettiRAF = requestAnimationFrame(step);
  }
  step();
}
function stopConfetti(){
  if (confettiRAF) cancelAnimationFrame(confettiRAF);
  confettiRAF = null;
  const ctx = confetti.getContext('2d');
  ctx.clearRect(0,0,confetti.width,confetti.height);
}

/* ======= TIMER + STATE ======= */
function setStateUI(){
  stateEl.textContent = paused ? 'PAUSED' : 'LIVE';
  pauseBtn.textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
  phaseBadge.textContent = 'phase: ' + (serverPhaseEndISO || '‚Äî');
}

async function fetchState(){
  const s = normalize(await callEdge('GET'));
  const prev = serverPhaseEndISO;
  serverPhaseEndISO = s.phase_end_at; paused = s.paused; remainingSec = s.remaining_sec; lastSyncAt = Date.now();
  setStateUI();

  if (prev && serverPhaseEndISO && prev !== serverPhaseEndISO) {
    // Phase just flipped ‚Üí finalize previous phase + load new images for the new phase
    lastFinishedKey = toIso(prev);
    chosen = null;
    voteA.classList.remove('selected'); voteB.classList.remove('selected');
    submitBtn.textContent = '‚úÖ Submit Vote'; submitBtn.disabled = true;
    countA.textContent = '0 votes'; countB.textContent = '0 votes';
    clearWinFX();
    await finalizeWinnerForKey(lastFinishedKey);
  } else {
    submitBtn.disabled = !chosen || !currentUid;
  }

  // Ensure current phase images are set
  if (serverPhaseEndISO) setImagesForPhase(toIso(serverPhaseEndISO));

  refreshVoteCounts();
}
function stop(){ if(rafId) cancelAnimationFrame(rafId); rafId=null; }
async function start(){
  stop();
  const tick = async ()=>{
    if (paused){
      const remCalc = serverPhaseEndISO ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      const sec = (typeof remainingSec === 'number' && !Number.isNaN(remainingSec)) ? Number(remainingSec) : Math.ceil(remCalc/1000);
      clockEl.textContent = String(Math.max(0, Math.ceil(sec)));
      if (Date.now() - lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
    } else {
      const rem = Math.max(0, Date.parse(serverPhaseEndISO) - Date.now());
      clockEl.textContent = String(Math.ceil(rem/1000));
      if (rem <= 0 || Date.now()-lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
      if (Date.now() - lastCountsAt > 2000) refreshVoteCounts();
    }
    rafId = requestAnimationFrame(tick);
  };
  rafId = requestAnimationFrame(tick);
}

/* ======= STRICT WINNER LOGIC (updated for tie‚Üírandom) ======= */
async function finalizeWinnerForKey(phaseKeyISO){
  try{
    const { r, b } = await countVotesForPhase(phaseKeyISO);

    // If a row already exists, use it; if counts tied, show tie-random banner using stored color
    {
      const { data, error } = await supabase
        .from('winners')
        .select('color')
        .eq('phase_key', phaseKeyISO)
        .limit(1);
      if (error) throw error;

      const existing = (data?.[0]?.color || '').toLowerCase();
      if (existing === 'red' || existing === 'blue'){
        if (r === b) { playTieRandomFX(existing); return; }
        playWinnerFX(existing); 
        return;
      }
      if (existing === 'tie'){
        // legacy rows: display old tie banner
        showTieBanner();
        return;
      }
    }

    // Decide winner
    let color;
    if (r === b){
      // Tie ‚áí random pick + store
      color = (Math.random() < 0.5) ? 'red' : 'blue';
    } else {
      color = (r > b) ? 'red' : 'blue';
    }

    // Try to write winner
    const { error: insErr } = await supabase
      .from('winners')
      .insert({ phase_key: phaseKeyISO, color })
      .select()
      .single();

    if (insErr){
      // If concurrent insert happened, read back and show
      const { data } = await supabase
        .from('winners')
        .select('color')
        .eq('phase_key', phaseKeyISO)
        .limit(1);
      const c = (data?.[0]?.color || '').toLowerCase();

      if (r === b && (c === 'red' || c === 'blue')) { playTieRandomFX(c); return; }
      if (c === 'red' || c === 'blue') { playWinnerFX(c); return; }
      if (c === 'tie') { showTieBanner(); return; }

      // Fallback: still show locally
      if (r === b){ playTieRandomFX(color); return; }
      playWinnerFX(color);
      return;
    }

    // Show overlay (tie vs normal)
    if (r === b) playTieRandomFX(color);
    else playWinnerFX(color);

  }catch(e){
    // Defensive fallbacks
    try{
      const { r, b } = await countVotesForPhase(phaseKeyISO);
      const { data } = await supabase
        .from('winners')
        .select('color')
        .eq('phase_key', phaseKeyISO)
        .limit(1);
      const c = (data?.[0]?.color || '').toLowerCase();
      if (r === b && (c==='red'||c==='blue')) playTieRandomFX(c);
      else if (c==='red'||c==='blue') playWinnerFX(c);
      else if (c==='tie') showTieBanner();
      else if (r === b) playTieRandomFX((Math.random()<0.5)?'red':'blue');
      else playWinnerFX((r>b)?'red':'blue');
    }catch(_){}
  }
}

/* --- Realtime: winners (updated to show tie‚Üírandom when tied) --- */
supabase.channel('winners-phase')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners'}, async (payload)=>{
    const rowKey = payload?.new?.phase_key;
    const color  = (payload?.new?.color || '').toLowerCase();
    if (!rowKey || !lastFinishedKey) return;
    if (toIso(rowKey) !== toIso(lastFinishedKey)) return;

    try{
      const { r, b } = await countVotesForPhase(lastFinishedKey);
      if (r === b && (color==='red' || color==='blue')) { playTieRandomFX(color); return; }
      if (color === 'tie') { showTieBanner(); return; }
      if (color === 'red' || color === 'blue'){ playWinnerFX(color); }
    }catch(_){
      if (color === 'tie') showTieBanner();
      else if (color === 'red' || color === 'blue') playWinnerFX(color);
    }
  }).subscribe();

/* --- Realtime: live vote counts for current phase --- */
supabase.channel('phase-votes-live')
  .on('postgres_changes',{event:'*',schema:'public',table:'phase_votes'}, async (payload)=>{
    try{
      const pk = payload?.new?.phase_key || payload?.old?.phase_key;
      if (!pk || !serverPhaseEndISO) return;
      if (toIso(pk) === toIso(serverPhaseEndISO)) await refreshVoteCounts();
    }catch(e){}
  }).subscribe();

/* --- Controls --- */
pauseBtn.onclick = async ()=>{ try{ if (paused) await callEdge('POST',{action:'resume'}); else await callEdge('POST',{action:'pause'}); await fetchState(); toast('OK'); }catch(e){ toast('Pause/resume failed'); }};
forceBtn.onclick = async ()=>{ try{ await callEdge('POST',{force:true}); await fetchState(); toast('Forced decision'); }catch(e){ toast('Force failed'); }};

/* --- Voting UX (A maps to 'red', B maps to 'blue') --- */
voteA.onclick  = ()=>{ chosen='red';  voteA.classList.add('selected');  voteB.classList.remove('selected'); submitBtn.disabled = !currentUid; if(!currentUid) toast('Log in to vote'); };
voteB.onclick  = ()=>{ chosen='blue'; voteB.classList.add('selected'); voteA.classList.remove('selected');  submitBtn.disabled = !currentUid; if(!currentUid) toast('Log in to vote'); };
submitBtn.onclick = async ()=>{
  if (!chosen || !serverPhaseEndISO) return;
  if (!currentUid) { toast('Log in to vote'); return; }
  try{
    const phaseKey = toIso(serverPhaseEndISO);
    const { error } = await supabase.from('phase_votes').upsert(
      { phase_key: phaseKey, vote: chosen, user_id: currentUid },
      { onConflict:'phase_key,user_id' }
    );
    if (error) throw error;
    toast('‚úî Vote submitted');
    submitBtn.textContent = '‚úî Voted';
    submitBtn.disabled = true;
    refreshVoteCounts();
  }catch(e){ toast('Vote failed'); }
};

/* --- Auth + boot --- */
(async()=>{
  try{
    currentUid = await getUidOrNull(); paintLoginBadge();
    supabase.auth.onAuthStateChange(async (_evt, session) => {
      currentUid = session?.user?.id ?? null;
      paintLoginBadge();
      submitBtn.disabled = !chosen || !currentUid;
    });
    await fetchState(); 
    if (serverPhaseEndISO) setImagesForPhase(toIso(serverPhaseEndISO));
    await start();
  }catch(e){
    clockEl.textContent='ERR'; stateEl.textContent='ERR';
  }
})();
</script>
</body>
</html>