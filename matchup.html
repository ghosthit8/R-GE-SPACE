<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rage Space — Minimal Matchup (pair-locked)</title>
  <style>
    :root { --fg:#e5e7eb; --bg:#0b0d0f; --accent:#39ff14; --muted:#8b8b8b; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,Segoe UI,Roboto,Inter,ui-sans-serif; }
    .wrap { max-width:700px; margin:0 auto; padding:16px 12px 28px; }
    h1 { margin:0 0 10px; font-size:20px; font-weight:700; letter-spacing:.5px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .timer { font-variant-numeric: tabular-nums; font-weight:700; font-size:32px; line-height:1; padding:8px 14px; border:1px solid #20242a; border-radius:12px; background:#0f1318; }
    .state { color:var(--muted); font-size:12px; }
    .card { margin-top:12px; border:1px solid #20242a; border-radius:16px; overflow:hidden; background:#0f1318; }
    .imgBox { position:relative; width:100%; aspect-ratio:3/4; background:#0b0d0f; display:grid; place-items:center; }
    .imgBox img { width:100%; height:100%; object-fit:cover; display:block; }
    .fullscreenBtn {
      position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.55);
      color:var(--accent); border:1px solid var(--accent);
      border-radius:8px; font-size:14px; padding:4px 8px;
      cursor:pointer; font-weight:700; transition:background .15s;
    }
    .fullscreenBtn:hover { background:rgba(0,0,0,0.8); }
    .bar { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; gap:8px; border-top:1px solid #20242a; }
    .label { text-transform:uppercase; letter-spacing:.12em; font-weight:700; font-size:12px; color:#a1a1a1; }
    .counts { font-variant-numeric: tabular-nums; font-weight:700; }
    .btn, .vote, .linkbtn, .backbtn {
      appearance:none; border:1px solid #24303a; background:#131920; color:var(--fg);
      padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:700; text-decoration:none; display:inline-flex; align-items:center;
    }
    .btn.ghost { color:#a0aec0; }
    button.vote { padding:10px 14px; }
    button.vote:disabled { opacity:.6; cursor:default; }
    .hint { margin-top:10px; color:#9aa0a6; font-size:12px; }
    .winner { margin-top:14px; padding:10px 12px; border:1px dashed #2a343f; border-radius:12px; color:#cbd5e1; font-size:14px; }
    .winner b { color:var(--accent); }

    /* Fullscreen overlay */
    .fullscreen-overlay {
      display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95);
      justify-content:center; align-items:center; z-index:9999;
    }
    .fullscreen-overlay img { max-width:90%; max-height:90%; border-radius:8px; }
    .fullscreen-overlay button {
      position:absolute; top:20px; right:20px; background:#111; border:1px solid var(--accent);
      color:var(--accent); padding:6px 10px; border-radius:6px; font-weight:700; cursor:pointer;
    }
  </style>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="wrap">
    <h1>Rage Space — Minimal Matchup</h1>

    <div class="header">
      <div class="row">
        <div class="timer" id="tRemain">20.0</div>
        <div class="state" id="tMeta">syncing…</div>
      </div>
      <div class="row">
        <button id="forceQueue" class="btn ghost" title="Use next 2 from queue immediately">Use Next From Queue Now</button>
        <a class="backbtn" href="menu.html">← Menu</a>
        <a class="linkbtn" href="winners.html">Winners</a>
      </div>
    </div>

    <!-- SEED A -->
    <div class="card">
      <div class="imgBox">
        <img id="imgA" alt="Seed A contender" />
        <button class="fullscreenBtn" onclick="openFull('A')">⤢</button>
      </div>
      <div class="bar">
        <div class="label">Seed A</div>
        <div class="counts" id="countA">0</div>
        <button class="vote" id="btnA">Vote Seed A</button>
      </div>
    </div>

    <!-- SEED B -->
    <div class="card">
      <div class="imgBox">
        <img id="imgB" alt="Seed B contender" />
        <button class="fullscreenBtn" onclick="openFull('B')">⤢</button>
      </div>
      <div class="bar">
        <div class="label">Seed B</div>
        <div class="counts" id="countB">0</div>
        <button class="vote" id="btnB">Vote Seed B</button>
      </div>
    </div>

    <div class="winner" id="winnerText">No winner yet — first round in progress.</div>
    <div class="hint">Timer auto-loops every ~20 s. A winner is decided at 0 (random if tied). One vote per device per round.</div>
  </div>

  <!-- fullscreen modal -->
  <div class="fullscreen-overlay" id="overlay">
    <button id="closeFull">✕ Close</button>
    <img id="fullImg" src="">
  </div>

  <script>
    // --- Supabase + runtime constants ---
    const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
    const supabase = window.supabase?.createClient ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;
    const FUNCTION_URL = `${SUPABASE_URL}/functions/v1/global-timer-v2`;

    // device id for vote limiting
    const RSID_KEY = "rsid_v2";
    let RSID = localStorage.getItem(RSID_KEY);
    if (!RSID) { RSID = (crypto.randomUUID?.() || (Math.random().toString(36).slice(2)+Date.now())); localStorage.setItem(RSID_KEY, RSID); }

    const votedKey = (b) => `voted:${b}`;
    const hasVoted = (b) => localStorage.getItem(votedKey(b)) === "1";
    const markVoted = (b) => localStorage.setItem(votedKey(b), "1");

    // pair lock helpers (avoid flicker)
    const PAIR_KEY = (b) => `pair:${b}`;
    const loadPair = (b) => { try { return JSON.parse(localStorage.getItem(PAIR_KEY(b))||"null"); } catch { return null; } };
    const savePair = (b, red, blue) => localStorage.setItem(PAIR_KEY(b), JSON.stringify({red, blue}));

    // queue claim flag
    const CLAIM_KEY = (b) => `queue_claimed:${b}`;

    // elements
    const elRemain = document.getElementById("tRemain");
    const elMeta = document.getElementById("tMeta");
    const imgA = document.getElementById("imgA");
    const imgB = document.getElementById("imgB");
    const cA = document.getElementById("countA");
    const cB = document.getElementById("countB");
    const btnA = document.getElementById("btnA");
    const btnB = document.getElementById("btnB");
    const winnerText = document.getElementById("winnerText");
    const overlay = document.getElementById("overlay");
    const fullImg = document.getElementById("fullImg");
    const btnClose = document.getElementById("closeFull");
    const forceBtn = document.getElementById("forceQueue");
    btnClose.onclick = () => overlay.style.display = 'none';

    function openFull(which) {
      const url = which === 'A' ? imgA.src : imgB.src;
      fullImg.src = url;
      overlay.style.display = 'flex';
    }

    // ---------- Queue helpers ----------
    async function fetchPendingQueue(n = 2) {
      if (!supabase) return [];
      const { data, error } = await supabase
        .from('art_queue')
        .select('id,image_url,created_at')
        .eq('status', 'pending')
        .order('created_at', { ascending: true })
        .limit(n);
      if (error) { console.warn('queue fetch error', error); return []; }
      return data || [];
    }
    async function markQueueUsed(ids = [], baseIso) {
      if (!supabase || !ids.length) return;
      const { error } = await supabase
        .from('art_queue')
        .update({ status: 'used', used_at: new Date().toISOString(), used_in_base: baseIso })
        .in('id', ids);
      if (error) console.warn('queue mark used error', error);
    }

    let state = { ends_at: null, base_iso: null, red_url: "", blue_url: "", red_count: 0, blue_count: 0, last_winner: null };

    function setVoteButtons(enabled) { btnA.disabled = btnB.disabled = !enabled; }
    function showWinner(winner) {
      if (!winner) { winnerText.textContent = "No winner yet — first round in progress."; return; }
      const by = winner.decided_by === "random_tie" ? "random tie" : "votes";
      const score = `${winner.red_count}–${winner.blue_count}`;
      const name = winner.winner_color === "red" ? "Seed A" : "Seed B";
      winnerText.innerHTML = `Last winner: <b>${name}</b> (${by}, ${score})`;
    }

    // ---------- fetch state (pair-locked & debounced) ----------
    let fetching = false;
    async function fetchState(forceQueue = false) {
      if (fetching) return; fetching = true;
      try {
        const res = await fetch(FUNCTION_URL);
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "GET failed");

        const newRound = state.base_iso && state.base_iso !== data.base_iso;
        state = data;

        // Always start from any locked pair for this base
        let locked = loadPair(state.base_iso);
        let red = locked?.red ?? state.red_url;
        let blue = locked?.blue ?? state.blue_url;

        const urlForce = new URLSearchParams(location.search).get('claim') === '1';
        const claimKey = CLAIM_KEY(state.base_iso);
        const alreadyClaimed = localStorage.getItem(claimKey) === '1';
        const shouldTryQueue = forceQueue || newRound || (!alreadyClaimed && !locked) || urlForce;

        if (shouldTryQueue) {
          try {
            const q = await fetchPendingQueue(2);
            if (q.length >= 1) red  = q[0].image_url;
            if (q.length >= 2) blue = q[1].image_url;

            const usedIds = q.slice(0, 2).map(r => r.id);
            if (usedIds.length) await markQueueUsed(usedIds, state.base_iso);

            localStorage.setItem(claimKey, '1');
            savePair(state.base_iso, red, blue);         // lock for this round
            locked = { red, blue };
            // clean ?claim=1
            if (urlForce && history.replaceState) {
              const u = new URL(location.href); u.searchParams.delete('claim');
              history.replaceState({}, '', u.toString());
            }
          } catch (e) { console.warn('queue override failed', e); }
        }

        // apply images (from lock if present)
        imgA.src = red; imgB.src = blue;
        // keep counts/metadata fresh
        cA.textContent = state.red_count; cB.textContent = state.blue_count;
        elMeta.textContent = `cycle: ${state.base_iso}`;
        showWinner(state.last_winner);

        if (newRound) setVoteButtons(!hasVoted(state.base_iso));
      } catch (e) {
        console.error(e);
      } finally {
        fetching = false;
      }
    }

    // Force button for immediate testing (ignores claim + lock)
    document.getElementById('forceQueue')?.addEventListener('click', async ()=>{
      if (!state?.base_iso) return;
      localStorage.removeItem(CLAIM_KEY(state.base_iso));
      localStorage.removeItem(PAIR_KEY(state.base_iso));
      await fetchState(true); // force pull now
    });

    // ---------- voting ----------
    async function sendVote(color) {
      const res = await fetch(FUNCTION_URL, {
        method: "POST",
        headers: { "content-type": "application/json", "x-rsid": RSID },
        body: JSON.stringify({ color }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "vote failed");
      if (data.ignored && data.reason === "already_voted") return setVoteButtons(false);
      if (!data.ignored) {
        markVoted(state.base_iso);
        setVoteButtons(false);
        cA.textContent = data.red_count;
        cB.textContent = data.blue_count;
      }
    }
    btnA.onclick = () => !btnA.disabled && sendVote("red");
    btnB.onclick = () => !btnB.disabled && sendVote("blue");

    // ---------- timer ----------
    function tick() {
      if (!state?.ends_at) return requestAnimationFrame(tick);
      const remain = new Date(state.ends_at).getTime() - Date.now();
      elRemain.textContent = (Math.max(0, remain) / 1000).toFixed(1);
      // when the server says we're ~1s past zero, refresh once (will advance base)
      if (remain <= -900) fetchState().catch(()=>{});
      requestAnimationFrame(tick);
    }

    // poll state (gentle)
    setInterval(() => fetchState().catch(()=>{}), 4000);

    (async () => {
      await fetchState();  // initial — will lock pair if unclaimed
      tick();
    })();
  </script>
</body>
</html>