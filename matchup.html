<script>
(() => {
  // === CONFIG: update only if your values are different ===
  const SUPABASE_URL  = "https://tuqvpcevrhciursxrgav.supabase.co";
  const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
  const EDGE_PATH     = "/functions/v1/global-timer";

  // === SELECTORS: point these at your existing elements ===
  const CLOCK_SEL = "#countdown, #decisionClock, #countdownMain";  // first match wins
  const PHASE_SEL = "#phaseKey, [data-phase-badge]";               // optional
  const BTN_PAUSE_SEL = "#btnPause, button#pause, .btn-pause";     // optional
  const BTN_FORCE_SEL = "#btnForceDecide, #forceDecide, .btn-force-decide"; // optional
  const STATUS_SEL = "#status, .status";                           // optional

  // === internal state ===
  let ticker = null;
  let phaseEndsAt = null;     // Date
  let phaseKey = null;        // string
  let paused = false;

  const $ = (sel) => document.querySelector(sel);
  const pick = (...sels) => {
    for (const s of sels) {
      const n = $(s);
      if (n) return n;
    }
    return null;
  };

  const clockEl = pick(CLOCK_SEL);
  const phaseEl = pick(PHASE_SEL);
  const statusEl = pick(STATUS_SEL);
  const btnPause = pick(BTN_PAUSE_SEL);
  const btnForce = pick(BTN_FORCE_SEL);

  function setText(el, txt) { if (el) el.textContent = txt; }

  async function fetchPhase() {
    try {
      setText(statusEl, "syncing…");
      const res = await fetch(SUPABASE_URL + EDGE_PATH, {
        headers: { Authorization: `Bearer ${SUPABASE_ANON}` }
      });
      const body = await res.json().catch(()=> ({}));

      const p = body?.phase;
      if (!p?.phase_key || !p?.ends_at) {
        setText(clockEl, "Sync…");
        setText(statusEl, "waiting for phase");
        return;
      }

      // When server switches phase, reset local state
      if (phaseKey !== p.phase_key) {
        phaseKey = p.phase_key;
        setText(phaseEl, phaseKey);
      }
      phaseEndsAt = new Date(p.ends_at);
      bootTicker();
      setText(statusEl, "LIVE");
    } catch (e) {
      setText(statusEl, "sync error");
      console.error("fetchPhase error", e);
    }
  }

  function bootTicker() {
    if (ticker) clearInterval(ticker);
    const tick = () => {
      if (!phaseEndsAt) { setText(clockEl, "Sync…"); return; }
      if (paused) { return; }

      const diff = phaseEndsAt.getTime() - Date.now();
      if (diff <= 0) {
        setText(clockEl, "0");
        // Ask server for the next phase and restart
        fetchPhase();
      } else {
        setText(clockEl, String(Math.floor(diff / 1000)));
      }
    };
    tick();
    ticker = setInterval(tick, 1000);
  }

  // Optional: wire your existing Pause button
  if (btnPause) {
    btnPause.addEventListener("click", () => {
      paused = !paused;
      // If unpausing, immediately tick to catch up
      if (!paused) bootTicker();
      // If you also pause the server in your code, keep that call where it is.
    });
  }

  // Optional: wire your existing Force Decide button
  if (btnForce) {
    btnForce.addEventListener("click", async () => {
      try {
        await fetch(SUPABASE_URL + EDGE_PATH, {
          method: "POST",
          headers: { Authorization: `Bearer ${SUPABASE_ANON}` }
        });
      } finally {
        fetchPhase(); // pull freshly-advanced phase
      }
    });
  }

  // Kick things off and keep it fresh
  fetchPhase();
  setInterval(fetchPhase, 10000);
})();
</script>