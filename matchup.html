<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space — Matchup</title>

<link rel="stylesheet" href="style.css"/>

<style>
body { background:#0b0f13; color:#e5e7eb; font-family:system-ui,Segoe UI,Roboto; margin:0; }
.wrap { max-width:700px; margin:auto; padding:16px 12px 96px; }

.timer { font-size:32px; padding:8px 14px; border:1px solid #20242a; border-radius:12px; background:#0f1318; }

.card { margin-top:12px; border:1px solid #20242a; border-radius:16px; overflow:hidden; background:#0f1318; }
.imgBox { aspect-ratio:3/4; background:#111; }
.imgBox img { width:100%; height:100%; object-fit:cover; }

.bar { display:flex; justify-content:space-between; padding:10px 12px; align-items:center; }
.vote { padding:10px 14px; border-radius:12px; background:#131920; border:1px solid #39ff14; color:#39ff14; cursor:pointer; }
.vote:disabled { opacity:.4; cursor:default; }

.topbar { display:flex; justify-content:space-between; align-items:center; gap:8px; margin:10px 0; }
.pill { padding:8px 12px; border-radius:999px; border:1px solid #20242a; background:#0f1318; font-size:14px; }
.btn { padding:8px 12px; border-radius:12px; border:1px solid rgba(57,255,20,.5); background:#0f1318; color:#39ff14; cursor:pointer; }
.btn:disabled { opacity:.4; cursor:default; }

.thumbs { display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-top:18px; }

.thumb{
  position:relative;
  border-radius:14px;
  overflow:hidden;
  cursor:pointer;
  background:#0f1318;
  border:1px solid rgba(57,255,20,.35);
  box-shadow:0 0 8px rgba(57,255,20,.15), inset 0 0 0 1px rgba(57,255,20,.15);
  transition:box-shadow .2s ease, transform .15s ease;
}
.thumb:hover{
  transform:translateY(-1px);
  box-shadow:0 0 14px rgba(57,255,20,.45), 0 0 32px rgba(57,255,20,.25), inset 0 0 0 1px rgba(57,255,20,.4);
}
.thumb.active{
  box-shadow:0 0 18px rgba(57,255,20,.9), 0 0 48px rgba(57,255,20,.55), inset 0 0 0 2px rgba(57,255,20,.9);
}

.thumb-img{ position:relative; width:100%; aspect-ratio:3/4; background:#0b0f13; }
.thumb-img img{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
.thumb-img img.left{ clip-path:polygon(0% 0%, 100% 0%, 0% 100%); }
.thumb-img img.right{ clip-path:polygon(100% 0%, 100% 100%, 0% 100%); }

.small{ font-size:12px; opacity:.8; }
.warn{ color:#ffcc66; }
.ok{ color:#39ff14; }
</style>
</head>

<body>
<div class="wrap">

<h1>ART BATTLE. Faction I.</h1>

<div class="timer">—</div>

<div class="topbar">
  <button class="btn" id="btnBack">← Menu</button>
  <div class="pill" id="roundLabel">Loading…</div>
  <div style="display:flex; gap:8px; align-items:center;">
    <div class="pill" id="userLabel">Not signed in</div>
    <button class="btn" id="btnSignIn">Sign in</button>
    <button class="btn" id="btnSignOut" disabled>Sign out</button>
  </div>
</div>

<div class="small" id="statusLine"></div>

<div class="card">
  <div class="imgBox"><img id="imgLeft" alt="Active top"></div>
  <div class="bar">
    <span>Top</span>
    <span id="countLeft">0</span>
    <button class="vote" id="voteLeft" disabled>Vote</button>
  </div>
</div>

<div class="card">
  <div class="imgBox"><img id="imgRight" alt="Active bottom"></div>
  <div class="bar">
    <span>Bottom</span>
    <span id="countRight">0</span>
    <button class="vote" id="voteRight" disabled>Vote</button>
  </div>
</div>

<div class="thumbs" id="thumbs"></div>

</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

/* =========================
   SUPABASE (YOUR PROJECT)
========================= */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY =
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Back to menu
const btnBack = document.getElementById("btnBack");
if (btnBack) btnBack.onclick = () => { window.location.href = "menu.html"; };

/* =========================
   DOM
========================= */
const imgLeft = document.getElementById("imgLeft");
const imgRight = document.getElementById("imgRight");
const countLeft = document.getElementById("countLeft");
const countRight = document.getElementById("countRight");
const voteLeft = document.getElementById("voteLeft");
const voteRight = document.getElementById("voteRight");
const thumbsEl = document.getElementById("thumbs");
const roundLabel = document.getElementById("roundLabel");
const userLabel = document.getElementById("userLabel");
const statusLine = document.getElementById("statusLine");
const btnSignIn = document.getElementById("btnSignIn");
const btnSignOut = document.getElementById("btnSignOut");

/* =========================
   STATE
========================= */
let sessionUser = null;

// We now load ALL rounds so we can show tiers (R32, R16, QF, SF, F)
const ROUND_NAMES = ["R32","R16","Quarterfinals","Semifinals","Final"];
let matchesByRound = [[],[],[],[],[]];

// What round is currently vote-active (lowest round with a playable undecided match)
let activeRound = 0;

// Within activeRound, which match_index is active
let activeMatchIndex = 0;

// voted matches for activeRound (user-specific)
let votedMatchIds = new Set();

// prevent jumping after vote
let keepCurrentMatch = false;

function setStatus(msg, cls=""){
  statusLine.className = "small " + cls;
  statusLine.textContent = msg;
}

function updateAuthUI(){
  if (sessionUser){
    userLabel.textContent = sessionUser.email ?? "Signed in";
    btnSignIn.disabled = true;
    btnSignOut.disabled = false;
  } else {
    userLabel.textContent = "Not signed in";
    btnSignIn.disabled = false;
    btnSignOut.disabled = true;
  }
}

/* =========================
   AUTH
========================= */
btnSignIn.onclick = async () => {
  const email = prompt("Email:");
  if (!email) return;
  const password = prompt("Password:");
  if (!password) return;

  setStatus("Signing in…");
  const { data, error } = await supabase.auth.signInWithPassword({ email, password });
  if (error){
    setStatus(error.message, "warn");
    return;
  }
  sessionUser = data.user;
  updateAuthUI();
  await refreshAll();
};

btnSignOut.onclick = async () => {
  await supabase.auth.signOut();
  sessionUser = null;
  updateAuthUI();
  await refreshAll();
};

/* =========================
   DATA
========================= */
async function loadRound(r){
  const { data, error } = await supabase
    .from("matches_v2")
    .select("*")
    .eq("round", r)
    .order("match_index");
  if (error) throw error;
  return data ?? [];
}

async function loadAllRounds(){
  const out = [];
  for (let r=0;r<5;r++){
    out.push(await loadRound(r));
  }
  return out;
}

/* Counts via RPC so counts show across accounts even with RLS */
async function loadCounts(matchId){
  const { data, error } = await supabase.rpc("get_match_counts_v2", { p_match_id: matchId });
  if (error) throw error;
  return {
    l: data?.[0]?.left_count ?? 0,
    r: data?.[0]?.right_count ?? 0
  };
}

/* Load which matches the user voted on in THIS round */
async function loadUserVotedMatchIds(userId, round){
  const set = new Set();
  if (!userId) return set;

  const { data, error } = await supabase
    .from("round_votes_v2")
    .select("match_id, round")
    .eq("user_id", userId)
    .eq("round", round);

  if (error) throw error;

  (data ?? []).forEach(row => set.add(row.match_id));
  return set;
}

function matchPlayable(m){
  // you can only vote if both sides exist and match not decided
  return !!m && !m.winner_img && !!m.left_img && !!m.right_img;
}

/* Find the lowest round that still has at least one playable match */
function detectActiveRoundFromLoaded(){
  for (let r=0;r<5;r++){
    const list = matchesByRound[r] ?? [];
    if (list.some(matchPlayable)) return r;
  }
  // If everything decided, stay at finals
  return 4;
}

/* =========================
   RENDER (main match)
========================= */
function getActiveMatch(){
  const list = matchesByRound[activeRound] ?? [];
  return list[activeMatchIndex] ?? null;
}

function render(){
  // Label shows the ACTIVE vote round, not necessarily where you tapped
  roundLabel.textContent = ROUND_NAMES[activeRound] ?? ("Round " + activeRound);

  const m = getActiveMatch();
  if (!m){
    imgLeft.removeAttribute("src");
    imgRight.removeAttribute("src");
    countLeft.textContent = "0";
    countRight.textContent = "0";
    voteLeft.disabled = true;
    voteRight.disabled = true;
    setStatus("No matches loaded.", "warn");
    renderThumbs();
    return;
  }

  imgLeft.src = m.left_img || "";
  imgRight.src = m.right_img || "";

  const alreadyVotedThisMatch = votedMatchIds.has(m.id);
  const playable = matchPlayable(m);
  const canVote = sessionUser && playable && !alreadyVotedThisMatch;

  voteLeft.disabled = !canVote;
  voteRight.disabled = !canVote;

  renderThumbs();
}

function badgeTextForMatch(m){
  if (m.winner_img) return "DECIDED";
  if (!m.left_img || !m.right_img) return "TBD";
  return "LIVE";
}

/* =========================
   THUMBS (tiered + dividers)
========================= */
function renderThumbs(){
  thumbsEl.innerHTML="";

  for (let r=0;r<5;r++){
    const section = document.createElement("div");
    section.style.gridColumn = "1 / -1";
    section.style.marginTop = r===0 ? "6px" : "16px";

    // header row with neon divider
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    header.innerHTML = `
      <div style="font-weight:700; color:#39ff14; letter-spacing:.5px;">${ROUND_NAMES[r]}</div>
      <div style="height:2px; flex:1; background:rgba(57,255,20,.55); box-shadow:0 0 10px rgba(57,255,20,.35); border-radius:999px;"></div>
    `;
    section.appendChild(header);
    thumbsEl.appendChild(section);

    const list = matchesByRound[r] ?? [];
    if (!list.length){
      const empty = document.createElement("div");
      empty.className = "small";
      empty.style.gridColumn = "1 / -1";
      empty.style.opacity = ".7";
      empty.style.margin = "6px 0 4px";
      empty.textContent = "No matches yet.";
      thumbsEl.appendChild(empty);
      continue;
    }

    list.forEach((m,i)=>{
      const isActive = (r===activeRound && i===activeMatchIndex);
      const t=document.createElement("div");
      const playable = matchPlayable(m);
      const decided = !!m.winner_img;
      const badge = badgeTextForMatch(m);

      t.className = "thumb"+(isActive?" active":"");
      t.style.opacity = decided ? ".55" : (playable ? "1" : ".75");

      // overlay label
      t.innerHTML = `
        <div class="thumb-img">
          ${m.left_img ? `<img class="left" src="${m.left_img}">` : `<div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#9ca3af;">TBD</div>`}
          ${m.right_img ? `<img class="right" src="${m.right_img}">` : ``}
          ${!m.right_img ? `<div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#9ca3af;">TBD</div>` : ``}
          <div style="position:absolute; left:8px; top:8px; font-size:11px; padding:4px 8px; border-radius:999px; background:rgba(15,19,24,.85); border:1px solid rgba(57,255,20,.35); color:${badge==='LIVE' ? '#39ff14' : (badge==='TBD' ? '#ffcc66' : '#9ca3af')};">
            ${badge}
          </div>
        </div>
      `;

      // Click rules:
      // - If it's the active vote round: allow switching to playable or decided (just to view)
      // - If it's a future round with TBD opponent: allow selecting for preview but disable voting
      t.onclick=async()=>{
        activeRound = r;
        activeMatchIndex = i;
        votedMatchIds = await loadUserVotedMatchIds(sessionUser?.id, activeRound);

        render();
        await refreshCounts();
        updateStatusLine();
      };

      thumbsEl.appendChild(t);
    });
  }
}

/* =========================
   COUNTS + STATUS
========================= */
async function refreshCounts(){
  const m = getActiveMatch();
  if (!m) return;

  // If a side is missing, show zeros and bail
  if (!m.left_img || !m.right_img){
    countLeft.textContent = "0";
    countRight.textContent = "0";
    return;
  }

  const c = await loadCounts(m.id);
  countLeft.textContent = c.l;
  countRight.textContent = c.r;

  // If counts hit 2 but winner isn't marked yet, try to advance (server-side)
  if (!m.winner_img && (c.l >= 2 || c.r >= 2)){
    try{
      await supabase.rpc("advance_match_v2", { p_match_id: m.id });
    } catch(e){
      // If RPC doesn't exist / permissions, we still show counts.
      console.warn("advance_match_v2 failed:", e);
    }
  }
}

function updateStatusLine(){
  const m = getActiveMatch();
  if (!m) return;

  if (!sessionUser){
    setStatus("Sign in to vote. (You can vote once per match.)");
    return;
  }

  if (m.winner_img){
    setStatus("This match is decided. Pick another matchup.", "warn");
    return;
  }

  if (!m.left_img || !m.right_img){
    setStatus("Waiting for an opponent (TBD). Voting is locked until both sides exist.", "warn");
    return;
  }

  if (votedMatchIds.has(m.id)){
    setStatus("You already voted in THIS matchup. You can vote in other matchups.", "warn");
    return;
  }

  setStatus("You can vote once in this matchup. First to 2 wins.", "ok");
}

/* =========================
   VOTE
========================= */
async function castVote(side){
  const m = getActiveMatch();
  if (!m || !sessionUser) return;

  if (!m.left_img || !m.right_img){
    setStatus("This match is waiting for an opponent (TBD).", "warn");
    return;
  }

  if (m.winner_img){
    setStatus("This match is already decided.", "warn");
    return;
  }

  if (votedMatchIds.has(m.id)){
    setStatus("Already voted in this matchup.", "warn");
    return;
  }

  setStatus("Submitting vote…");

  const { error } = await supabase
    .from("round_votes_v2")
    .insert({
      user_id: sessionUser.id,
      round: activeRound,
      match_id: m.id,
      side
    });

  if (error){
    if (String(error.code) === "23505"){
      votedMatchIds.add(m.id);
      setStatus("Already voted in this matchup (DB enforced).", "warn");
      keepCurrentMatch = true;
      await refreshAll();
      return;
    }
    setStatus("Vote failed: " + error.message, "warn");
    return;
  }

  votedMatchIds.add(m.id);
  setStatus("Vote submitted.", "ok");

  // NEW: auto-advance if 2 votes reached (server-side)
  try{
    await supabase.rpc("advance_match_v2", { p_match_id: m.id });
  }catch(e){
    console.warn("advance_match_v2 failed:", e);
  }

  keepCurrentMatch = true;
  await refreshAll();
}

voteLeft.onclick=()=>castVote("left");
voteRight.onclick=()=>castVote("right");

/* =========================
   REFRESH
========================= */
async function refreshAll(){
  try{
    const { data: sess, error: sessErr } = await supabase.auth.getSession();
    if (sessErr) throw sessErr;

    sessionUser = sess?.session?.user ?? null;
    updateAuthUI();

    // Remember current match id (only when keepCurrentMatch is true)
    const prevMatchId = keepCurrentMatch ? (getActiveMatch()?.id ?? null) : null;

    matchesByRound = await loadAllRounds();

    // Set active voting round based on loaded data (playable match exists)
    const autoActive = detectActiveRoundFromLoaded();

    // If user tapped a different round manually, keep it (preview mode),
    // but if that round has no playable matches, auto-set to vote-active.
    if (activeRound == null) activeRound = autoActive;

    // If we're previewing a future round with TBD, don't force them away.
    // But if activeRound is older than autoActive (shouldn't happen) or has no matches, snap to autoActive.
    const currentList = matchesByRound[activeRound] ?? [];
    if (!currentList.length){
      activeRound = autoActive;
    }

    // restore match if possible
    if (keepCurrentMatch && prevMatchId){
      const list = matchesByRound[activeRound] ?? [];
      const idx = list.findIndex(mm => mm.id === prevMatchId);
      if (idx >= 0){
        activeMatchIndex = idx;
      }
      keepCurrentMatch = false;
    }

    // If active match is out of range, pick first playable, else 0
    const list = matchesByRound[activeRound] ?? [];
    if (!list[activeMatchIndex]){
      const firstPlayable = list.findIndex(matchPlayable);
      activeMatchIndex = firstPlayable >= 0 ? firstPlayable : 0;
    }

    votedMatchIds = await loadUserVotedMatchIds(sessionUser?.id, activeRound);

    render();
    await refreshCounts();
    updateStatusLine();
  } catch(e){
    console.error(e);
    setStatus("Load error: " + (e?.message ?? e), "warn");
  }
}

await refreshAll();


</body>
</html>