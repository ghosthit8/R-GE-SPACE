<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space — Matchup</title>
<link rel="preconnect" href="https://tuqvpcevrhciursxrgav.supabase.co">
<script src="https://unpkg.com/@supabase/supabase-js@2">
/* ---- Robust decided-rows visibility controller (injected) ---- */
(function(){
  function byId(id){ return document.getElementById(id); }
  const showDone = byId('showDone');
  const bracketEl = byId('bracket');
  const brows = byId('brows');

  function updateDecidedVisibility(){
    if (!brows || !showDone) return;
    const hide = !showDone.checked;
    // Toggle container class (CSS fallback) and inline style (authoritative)
    if (bracketEl){
      bracketEl.classList.toggle('hide-done', hide);
    }
    const rows = brows.querySelectorAll('.brow.decided');
    rows.forEach(el => {
      // Inline style wins no matter what stylesheet says
      el.style.display = hide ? 'none' : '';
    });
  }

  if (showDone){
    // Restore saved preference (default: show = true)
    try{
      const saved = localStorage.getItem('rs_show_done');
      if (saved === '0') showDone.checked = false;
    }catch(e){}
    showDone.addEventListener('change', function(){
      try{ localStorage.setItem('rs_show_done', showDone.checked ? '1' : '0'); }catch(e){}
      updateDecidedVisibility();
    });
  }

  // Watch the bracket list for re-renders and re-apply
  if (brows && 'MutationObserver' in window){
    const mo = new MutationObserver(updateDecidedVisibility);
    mo.observe(brows, {childList:true, subtree:true});
  }

  // Initial kick (double-tap for async content)
  updateDecidedVisibility();
  setTimeout(updateDecidedVisibility, 400);
})();
/* ---- /Robust decided-rows visibility controller ---- */

</script>
<style>
/* Hide the R32/R16/QF/SF/Final Left/Right labels under each image */
#labelA, #labelB { display: none; }
:root{ --green:#39ff14; --green-bright:#7dff62; --bg:#000; --ink:#e5e5e5; --card:#0b0b0b; --border:#153b16; --muted:#8aff8a; --maxw:980px; --danger:#ff3b3b; }
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:var(--maxw);margin:16px auto 64px;padding:0 16px}

/* top bar */
.scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
.btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;cursor:pointer;text-decoration:none;display:inline-block;text-align:center}
.btn:hover{box-shadow:0 0 12px rgba(57,255,20,.18)}
.btn:disabled{opacity:.45;cursor:not-allowed;box-shadow:none}
.tiny{display:flex;gap:8px;align-items:center;font-variant-numeric:tabular-nums;font-size:12px;color:var(--muted)}
.clock{font-weight:700;border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge{border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge.warn{border-color:#3b1616;color:#ff6b6b}
.badge.ok{border-color:#153b16;color:#8aff8a}

/* current match tiles */
.tile{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:rgba(7,7,7,.6);margin-top:16px;position:relative}
.tile.decided::after{
  content:"DECIDED";
  position:absolute; bottom:10px; left:10px;
  background:rgba(0,0,0,.6);
  border:1px solid var(--danger); color:#ff6b6b;
  font-weight:700; letter-spacing:2px; font-size:12px;
  padding:4px 8px; border-radius:8px; pointer-events:none;
}

/* Fullscreen control on each image */
.artbox{position:relative}
.art{aspect-ratio:4/3;width:100%;height:auto;display:block;object-fit:cover}
.fsbtn{
  position:absolute; top:8px; right:8px;
  background:rgba(0,0,0,.6); color:var(--green);
  border:1px solid var(--green); border-radius:8px;
  padding:4px 8px; cursor:pointer; font-size:14px; line-height:1;
}

/* fullscreen overlay */
#fsOverlay{
  position:fixed; inset:0; display:none;
  background:rgba(0,0,0,.95);
  align-items:center; justify-content:center;
  z-index:10000;
}
#fsOverlay.show{display:flex}
#fsImage{
  max-width:95%; max-height:95%;
  box-shadow:0 0 40px rgba(57,255,20,.25);
  border:1px solid var(--green); border-radius:12px;
}
#fsClose{
  position:absolute; top:12px; right:14px; z-index:1;
  border:1px solid var(--green); background:rgba(0,0,0,.6); color:var(--green);
  border-radius:8px; padding:4px 10px; cursor:pointer; font-size:16px;
}

.caption{display:block;text-align:center;font-size:12px;color:var(--muted);padding:6px 8px;border-top:1px dashed var(--border)}
.meta{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-top:1px solid var(--border)}
.btn.primary.selected{background:rgba(57,255,20,.22);color:var(--ink);box-shadow:0 0 18px rgba(125,255,98,.35), inset 0 0 12px rgba(57,255,20,.15)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:14px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071c07;color:var(--green);border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:none;box-shadow:0 0 18px rgba(57,255,20,.18);z-index:50}
.toast.show{display:block}

/* ===== Winner Overlay (art clean, frame, typewriter) ===== */
#overlay{
  position:fixed; inset:0; display:none;
  background:rgba(0,0,0,.92);
  align-items:center; justify-content:center;
  z-index:9999; overflow:hidden;
}
#overlay.show{display:flex}
#confetti{position:absolute; inset:0; pointer-events:none; z-index:3}

/* stage + art */
.overlay-bg{position:absolute; inset:0; overflow:hidden}
.overlay-stage{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:2}
.art-wrap{position:relative; display:inline-block; max-width:92vw; max-height:78vh}
.art-wrap img{max-width:100%; max-height:100%; object-fit:contain; display:block}

/* GLITCHY SCANLINE FRAME (around the image, not over it) */
.scanline-frame{ --frame:28px; pointer-events:none; position:absolute; inset:0; }
.scanline-frame .band{
  position:absolute; background:
    repeating-linear-gradient(to right,
      rgba(57,255,20,.38) 0 2px, transparent 2px 4px),
    linear-gradient(90deg, rgba(0,0,0,.35), rgba(0,0,0,.35));
  filter: drop-shadow(0 0 8px rgba(57,255,20,.35));
  animation: glitchShift 1.2s steps(6,end) infinite, flicker 2.6s steps(20,end) infinite;
}
.scanline-frame .top{   left:calc(-1*var(--frame)); right:calc(-1*var(--frame)); top:calc(-1*var(--frame)); height:var(--frame); }
.scanline-frame .bottom{left:calc(-1*var(--frame)); right:calc(-1*var(--frame)); bottom:calc(-1*var(--frame)); height:var(--frame); }
.scanline-frame .left{  top:calc(-1*var(--frame)); bottom:calc(-1*var(--frame)); left:calc(-1*var(--frame)); width:var(--frame); background:
    repeating-linear-gradient(to bottom,
      rgba(57,255,20,.38) 0 2px, transparent 2px 4px),
    linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.35)); }
.scanline-frame .right{ top:calc(-1*var(--frame)); bottom:calc(-1*var(--frame)); right:calc(-1*var(--frame)); width:var(--frame); background:
    repeating-linear-gradient(to bottom,
      rgba(57,255,20,.38) 0 2px, transparent 2px 4px),
    linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.35)); }

@keyframes glitchShift{
  0%{ background-position:0 0, 0 0 }
  50%{ background-position:12px 0, 0 0 }
  100%{ background-position:0 0, 0 0 }
}
@keyframes flicker{
  0%,100%{ opacity:1 }
  5%{ opacity:.75 }
  10%{ opacity:.9 }
  15%{ opacity:.6 }
  22%{ opacity:.95 }
  35%{ opacity:.7 }
  55%{ opacity:1 }
}

/* ambient layers BEHIND image */
.scanlines-behind{position:absolute; inset:0; z-index:1; background:repeating-linear-gradient(to bottom, rgba(0,0,0,.25) 0, rgba(0,0,0,.25) 2px, transparent 3px, transparent 4px)}
.vignette{position:absolute; inset:-10%; z-index:1; background:radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,.6) 100%)}

/* champion card pinned to bottom */
.overlay-card{
  position:absolute; left:50%; bottom:24px; transform:translateX(-50%);
  max-width:min(820px,92vw);
  border:1px solid var(--green); background:rgba(7,7,7,.72);
  border-radius:18px; padding:22px 18px;
  box-shadow:0 0 40px rgba(57,255,20,.25);
  text-align:center; z-index:4;
}
.overlay-card h1{margin:0 8px 6px; letter-spacing:2px; font-size:clamp(28px,6vw,54px); text-transform:uppercase}
.overlay-card .sub{color:var(--muted); margin:0 8px 8px; font-size:clamp(12px,2.4vw,14px); min-height:1.4em}
.overlay-card .motto{color:var(--green-bright); font-weight:700; letter-spacing:.5px; min-height:1.4em}

/* typewriter look + caret */
.typewriter-text{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  letter-spacing: 0;
  line-height: 1.35;
}
.type-caret{ border-right:2px solid var(--green); animation: caretBlink .9s steps(1,end) infinite; }
@keyframes caretBlink{ 50%{ border-right-color:transparent } }

#overlayClose{
  position:absolute; right:14px; top:12px; z-index:5;
  border:1px solid var(--green); background:rgba(0,0,0,.6); color:var(--green);
  border-radius:10px; padding:6px 10px; cursor:pointer
}

/* BRACKET under the current match */
.bracket{margin-top:20px; border:1px solid var(--border); border-radius:14px; background:rgba(7,7,7,.5); overflow:hidden}
.bracket-head{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--border)}
.bracket-title{font-weight:700; font-size:18px}
.switch{display:flex; align-items:center; gap:8px; color:var(--muted); font-size:13px}

/* compact rows (no expand) */
.brow{position:relative; display:grid; grid-template-columns:auto auto 1fr auto; gap:10px 12px; padding:12px 14px; border-top:1px solid var(--border); cursor:pointer; align-items:center}
.brow:first-child{border-top:0}
.brow.active{outline:2px solid var(--danger); outline-offset:-2px; background:rgba(255,59,59,.07)}
.brow.decided::after{
  content:"DECIDED";
  position:absolute; right:14px; top:50%; transform:translateY(-50%);
  font-weight:900; letter-spacing:2px; border:2px solid var(--danger);
  color:#ff6b6b; padding:2px 10px; border-radius:10px; opacity:.95; pointer-events:none;
}
.brow.decided .bline, .brow.decided .bpill, .brow.decided .title{color:#7a7a7a}
.brow.decided .bscore{opacity:.7}

.thumb2{display:flex; gap:8px}
.thumb{width:44px;height:44px;border-radius:10px;overflow:hidden;border:1px solid var(--border);background:rgba(0,0,0,.35)}
.thumb img{width:100%;height:100%;object-fit:cover;display:block}
.bmeta{display:flex; flex-direction:column; gap:4px; min-width:0}
.bline{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
.bbadge{border:1px solid var(--border); border-radius:999px; padding:2px 8px; font-size:12px}
.bpill{color:var(--muted); font-size:13px}
.bscore{font-variant-numeric:tabular-nums; font-size:18px; justify-self:end}
.title{font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
.small{font-size:12px; color:var(--muted)}
.tabs{display:none}

/* ======= CYBERPUNK BOOT LOADER ======= */
#bootLoader{
  position:fixed; inset:0; z-index:10000;
  background: radial-gradient(120% 120% at 50% 0%, rgba(0,255,120,.08), rgba(0,0,0,.96) 60%), #000;
  display:flex; align-items:center; justify-content:center; flex-direction:column;
  color:var(--green); font-variant-numeric:tabular-nums; text-align:center;
  transition:opacity .35s ease, visibility .35s ease;
}
#bootLoader.hidden{ opacity:0; visibility:hidden; pointer-events:none }
.boot-title{letter-spacing:2px; text-transform:uppercase; margin-bottom:12px; font-size:14px}
.boot-bar{width:min(560px,90vw); height:12px; border:1px solid var(--green); border-radius:999px; overflow:hidden; background:rgba(0,255,120,.07)}
.boot-fill{height:100%; width:0%; background:linear-gradient(90deg, var(--green), var(--green-bright)); box-shadow:0 0 18px rgba(57,255,20,.35) inset}
.boot-sub{margin-top:8px; color:var(--muted); font-size:12px}

/* Hide decided rows when the toggle is off (fallback) */
#bracket.hide-done .brow.decided{ display:none; }

</style>
</head>
<body>

<!-- CYBERPUNK LOADING OVERLAY -->
<div id="bootLoader" aria-live="polite">
  <div class="boot-title">Rage Space — syncing…</div>
  <div class="boot-bar"><div class="boot-fill" id="bootFill"></div></div>
  <div class="boot-sub" id="bootMsg">initializing</div>
</div>

  <div class="wrap">
    <div class="scorebar">
      <div class="tiny">
        <strong>Decision in</strong>
        <span id="clock" class="clock">Sync…</span>
        <span id="state" class="clock">—</span>
        <span id="phaseKey" class="clock">phase: —</span>
        <span id="loginBadge" class="badge">checking auth…</span>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">⏸️ Pause</button>
        <a class="btn" href="./winners.html">🏁 Winners</a>
      </div>
    </div>

    <!-- Current Match -->
    <div class="tile" id="tileA" data-color="red">
      <div class="artbox">
        <img id="imgA" class="art" alt="Entry Left"/>
        <button class="fsbtn" data-target="imgA" title="View fullscreen">⛶</button>
      </div>
      <div class="caption" id="countA">0 votes</div>
      <div class="meta">
        <span id="labelA">Left</span>
        <button class="btn primary" id="voteA">Vote This</button>
      </div>
    </div>

    <div class="tile" id="tileB" data-color="blue">
      <div class="artbox">
        <img id="imgB" class="art" alt="Entry Right"/>
        <button class="fsbtn" data-target="imgB" title="View fullscreen">⛶</button>
      </div>
      <div class="caption" id="countB">0 votes</div>
      <div class="meta">
        <span id="labelB">Right</span>
        <button class="btn primary" id="voteB">Vote This</button>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="submitBtn" disabled>✅ Submit Vote</button>
    </div>

    <!-- Bracket list -->
    <section class="bracket" id="bracket">
      <div class="bracket-head">
        <div class="bracket-title">Bracket</div>
        <label class="switch">
          <input id="showDone" type="checkbox" />
          <span>Show finished rounds</span>
        </label>
      </div>
      <div id="brows"></div>
    </section>
  </div>

  <div id="toast" class="toast"></div>

  <!-- FINAL OVERLAY -->
  <div id="overlay">
    <canvas id="confetti"></canvas>
    <div class="overlay-bg">
      <div class="scanlines-behind"></div>
      <div class="vignette"></div>

      <div class="overlay-stage">
        <div class="art-wrap">
          <img id="overlayArtImg" alt="Winning Art"/>
          <div class="scanline-frame">
            <div class="band top"></div>
            <div class="band bottom"></div>
            <div class="band left"></div>
            <div class="band right"></div>
          </div>
        </div>
      </div>
    </div>

    <button id="overlayClose" class="btn">✕</button>
    <div class="overlay-card" id="overlayCard">
      <h1 id="overlayTitle">CHAMPION</h1>
      <div class="sub typewriter-text" id="overlaySubtitle"></div>
      <div class="motto typewriter-text" id="overlayMotto"></div>
    </div>
  </div>

  <!-- Fullscreen overlay -->
  <div id="fsOverlay">
    <button id="fsClose">✕</button>
    <img id="fsImage" alt="Fullscreen Art"/>
  </div>

<script>
/* ---------- Setup ---------- */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer`;
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const clockEl = document.getElementById('clock');
const stateEl = document.getElementById('state');
const phaseBadge = document.getElementById('phaseKey');
const loginBadge = document.getElementById('loginBadge');
const pauseBtn = document.getElementById('btnPause');
const toastEl = document.getElementById('toast');
function toast(msg, ms=1400){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); }
const iso = (d)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,'Z');

const imgA  = document.getElementById('imgA');
const imgB  = document.getElementById('imgB');
const labelA = document.getElementById('labelA');
const labelB = document.getElementById('labelB');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');
const voteA = document.getElementById('voteA');
const voteB = document.getElementById('voteB');
const submitBtn = document.getElementById('submitBtn');

const overlay = document.getElementById('overlay');
const overlayArtImg = document.getElementById('overlayArtImg');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySubtitle = document.getElementById('overlaySubtitle');
const overlayMotto = document.getElementById('overlayMotto');
const overlayClose = document.getElementById('overlayClose');
const confettiCanvas = document.getElementById('confetti');

/* Fullscreen overlay refs */
const fsOverlay = document.getElementById('fsOverlay');
const fsImage   = document.getElementById('fsImage');
const fsClose   = document.getElementById('fsClose');

/* bracket DOM */
const brows = document.getElementById('brows');
const showDone = document.getElementById('showDone');

/* ---------- State ---------- */
let paused=false, serverPhaseEndISO=null, currentPhaseKey=null, prevPhaseKey=null, periodSec=20, remainingSec=null, lastSyncAt=0, lastCountsAt=0;
let currentUid=null, chosen=null;

/* NEW: 32-entrant flow */
let activeSlot='r32_1'; // 'r32_1'..'r32_16' | 'r16_1'..'r16_8' | 'qf1'..'qf4' | 'sf1'|'sf2' | 'final'
let currentStage='r32'; // 'r32'|'r16'|'qf'|'sf'|'final'
let overlayGateBase=null; // base ISO allowed to trigger champion

// Freeze images per battle: "<baseISO>::slot" → {A,B}
const imgCache = new Map();
let lastPaintedBattleKey=null;

/* ---------- Boot Loader helper ---------- */
const bootFill = ()=>document.getElementById('bootFill');
const bootMsg  = ()=>document.getElementById('bootMsg');
const bootWrap = ()=>document.getElementById('bootLoader');
let _bootTarget = 0, _bootTimer=null;

function setBoot(p, msg){
  _bootTarget = Math.max(_bootTarget, Math.min(100, p));
  if (msg) bootMsg().textContent = msg;
}
function startBootTick(){
  if (_bootTimer) return;
  _bootTimer = setInterval(()=>{
    const el = bootFill();
    const cur = parseFloat(el.style.width||'0');
    const toward = (_bootTarget>cur) ? (cur + Math.max(1,( _bootTarget-cur)*0.12)) : (cur + 0.18);
    el.style.width = Math.min(99, toward).toFixed(2) + '%';
  }, 60);
}
function endBoot(){
  clearInterval(_bootTimer); _bootTimer=null;
  bootFill().style.width='100%';
  setTimeout(()=> bootWrap().classList.add('hidden'), 280);
}

/* ---------- Helpers ---------- */
async function getUidOrNull(){ const {data:{session}}=await supabase.auth.getSession(); return session?.user?.id ?? null; }
function paintLoginBadge(){ if(currentUid){loginBadge.textContent='logged in'; loginBadge.classList.add('ok'); loginBadge.classList.remove('warn');} else {loginBadge.textContent='not logged in'; loginBadge.classList.add('warn'); loginBadge.classList.remove('ok');} }

async function callEdge(method='GET', body=null){
  const res = await fetch(EDGE_URL,{method,headers:{'Content-Type':'application/json','Authorization':`Bearer ${SUPABASE_ANON_KEY}`,'apikey':SUPABASE_ANON_KEY},body:body?JSON.stringify(body):null});
  const raw = await res.text(); let j=null; try{ j=JSON.parse(raw);}catch{}
  if(!res.ok) throw new Error((j&&j.error)||raw||'edge error');
  return j?.state || j || {};
}
const normalize=(s)=>({phase_end_at:s.phase_end_at??null, period_sec:s.period_sec??20, paused:!!s.paused, remaining_sec:(typeof s.remaining_sec==='number')?s.remaining_sec:null});

/* deterministic seeds */
function seedUrlFromKey(baseISO, suffix){ const s=encodeURIComponent(`${baseISO}-${suffix}`); return `https://picsum.photos/seed/${s}/1600/1200`; }

function r32KeysFor(baseISO){
  const o={}; for(let i=1;i<=16;i++) o[`r32_${i}`]=`${baseISO}::r32_${i}`; return o;
}
function r16KeysFor(baseISO){
  const o={}; for(let i=1;i<=8;i++) o[`r16_${i}`]=`${baseISO}::r16_${i}`; return o;
}
function qfKeysFor(baseISO){ return { qf1:`${baseISO}::qf1`, qf2:`${baseISO}::qf2`, qf3:`${baseISO}::qf3`, qf4:`${baseISO}::qf4` }; }
function semiKeysFor(baseISO){ return { sf1:`${baseISO}::sf1`, sf2:`${baseISO}::sf2` }; }
function finalKeyFor(baseISO){ return `${baseISO}::final`; }

const stageOfSlot = (slot)=>{
  if (slot.startsWith('r32')) return 'r32';
  if (slot.startsWith('r16')) return 'r16';
  if (slot.startsWith('qf'))  return 'qf';
  if (slot.startsWith('sf'))  return 'sf';
  return 'final';
};
const stageLevel = (st)=> st==='r32'?1 : (st==='r16'?2 : (st==='qf'?3 : (st==='sf'?4 : 5)));
const slotLevel  = (slot)=> stageLevel(stageOfSlot(slot));

function baseAtOffset(n){
  if (!currentPhaseKey) return null;
  const t = Date.parse(currentPhaseKey) - Math.max(0,n)*periodSec*1000;
  return iso(t);
}
function baseForSlot(slot){
  const curLv = stageLevel(currentStage||'r32');
  const needLv = slotLevel(slot);
  const delta = curLv - needLv; // 0 = this phase, 1..4 = previous phases back
  if (delta <= 0) return currentPhaseKey;
  return baseAtOffset(delta);
}
function baseForCompletedStage(stage){
  const curLv = stageLevel(currentStage||'r32');
  const needLv = stageLevel(stage);
  const delta = curLv - needLv;
  if (delta <= 0) return null;
  return baseAtOffset(delta);
}

/* ---------- Stage detection ---------- */
async function detectStage(){
  if (!currentPhaseKey || !prevPhaseKey) return {stage:'r32'};

  // If previous base has both SF winners → we're in FINAL
  const { data:sfW } = await supabase.from('winners').select('phase_key').in('phase_key', [ `${prevPhaseKey}::sf1`, `${prevPhaseKey}::sf2` ]);
  if ((sfW||[]).length===2) return {stage:'final'};

  // Else if previous base has all QF winners → we're in SF
  const { data:qfW } = await supabase.from('winners').select('phase_key').in('phase_key',
    [ `${prevPhaseKey}::qf1`, `${prevPhaseKey}::qf2`, `${prevPhaseKey}::qf3`, `${prevPhaseKey}::qf4` ]);
  if ((qfW||[]).length===4) return {stage:'sf'};

  // Else if previous base has all R16 winners → we're in QF
  const r16Keys = Array.from({length:8}, (_,i)=> `${prevPhaseKey}::r16_${i+1}`);
  const { data:r16W } = await supabase.from('winners').select('phase_key').in('phase_key', r16Keys);
  if ((r16W||[]).length===8) return {stage:'qf'};

  // Else if previous base has all R32 winners → we're in R16
  const r32Keys = Array.from({length:16}, (_,i)=> `${prevPhaseKey}::r32_${i+1}`);
  const { data:r32W } = await supabase.from('winners').select('phase_key').in('phase_key', r32Keys);
  if ((r32W||[]).length===16) return {stage:'r16'};

  // Else → still in R32
  return {stage:'r32'};
}

/* ---------- Build entrants from previous winners ---------- */
/* R16 entrants from R32 winners (pairs: 1/2, 3/4, ..., 15/16) */
async function getR16EntrantSourcesFromR32Winners(which /* 'r16_1'..'r16_8' */){
  const r32Base = baseForCompletedStage('r32');
  if (!r32Base) return null;

  const idx = Number(which.split('_')[1]); // 1..8
  const pair = [idx*2-1, idx*2]; // [1,2], [3,4], ...
  const keys = pair.map(i=>`${r32Base}::r32_${i}`);
  const { data } = await supabase.from('winners').select('phase_key,color').in('phase_key', keys);
  const map = Object.fromEntries((data||[]).map(r=>[r.phase_key, r.color]));

  const pickFromR32 = (i, color)=> seedUrlFromKey(r32Base, color==='red' ? `A${i}` : `B${i}`);

  const cA = map[keys[0]];
  const cB = map[keys[1]];
  if (!(cA && cB)) return null;

  return { A: pickFromR32(pair[0], cA), B: pickFromR32(pair[1], cB) };
}

/* QF entrants from R16 winners (pairs: r16_1/2 → qf1, 3/4 → qf2, 5/6 → qf3, 7/8 → qf4) */
async function getQFEntrantSourcesFromR16Winners(which /* 'qf1'|'qf2'|'qf3'|'qf4' */){
  const r16Base = baseForCompletedStage('r16');
  if (!r16Base) return null;

  const slots = {
    qf1:['r16_1','r16_2'],
    qf2:['r16_3','r16_4'],
    qf3:['r16_5','r16_6'],
    qf4:['r16_7','r16_8'],
  }[which];
  if (!slots) return null;

  const keys = slots.map(s=>`${r16Base}::${s}`);
  const { data } = await supabase.from('winners').select('phase_key,color').in('phase_key', keys);
  const colors = Object.fromEntries((data||[]).map(r=>[r.phase_key, r.color]));

  async function r16Pack(slot /* 'r16_1'..'r16_8' */){
    const key = `${r16Base}::${slot}`;
    if (imgCache.has(key)) return imgCache.get(key);
    // rebuild from R32 winners
    const rebuilt = await getR16EntrantSourcesFromR32Winners(slot);
    if (rebuilt) imgCache.set(key, rebuilt);
    return rebuilt;
  }

  const pL = await r16Pack(slots[0]);
  const pR = await r16Pack(slots[1]);
  if (!(pL && pR)) return null;

  const leftSrc  = (String(colors[keys[0]]).toLowerCase()==='red') ? pL.A : pL.B;
  const rightSrc = (String(colors[keys[1]]).toLowerCase()==='red') ? pR.A : pR.B;
  return { A: leftSrc, B: rightSrc };
}

/* SF entrants from QF winners (rebuild QF packs from R16 winners) */
async function getSemiEntrantSourcesFromQFWinners(which /* 'sf1'|'sf2' */){
  const qfBase = baseForCompletedStage('qf');
  if (!qfBase) return null;

  const slots = which==='sf1' ? ['qf1','qf2'] : ['qf3','qf4'];
  const keys = slots.map(s=>`${qfBase}::${s}`);
  const { data: winRows } = await supabase.from('winners').select('phase_key,color').in('phase_key', keys);
  const colors = Object.fromEntries((winRows||[]).map(r=>[r.phase_key, (r.color||'').toLowerCase()]));
  if (!(colors[keys[0]] && colors[keys[1]])) return null;

  async function qfPack(slot /* 'qf1'..'qf4' */){
    const key = `${qfBase}::${slot}`;
    if (imgCache.has(key)) return imgCache.get(key);
    const rebuilt = await getQFEntrantSourcesFromR16Winners(slot);
    if (rebuilt) imgCache.set(key, rebuilt);
    return rebuilt;
  }

  const pLeft  = await qfPack(slots[0]);
  const pRight = await qfPack(slots[1]);
  if (!(pLeft && pRight)) return null;

  const leftSrc  = (colors[keys[0]]==='red') ? pLeft.A : pLeft.B;
  const rightSrc = (colors[keys[1]]==='red') ? pRight.A : pRight.B;
  return { A: leftSrc, B: rightSrc };
}

/* Final entrants from SF winners (rebuild SF packs from QF winners) */
async function getFinalEntrantSourcesFromWinners(){
  const sfBase = baseForCompletedStage('sf');
  if (!sfBase) return null;

  const { sf1, sf2 } = semiKeysFor(sfBase);
  const { data: winRows } = await supabase
    .from('winners')
    .select('phase_key,color')
    .in('phase_key', [sf1, sf2]);

  const colors = Object.fromEntries((winRows||[]).map(r => [r.phase_key, (r.color||'').toLowerCase()]));
  const c1 = colors[sf1];
  const c2 = colors[sf2];
  if (!(c1 && c2)) return null;

  async function sfPack(slot /* 'sf1'|'sf2' */){
    const key = `${sfBase}::${slot}`;
    if (imgCache.has(key)) return imgCache.get(key);
    const rebuilt = await getSemiEntrantSourcesFromQFWinners(slot);
    if (rebuilt) imgCache.set(key, rebuilt);
    return rebuilt;
  }

  const p1 = await sfPack('sf1');
  const p2 = await sfPack('sf2');
  if (!(p1 && p2)) return null;

  const leftFinal  = (c1 === 'red') ? p1.A : p1.B;
  const rightFinal = (c2 === 'red') ? p2.A : p2.B;

  return { A: leftFinal, B: rightFinal };
}

/* ---------- Votes ---------- */
const fmtVotes=(n)=>`${n} ${n===1?'vote':'votes'}`;
function currentBattleKey(){
  const base = baseForSlot(activeSlot);
  if (!base) return null;
  if (activeSlot==='final') return `${base}::final`;
  return `${base}::${activeSlot}`;
}
async function countVotesFor(key){
  const { data, error } = await supabase.from('phase_votes').select('vote').eq('phase_key', key);
  if (error) throw error;
  let r=0,b=0; (data||[]).forEach(row=>{ if(row.vote==='red') r++; else if(row.vote==='blue') b++; });
  return {r,b};
}
async function refreshVoteCounts(){
  try{
    const key=currentBattleKey();
    if(!key){ countA.textContent='0 votes'; countB.textContent='0 votes'; return; }
    const {r,b}=await countVotesFor(key);
    countA.textContent=fmtVotes(r);
    countB.textContent=fmtVotes(b);
    lastCountsAt=Date.now();
    updateBracketScores();
  }catch{}
}

/* ---------- Decide & persist winner ---------- */
async function decideAndPersistWinner(phaseKeyISO){
  const { r, b } = await countVotesFor(phaseKeyISO);
  const color = (r===b) ? (Math.random()<0.5?'red':'blue') : (r>b?'red':'blue');
  const { error:insErr } = await supabase.from('winners').insert({phase_key: phaseKeyISO, color}).select().single();
  if (insErr){
    const { data } = await supabase.from('winners').select('color').eq('phase_key', phaseKeyISO).limit(1);
    const c=(data?.[0]?.color||'').toLowerCase();
    if (c==='red'||c==='blue') return c;
  }
  return color;
}

/* ---------- Confetti (one burst; stop after 5s) ---------- */
let _confettiRaf=null;
function startConfetti(){
  const ctx=confettiCanvas.getContext('2d');
  const W=()=> (confettiCanvas.width = innerWidth);
  const H=()=> (confettiCanvas.height = innerHeight);
  W(); H();

  const cx = confettiCanvas.width/2;
  const cy = confettiCanvas.height/3;

  const N = 280;
  const parts = Array.from({length:N}, ()=> {
    const ang = Math.random()*Math.PI*2;
    const spd = 3 + Math.random()*7;
    return {
      x: cx, y: cy,
      vx: Math.cos(ang)*spd,
      vy: Math.sin(ang)*spd,
      w: 3+Math.floor(Math.random()*7),
      h: 3+Math.floor(Math.random()*7),
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.3,
      color: ['#39ff14','#7dff62','#00ffd5','#baffc9','#eaff00'][Math.floor(Math.random()*5)]
    };
  });

  function step(){
    W(); H();
    ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
    parts.forEach(p=>{
      p.vy += 0.04;         // gravity
      p.vx *= 0.995; p.vy *= 0.995; // drag
      p.x += p.vx; p.y += p.vy; p.rot += p.vr;

      // wrap around
      if (p.x < -20) p.x = confettiCanvas.width + 20;
      if (p.x > confettiCanvas.width + 20) p.x = -20;
      if (p.y < -20) p.y = confettiCanvas.height + 20;
      if (p.y > confettiCanvas.height + 20) p.y = -20;

      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.fillStyle=p.color; ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
      ctx.restore();
    });
    _confettiRaf = requestAnimationFrame(step);
  }
  cancelAnimationFrame(_confettiRaf);
  step();
  setTimeout(()=> stopConfetti(), 5000);
}
function stopConfetti(){
  if (_confettiRaf) cancelAnimationFrame(_confettiRaf);
  _confettiRaf = null;
  const c=confettiCanvas.getContext('2d');
  c.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
}

/* ---------- Typewriter ---------- */
let _typewriterToken = 0;
async function typewriter(el, text, speed=85){
  const myToken = ++_typewriterToken;
  el.textContent = '';
  el.classList.add('type-caret');
  for (let i=0;i<text.length;i++){
    if (myToken !== _typewriterToken) return;
    el.textContent += text[i];
    await new Promise(r=>setTimeout(r, speed));
  }
  if (myToken === _typewriterToken) el.classList.remove('type-caret');
}

/* ---------- Show champion (Final only) ---------- */
let _openChampionBase = null;
function showChampion(color, finalBaseISO){
  if (_openChampionBase === finalBaseISO && overlay.classList.contains('show')) return;
  _openChampionBase = finalBaseISO;

  const finalKey = finalKeyFor(finalBaseISO);
  const cached = imgCache.get(finalKey) || {};
  const src = (color==='red') ? (cached.A || imgA.src) : (cached.B || imgB.src);
  overlayArtImg.src = src;

  overlayTitle.textContent = 'CHAMPION';

  countVotesFor(finalKey).then(({ r, b }) => {
    const sub = (r === b)
      ? 'Tie… random winner picked'
      : ((color === 'red') ? 'Winner<3' : 'Winner<3');

    const motto = 'Glory to the machine. Your art devours the bracket';

    overlaySubtitle.textContent = '';
    overlayMotto.textContent = '';

    overlay.classList.add('show');
    startConfetti();

    (async ()=>{
      await typewriter(overlaySubtitle, sub,   95);
      await typewriter(overlayMotto,   motto,  85);
    })();
  });
}

overlayClose.onclick=()=>{ 
  overlay.classList.remove('show'); 
  stopConfetti(); 
  overlayArtImg.removeAttribute('src');
  overlaySubtitle.textContent = '';
  overlayMotto.textContent = '';
  _typewriterToken++;            // cancel any in-flight typing
  _openChampionBase = null;      // allow next final
};

/* ---------- Fullscreen viewer ---------- */
function openFullscreenFor(imgEl){
  if (!imgEl || !imgEl.src) return;
  fsImage.src = imgEl.src;
  fsOverlay.classList.add('show');
}
document.querySelectorAll('.fsbtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const targetId = btn.dataset.target;
    const imgEl = document.getElementById(targetId);
    openFullscreenFor(imgEl);
  });
});
fsClose.addEventListener('click', ()=>{
  fsOverlay.classList.remove('show');
  fsImage.src = '';
});
fsOverlay.addEventListener('click', (e)=>{
  if (e.target === fsOverlay){ fsOverlay.classList.remove('show'); fsImage.src=''; }
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape' && fsOverlay.classList.contains('show')){
    fsOverlay.classList.remove('show'); fsImage.src='';
  }
});

/* ---------- Timer / phase handling ---------- */
function setStateUI(){ stateEl.textContent = paused ? 'PAUSED' : 'LIVE'; pauseBtn.textContent = paused ? '▶️ Resume' : '⏸️ Pause'; phaseBadge.textContent='phase: '+(currentPhaseKey||'—'); }

function slotFinished(slot){
  return slotLevel(slot) < stageLevel(currentStage||'r32');
}
function votingLockedFor(slot){
  return slotLevel(slot) !== stageLevel(currentStage||'r32');
}
function applyVotingLockUI(){
  const locked = votingLockedFor(activeSlot);
  [voteA, voteB, submitBtn].forEach(b=> b.disabled = locked || !currentUid);
  // Show DECIDED ribbon only if this slot is finished (older round)
  const finished = slotFinished(activeSlot);
  document.getElementById('tileA').classList.toggle('decided', finished);
  document.getElementById('tileB').classList.toggle('decided', finished);
  submitBtn.textContent = locked ? (finished?'Voting closed':'Not started') : '✅ Submit Vote';
}

/* paint images for the chosen slot */
async function paintImagesForActive(){
  const slot = activeSlot;
  const base = baseForSlot(slot);
  if (!base) return;

  const bKey = `${base}::${slot}`;
  if (imgCache.has(bKey)){
    const {A,B}=imgCache.get(bKey); imgA.src=A; imgB.src=B;
  } else {
    if (slot.startsWith('r32')){
      const idx = Number(slot.split('_')[1]); // 1..16
      const A = seedUrlFromKey(base, `A${idx}`);
      const B = seedUrlFromKey(base, `B${idx}`);
      imgCache.set(bKey,{A,B}); imgA.src=A; imgB.src=B;
    } else if (slot.startsWith('r16')){
      const pack = await getR16EntrantSourcesFromR32Winners(slot);
      if (pack){ imgCache.set(bKey,pack); imgA.src=pack.A; imgB.src=pack.B; }
      else { imgA.removeAttribute('src'); imgB.removeAttribute('src'); }
    } else if (slot.startsWith('qf')){
      const pack = await getQFEntrantSourcesFromR16Winners(slot);
      if (pack){ imgCache.set(bKey,pack); imgA.src=pack.A; imgB.src=pack.B; }
      else { imgA.removeAttribute('src'); imgB.removeAttribute('src'); }
    } else if (slot==='sf1' || slot==='sf2'){
      const pack = await getSemiEntrantSourcesFromQFWinners(slot);
      if (pack){ imgCache.set(bKey,pack); imgA.src=pack.A; imgB.src=pack.B; }
      else { imgA.removeAttribute('src'); imgB.removeAttribute('src'); }
    } else { // final
      const finals = await getFinalEntrantSourcesFromWinners();
      if (finals){ imgCache.set(bKey, finals); imgA.src=finals.A; imgB.src=finals.B; }
      else { imgA.removeAttribute('src'); imgB.removeAttribute('src'); }
    }
  }

  // Labels (kept for accessibility; visually hidden by CSS)
  if (slot.startsWith('r32')){
    const n = slot.split('_')[1];
    labelA.textContent=`R32 ${n} — Left`;
    labelB.textContent=`R32 ${n} — Right`;
  } else if (slot.startsWith('r16')){
    const n = slot.split('_')[1];
    labelA.textContent=`R16 ${n} — Left`;
    labelB.textContent=`R16 ${n} — Right`;
  } else if (slot.startsWith('qf')){
    const n = slot.slice(2);
    labelA.textContent=`QF ${n} — Left`;
    labelB.textContent=`QF ${n} — Right`;
  } else if (slot==='sf1' || slot==='sf2'){
    const n = slot.slice(2);
    labelA.textContent=`SF ${n} — Left`;
    labelB.textContent=`SF ${n} — Right`;
  } else {
    labelA.textContent='Final — Left';
    labelB.textContent='Final — Right';
  }

  imgA.loading='eager'; imgB.loading='eager'; imgA.decoding='async'; imgB.decoding='async';
  lastPaintedBattleKey=bKey;

  renderBracket();
  applyVotingLockUI();
}

async function fetchState(){
  const prevEnd = serverPhaseEndISO;
  const prevStage = currentStage;

  const s = normalize(await callEdge('GET'));
  serverPhaseEndISO = s.phase_end_at;
  paused = s.paused;
  remainingSec = s.remaining_sec;
  periodSec = s.period_sec ?? 20;
  lastSyncAt = Date.now();

  currentPhaseKey = serverPhaseEndISO ? iso(serverPhaseEndISO) : null;
  prevPhaseKey = currentPhaseKey && periodSec ? iso(Date.parse(currentPhaseKey) - periodSec*1000) : null;

  setStateUI();

  // Phase flip
  if (prevEnd && serverPhaseEndISO && prevEnd !== serverPhaseEndISO){
    const justEndedBase = iso(prevEnd);

    if (prevStage === 'final'){
      // FINAL just ended
      const finalKey = finalKeyFor(justEndedBase);
      const color = await decideAndPersistWinner(finalKey);
      if (!imgCache.has(finalKey)){ const pack = await getFinalEntrantSourcesFromWinners(); if (pack) imgCache.set(finalKey, pack); }
      if (overlayGateBase === justEndedBase) showChampion(color, justEndedBase);

      // Loop back: next phase is fresh R32
      overlayGateBase = null;
      activeSlot = 'r32_1';
      imgCache.clear(); lastPaintedBattleKey=null;

    } else if (prevStage === 'sf'){
      // SFs just ended → record SF winners and move to FINAL
      const { sf1, sf2 } = semiKeysFor(justEndedBase);
      await decideAndPersistWinner(sf1);
      await decideAndPersistWinner(sf2);

      overlayGateBase = currentPhaseKey; // final that just started
      activeSlot = 'final';
      const pack = await getFinalEntrantSourcesFromWinners();
      if (pack) imgCache.set(finalKeyFor(currentPhaseKey), pack);
      lastPaintedBattleKey=null;

    } else if (prevStage === 'qf'){
      // QFs just ended → record all 4 and move to SF
      const { qf1,qf2,qf3,qf4 } = qfKeysFor(justEndedBase);
      await Promise.all([
        decideAndPersistWinner(qf1),
        decideAndPersistWinner(qf2),
        decideAndPersistWinner(qf3),
        decideAndPersistWinner(qf4),
      ]);

      activeSlot = 'sf1';
      const pack1 = await getSemiEntrantSourcesFromQFWinners('sf1');
      const pack2 = await getSemiEntrantSourcesFromQFWinners('sf2');
      if (pack1) imgCache.set(`${currentPhaseKey}::sf1`, pack1);
      if (pack2) imgCache.set(`${currentPhaseKey}::sf2`, pack2);
      lastPaintedBattleKey=null;

    } else if (prevStage === 'r16'){
      // R16 just ended → record all 8 and move to QF
      const r16 = r16KeysFor(justEndedBase);
      await Promise.all(Object.values(r16).map(k=>decideAndPersistWinner(k)));

      activeSlot = 'qf1';
      const qp1 = await getQFEntrantSourcesFromR16Winners('qf1');
      const qp2 = await getQFEntrantSourcesFromR16Winners('qf2');
      const qp3 = await getQFEntrantSourcesFromR16Winners('qf3');
      const qp4 = await getQFEntrantSourcesFromR16Winners('qf4');
      if (qp1) imgCache.set(`${currentPhaseKey}::qf1`, qp1);
      if (qp2) imgCache.set(`${currentPhaseKey}::qf2`, qp2);
      if (qp3) imgCache.set(`${currentPhaseKey}::qf3`, qp3);
      if (qp4) imgCache.set(`${currentPhaseKey}::qf4`, qp4);
      lastPaintedBattleKey=null;

    } else {
      // R32 just ended → record all 16 and move to R16
      const r32 = r32KeysFor(justEndedBase);
      await Promise.all(Object.values(r32).map(k=>decideAndPersistWinner(k)));

      activeSlot = 'r16_1';
      // seed R16 thumbnails cache for current base
      for (let i=1;i<=8;i++){
        const slot = `r16_${i}`;
        const pack = await getR16EntrantSourcesFromR32Winners(slot);
        if (pack) imgCache.set(`${currentPhaseKey}::${slot}`, pack);
      }
      lastPaintedBattleKey=null;
    }
  }

  const { stage } = await detectStage();
  currentStage = stage;

  await paintImagesForActive();
  await refreshVoteCounts();
  renderBracket();
  applyVotingLockUI();
}

/* ---------- Bracket list rendering (compact) ---------- */
function labelFor(slot){
  if (slot.startsWith('r32')){
    const n = Number(slot.split('_')[1]);
    const seeds = ['A vs B','C vs D','E vs F','G vs H','I vs J','K vs L','M vs N','O vs P',
                   'Q vs R','S vs T','U vs V','W vs X','Y vs Z','AA vs AB','AC vs AD','AE vs AF'];
    return {round:'R32', title:`Seed ${seeds[n-1] || 'A vs B'}`};
  }
  if (slot.startsWith('r16')){
    const n = Number(slot.split('_')[1]);
    const seeds = ['R32 1/2','R32 3/4','R32 5/6','R32 7/8','R32 9/10','R32 11/12','R32 13/14','R32 15/16'];
    return {round:'R16', title:`Winners of ${seeds[n-1] || 'R32'}`};
  }
  if (slot.startsWith('qf')){
    const labels = {qf1:'Winners of R16 1/2', qf2:'Winners of R16 3/4', qf3:'Winners of R16 5/6', qf4:'Winners of R16 7/8'};
    return {round:'QF', title: labels[slot] || 'Quarter Finals'};
  }
  if (slot==='sf1' || slot==='sf2') return {round:'SF', title:'Semifinals'};
  return {round:'Final', title:'TBD vs TBD'};
}
function slotKeyFor(slot, baseISO){
  if (slot==='final') return finalKeyFor(baseISO);
  return `${baseISO}::${slot}`;
}

/* thumbnails reflect actual battles */
async function thumbsFor(slot){
  const base = baseForSlot(slot);
  if (!base) return {A:'',B:''};
  const key = slotKeyFor(slot, base);

  if (imgCache.has(key)) return imgCache.get(key);

  if (slot.startsWith('r32')){
    const idx = Number(slot.split('_')[1]);
    const pack = { A: seedUrlFromKey(base, `A${idx}`), B: seedUrlFromKey(base, `B${idx}`) };
    imgCache.set(key, pack); return pack;
  }
  if (slot.startsWith('r16')){
    const pack = await getR16EntrantSourcesFromR32Winners(slot);
    if (pack){ imgCache.set(key, pack); return pack; }
    return {A:'',B:''};
  }
  if (slot.startsWith('qf')){
    const pack = await getQFEntrantSourcesFromR16Winners(slot);
    if (pack){ imgCache.set(key, pack); return pack; }
    return {A:'',B:''};
  }
  if (slot==='sf1' || slot==='sf2'){
    const pack = await getSemiEntrantSourcesFromQFWinners(slot);
    if (pack){ imgCache.set(key, pack); return pack; }
    return {A:'',B:''};
  }
  // final
  const finals = await getFinalEntrantSourcesFromWinners();
  if (finals){ imgCache.set(key, finals); return finals; }
  return {A:'',B:''};
}

function rowId(slot){ return `row-${slot}`; }

function switchTo(slot){
  activeSlot = slot;
  clearSelection();
  lastPaintedBattleKey=null;
  paintImagesForActive();
  refreshVoteCounts();
  highlightActiveRow();
  applyVotingLockUI();
}

function highlightActiveRow(){
  document.querySelectorAll('.brow').forEach(el=>el.classList.remove('active'));
  const r = document.getElementById(rowId(activeSlot));
  r && r.classList.add('active');
}

async function updateBracketScores(){
  const slots = [
    'r32_1','r32_2','r32_3','r32_4','r32_5','r32_6','r32_7','r32_8',
    'r32_9','r32_10','r32_11','r32_12','r32_13','r32_14','r32_15','r32_16',
    'r16_1','r16_2','r16_3','r16_4','r16_5','r16_6','r16_7','r16_8',
    'qf1','qf2','qf3','qf4','sf1','sf2','final'
  ];
  for (const slot of slots){
    const base = baseForSlot(slot);
    if (!base) continue;
    const key = slotKeyFor(slot, base);
    const sEl = document.querySelector(`#${rowId(slot)} .bscore`);
    if (!sEl) continue;
    try{
      const {r,b}=await countVotesFor(key);
      sEl.textContent = `${r} - ${b}`;
    }catch{
      sEl.textContent = `0 - 0`;
    }
  }
}

async function finalSeedsTitle(){
  if (currentStage==='final' || currentStage==='sf' || currentStage==='qf' || currentStage==='r16'){
    const sfBase = baseForCompletedStage('sf');
    if (!sfBase) return 'TBD vs TBD';
    const { data } = await supabase.from('winners').select('phase_key,color')
      .in('phase_key',[ `${sfBase}::sf1`, `${sfBase}::sf2` ]);
    const map = Object.fromEntries((data||[]).map(r=>[r.phase_key, r.color]));
    return (map[`${sfBase}::sf1`] && map[`${sfBase}::sf2`]) ? 'Finalists decided' : 'TBD vs TBD';
  }
  return 'TBD vs TBD';
}

async function renderBracket(){
  const base = currentPhaseKey;
  if (!base){ brows.innerHTML=''; return; }

  const rowsOrder = [
    'r32_1','r32_2','r32_3','r32_4','r32_5','r32_6','r32_7','r32_8',
    'r32_9','r32_10','r32_11','r32_12','r32_13','r32_14','r32_15','r32_16',
    'r16_1','r16_2','r16_3','r16_4','r16_5','r16_6','r16_7','r16_8',
    'qf1','qf2','qf3','qf4','sf1','sf2','final'
  ];
  const titlesFinal = await finalSeedsTitle();

  const rows = await Promise.all(rowsOrder.map(async (slot)=>{
    const round = labelFor(slot).round;
    const title = (slot==='final') ? titlesFinal : labelFor(slot).title;
    const thumbs = await thumbsFor(slot);
    const decided = slotFinished(slot);
    const pillText = decided ? 'round decided' : (slotLevel(slot)===stageLevel(currentStage)?'':'locked');
    return `
      <div class="brow ${decided?'decided':''}" id="${rowId(slot)}" data-slot="${slot}">
        <div class="bbadge">${round}</div>
        <div class="thumb2">
          <div class="thumb">${thumbs.A ? `<img src="${thumbs.A}" alt="">` : ''}</div>
          <div class="thumb">${thumbs.B ? `<img src="${thumbs.B}" alt="">` : ''}</div>
        </div>
        <div class="bmeta">
          <div class="title">${title}</div>
          <div class="bline">
            <span class="bpill">${pillText}</span>
          </div>
        </div>
        <div class="bscore">0 - 0</div>
      </div>
    `;
  }));

  brows.innerHTML = rows.join('');
  highlightActiveRow();
  updateBracketScores();

  brows.querySelectorAll('.brow').forEach(row=>{
    row.addEventListener('click',()=> switchTo(row.dataset.slot));
  });
}

/* ---------- Loops ---------- */
let rafId=null;
function stop(){ if(rafId) cancelAnimationFrame(rafId); rafId=null; }
async function start(){
  stop();
  const loop = async ()=>{
    if (paused){
      const remCalc = currentPhaseKey ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      const sec = (typeof remainingSec==='number' && !Number.isNaN(remainingSec)) ? Number(remainingSec) : Math.ceil(remCalc/1000);
      clockEl.textContent = String(Math.max(0, Math.ceil(sec)));
      if (Date.now()-lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
    } else {
      const rem = serverPhaseEndISO ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
      clockEl.textContent = String(Math.ceil(rem/1000));
      if (rem<=0 || Date.now()-lastSyncAt>5000) { try{ await fetchState(); }catch{} }
      if (Date.now()-lastCountsAt>2000) refreshVoteCounts();
    }
    rafId = requestAnimationFrame(loop);
  };
  rafId = requestAnimationFrame(loop);
}

/* ---------- Realtime ---------- */
supabase.channel('winners-final-overlay')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners'},(payload)=>{
    const key = payload?.new?.phase_key || '';
    const color = (payload?.new?.color||'').toLowerCase();
    if (!key.endsWith('::final')) return;
    const base = key.split('::')[0];
    if (!overlayGateBase || base !== overlayGateBase) return;
    if (!(color==='red'||color==='blue')) return;

    if (!imgCache.has(finalKeyFor(base))){
      getFinalEntrantSourcesFromWinners().then(pack=>{
        if (pack) imgCache.set(finalKeyFor(base), pack);
        showChampion(color, base);
      });
    } else {
      showChampion(color, base);
    }
  }).subscribe();

supabase.channel('phase-votes-live')
  .on('postgres_changes',{event:'*',schema:'public',table:'phase_votes'}, async (payload)=>{
    const pk = payload?.new?.phase_key || payload?.old?.phase_key;
    if (!pk) return;
    updateBracketScores();
    const want = currentBattleKey();
    if (pk && want && pk===want) await refreshVoteCounts();
  }).subscribe();

/* ---------- Controls / Voting ---------- */
pauseBtn.onclick = async ()=>{ try{ if (paused) await callEdge('POST',{action:'resume'}); else await callEdge('POST',{action:'pause'}); await fetchState(); toast('OK'); }catch{ toast('Pause/resume failed'); }};

function clearSelection(){ voteA.classList.remove('selected'); voteB.classList.remove('selected'); chosen=null; submitBtn.textContent='✅ Submit Vote'; submitBtn.disabled=!currentUid; }
voteA.onclick=()=>{ if (votingLockedFor(activeSlot)) return toast(slotFinished(activeSlot)?'Voting closed':'Not started'); chosen='red'; voteA.classList.add('selected'); voteB.classList.remove('selected'); submitBtn.disabled=!currentUid; };
voteB.onclick=()=>{ if (votingLockedFor(activeSlot)) return toast(slotFinished(activeSlot)?'Voting closed':'Not started'); chosen='blue'; voteB.classList.add('selected'); voteA.classList.remove('selected'); submitBtn.disabled=!currentUid; };
submitBtn.onclick=async()=>{
  if (votingLockedFor(activeSlot)) return toast(slotFinished(activeSlot)?'Voting closed':'Not started');
  const key=currentBattleKey();
  if (!chosen || !key) return;
  if (!currentUid){ toast('Log in to vote'); return; }
  try{
    const { error } = await supabase.from('phase_votes').upsert(
      { phase_key:key, vote:chosen, user_id: currentUid },
      { onConflict:'phase_key,user_id' }
    );
    if (error) throw error;
    toast('✔ Vote submitted');
    submitBtn.textContent='✔ Voted';
    submitBtn.disabled=true;
    refreshVoteCounts();
  }catch{ toast('Vote failed'); }
};

/* ---------- Boot (with staged loader) ---------- */
(async()=>{
  startBootTick();           setBoot(5,'wiring auth');
  currentUid = await getUidOrNull(); paintLoginBadge();
  supabase.auth.onAuthStateChange((_evt, session)=>{ currentUid=session?.user?.id ?? null; paintLoginBadge(); submitBtn.disabled=!chosen||!currentUid; });

  setBoot(35,'fetching state');
  await fetchState();

  setBoot(58,'seeding images');
  await paintImagesForActive();

  setBoot(74,'loading vote counts');
  await refreshVoteCounts();

  setBoot(92,'starting engine');
  await start();

  setBoot(100,'ready');
  endBoot();
})();
</script>
<script>
/* ===== Rage Space: Show/Hide Finished Rounds (drop-in) =====
   Paste this block before </body>. No other edits required. */

(function(){
  // 1) Ensure CSS exists (injected once)
  (function injectCSS(){
    if (document.getElementById('rs_hide_done_css')) return;
    const css = document.createElement('style');
    css.id = 'rs_hide_done_css';
    css.textContent = `
      /* Hide decided rows when bracket has .hide-done */
      #bracket.hide-done .brow.decided{ display:none !important; }
    `;
    document.head.appendChild(css);
  })();

  // 2) Locate or create bracket container + list
  const bracketEl = document.getElementById('bracket')
                    || document.querySelector('.bracket')
                    || (function(){ const s=document.createElement('section'); s.className='bracket'; s.id='bracket'; document.body.appendChild(s); return s; })();

  let brows = document.getElementById('brows') || bracketEl.querySelector('#brows');
  if (!brows){
    brows = document.createElement('div');
    brows.id = 'brows';
    bracketEl.appendChild(brows);
  }

  // 3) Inject a header with the toggle if not present
  let head = bracketEl.querySelector('.bracket-head');
  if (!head){
    head = document.createElement('div');
    head.className = 'bracket-head';
    const title = document.createElement('div');
    title.className = 'bracket-title';
    title.textContent = 'Bracket';
    head.appendChild(title);
    bracketEl.insertBefore(head, bracketEl.firstChild);
  }

  let showDone = document.getElementById('showDone');
  if (!showDone){
    const label = document.createElement('label');
    label.className = 'switch';
    label.style.cssText = 'margin-left:auto;display:flex;align-items:center;gap:8px';

    showDone = document.createElement('input');
    showDone.type = 'checkbox';
    showDone.id = 'showDone';

    const span = document.createElement('span');
    span.textContent = 'Show finished rounds';

    // restore preference (default = show)
    try{
      const saved = localStorage.getItem('rs_show_done');
      showDone.checked = saved !== '0';
    }catch(e){ showDone.checked = true; }

    label.appendChild(showDone);
    label.appendChild(span);
    head.appendChild(label);
  }

  // 4) Decide if a row is "finished" using multiple heuristics (robust)
  function isRowDecided(row){
    if (!row) return false;
    // A) has .decided class
    if (row.classList.contains('decided')) return true;
    // B) data attribute
    if (row.getAttribute('data-decided') === '1' || row.getAttribute('aria-checked') === 'true') return true;
    // C) badge/pill text that indicates decided/locked
    const pill = row.querySelector('.bpill,.badge,.bline');
    const txt = (pill?.textContent || row.textContent || '').toLowerCase();
    if (/\bdecided\b/.test(txt) || /\bfinished\b/.test(txt)) return true;
    // D) overlay text node “DECIDED”
    if ([...row.querySelectorAll('*')].some(n=>/DECIDED/i.test(n.textContent||''))) return true;
    return false;
  }

  // 5) Apply visibility based on toggle (also adds class on container)
  function applyShowDone(){
    const hide = !showDone.checked;
    bracketEl.classList.toggle('hide-done', hide);

    // Inline fallback that wins over any CSS order
    const rows = brows.querySelectorAll('.brow, [class*="row"], [data-slot]');
    rows.forEach(row=>{
      const decided = isRowDecided(row);
      if (decided){
        // normalize class so CSS can hit too
        row.classList.add('decided');
        row.style.display = hide ? 'none' : '';
      }
    });

    try{ localStorage.setItem('rs_show_done', hide ? '0' : '1'); }catch(e){}
  }

  // 6) Re-apply when list changes (your code often re-renders the bracket)
  if ('MutationObserver' in window){
    const mo = new MutationObserver(applyShowDone);
    mo.observe(brows, {childList:true, subtree:true});
  }

  // 7) Hook up toggle + initial pass
  showDone.addEventListener('change', applyShowDone);
  applyShowDone();
  setTimeout(applyShowDone, 300); // one more pass for async renders
})();
</script>
<script>
/* ===== Rage Space — Art Queue Integrator (R32 injections) =====
   Requirements (see submit.html for SQL):
   - public.art_queue (image_url, status='pending' → 'used', used_at)
   - public.art_injections (base_iso, slot, image_url, submission_id)
   - public.art_cycle_claims (base_iso) — prevents multiple assignment per cycle

   What it does:
   - When a NEW cycle starts (we move from FINAL → fresh R32), one client claims the base_iso.
   - The claimer pulls up to 16 pending submissions and assigns them to random distinct r32 slots.
   - Everyone then reads art_injections to override default seeds for thumbnails & live images.
*/

const _inj = {
  cache: new Map(), // key: `${baseISO}::${slot}` -> { image_url, submission_id }
  ready: new Set()  // baseISO values we already loaded
};

async function loadInjectionsFor(baseISO){
  if (!baseISO || _inj.ready.has(baseISO)) return;
  const { data, error } = await supabase
    .from('art_injections')
    .select('slot,image_url,submission_id')
    .eq('base_iso', baseISO);
  if (!error && Array.isArray(data)){
    data.forEach(r=>{
      _inj.cache.set(`${baseISO}::${r.slot}`, { image_url: r.image_url, submission_id: r.submission_id });
    });
  }
  _inj.ready.add(baseISO);
}

async function tryClaimCycle(baseISO){
  // Attempt to insert a claim row; if conflict, another client already did it.
  try{
    const { error } = await supabase.from('art_cycle_claims').insert({ base_iso: baseISO });
    if (error){
      // Postgrest returns 409-ish; just treat as "not leader"
      return false;
    }
    return true;
  }catch{ return false; }
}

function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

async function assignQueuedToR32(baseISO){
  // Pull pending rows (oldest first) and map to random r32 slots (max 16)
  const { data:queue } = await supabase
    .from('art_queue')
    .select('id,image_url')
    .eq('status','pending')
    .order('created_at', { ascending:true })
    .limit(16);

  if (!queue || queue.length===0) return;

  const slots = Array.from({length:16},(_,i)=>`r32_${i+1}`);
  shuffle(slots);

  const rows = [];
  for (let i=0;i<Math.min(slots.length, queue.length); i++){
    rows.push({
      base_iso: baseISO,
      slot: slots[i],
      submission_id: queue[i].id,
      image_url: queue[i].image_url
    });
  }

  if (rows.length===0) return;

  const { error:insErr } = await supabase.from('art_injections').upsert(rows);
  if (!insErr){
    // Mark used
    const ids = rows.map(r=>r.submission_id);
    await supabase.from('art_queue').update({ status:'used', used_at: new Date().toISOString() }).in('id', ids);
  }

  // Warm local cache
  rows.forEach(r=>{
    _inj.cache.set(`${baseISO}::${r.slot}`, { image_url:r.image_url, submission_id:r.submission_id });
  });
}

async function ensureR32InjectionsFor(baseISO){
  if (!baseISO) return;
  // First, see if something already assigned
  await loadInjectionsFor(baseISO);
  // If none exist, try to become the "leader" and assign
  const hasAny = [..._inj.cache.keys()].some(k=>k.startsWith(`${baseISO}::r32_`));
  if (!hasAny){
    const isLeader = await tryClaimCycle(baseISO);
    if (isLeader){
      await assignQueuedToR32(baseISO);
    }
    // Either way, load again so followers get what the leader just wrote
    await loadInjectionsFor(baseISO);
  }
}

/* ---- Injection-aware helpers: override R32 seeds when present ---- */

function injectedSrcFor(baseISO, slot, fallback){
  const k = `${baseISO}::${slot}`;
  const rec = _inj.cache.get(k);
  return rec?.image_url || fallback;
}

// Patch seed usage in your painters:
// 1) Call `ensureR32InjectionsFor(currentPhaseKey)` whenever a NEW base begins.
// 2) In places where you set R32 A/B images, wrap with injectedSrcFor(...).

// Hook into your existing phase flip logic:
// In your code you already handle transitions in fetchState().
// Add the following calls in the appropriate branches:

const _orig_fetchState_for_injections = fetchState;
fetchState = async function(){
  const prevEnd = serverPhaseEndISO;
  const prevStageBefore = currentStage;

  await _orig_fetchState_for_injections();

  // Detect fresh R32 start:
  // Condition: we just moved from FINAL -> new cycle (your code sets activeSlot='r32_1' there)
  // or if stage resolved to 'r32' and the base changed compared to previous.
  if (prevEnd && serverPhaseEndISO && prevEnd !== serverPhaseEndISO){
    // new base started; if it's R32 now, prep injections
    if (currentStage === 'r32'){
      await ensureR32InjectionsFor(currentPhaseKey);
      // Repaint in case some slots were injected
      await paintImagesForActive();
      await renderBracket();
    }
  }
};

// 3) Intercept where R32 images are chosen to apply injection:

const _orig_paintImagesForActive = paintImagesForActive;
paintImagesForActive = async function(){
  const slot = activeSlot;
  const base = baseForSlot(slot);

  // If current stage is R32, ensure injections are loaded before painting
  if (stageOfSlot(slot) === 'r32' && base){
    await ensureR32InjectionsFor(base);
  }

  // run original
  await _orig_paintImagesForActive();

  // If we just painted an R32 slot, swap to injected sources if present
  if (base && slot.startsWith('r32')){
    const idx = Number(slot.split('_')[1]);
    const fallbackA = imgA.src;
    const fallbackB = imgB.src;
    const injA = injectedSrcFor(base, `r32_${idx}`, null);
    // For simplicity, when we inject a slot, we replace LEFT (A). You can alternate later.
    if (injA){
      imgA.src = injA;
      // Cache what we painted so bracket thumbnails stay consistent
      imgCache.set(`${base}::${slot}`, { A: imgA.src, B: fallbackB });
    }
  }
};

// 4) Also ensure bracket thumbnails reflect injections:

const _orig_thumbsFor = thumbsFor;
thumbsFor = async function(slot){
  const pack = await _orig_thumbsFor(slot);
  const base = baseForSlot(slot);
  if (base && slot.startsWith('r32')){
    await ensureR32InjectionsFor(base);
    const inj = _inj.cache.get(`${base}::${slot}`);
    if (inj){
      // Replace left thumb (A) with injected image; right stays default
      return { A: inj.image_url, B: pack.B };
    }
  }
  return pack;
};
</script>
<style>
  /* --- Testing toolbar + drawer --- */
  .rs-toolbar{
    position:sticky; top:0; z-index:9999;
    display:flex; gap:10px; align-items:center; justify-content:flex-start;
    padding:8px 12px; background:rgba(0,0,0,.9); border-bottom:1px solid #153b16;
    color:#39ff14; font:14px/1.2 system-ui, Arial, sans-serif;
  }
  .rs-toolbar button{
    border:1px solid #39ff14; background:transparent; color:#39ff14;
    border-radius:10px; padding:8px 10px; cursor:pointer;
  }
  .rs-queue-drawer{
    display:none; background:rgba(0,0,0,.85); border-top:1px dashed #153b16;
    padding:10px 12px;
  }
  .rs-queue-grid{
    display:grid; grid-template-columns:repeat(auto-fill,minmax(90px,1fr)); gap:10px;
  }
  .rs-queue-item{
    border:1px solid #153b16; border-radius:10px; padding:6px; background:#0a0a0a;
    display:flex; flex-direction:column; gap:6px; align-items:center;
    color:#8aff8a; font-size:12px;
  }
  .rs-queue-item img{ width:100%; height:90px; object-fit:cover; border-radius:6px; }
  .rs-queue-empty{ color:#9adf9a; font-size:13px; padding:6px 0; }
</style>

<div class="rs-toolbar">
  <button id="rsBtnQueue">In the queue</button>
  <button id="rsBtnForce">Force decide → next</button>
  <span id="rsToolbarInfo" style="margin-left:10px; opacity:.8;"></span>
</div>
<div id="rsQueueDrawer" class="rs-queue-drawer">
  <div id="rsQueueGrid" class="rs-queue-grid"></div>
  <div id="rsQueueEmpty" class="rs-queue-empty" style="display:none;">No pending submissions.</div>
</div>

<script>
/* ========= Helper to show base/stage for context ========= */
(function(){
  const info = document.getElementById('rsToolbarInfo');
  function paint(){
    try{
      const base = (window.currentPhaseKey || '(base?)');
      const stage = (window.currentStage || '(stage?)');
      const slot = (window.activeSlot || '(slot?)');
      info.textContent = `BASE: ${base} • STAGE: ${stage} • SLOT: ${slot}`;
    }catch(e){}
  }
  paint(); setInterval(paint, 1200);
})();

/* ========= “In the queue” drawer & thumbnails ========= */
(async function setupQueueDrawer(){
  const btn = document.getElementById('rsBtnQueue');
  const drawer = document.getElementById('rsQueueDrawer');
  const grid = document.getElementById('rsQueueGrid');
  const empty = document.getElementById('rsQueueEmpty');

  async function loadQueue(){
    if (typeof supabase === 'undefined'){ grid.innerHTML = ''; empty.style.display=''; empty.textContent='Supabase not ready'; return; }
    const { data, error } = await supabase
      .from('art_queue')
      .select('image_url,title,artist,created_at')
      .eq('status','pending')
      .order('created_at', { ascending:true })
      .limit(48);
    grid.innerHTML = '';
    if (error){ empty.style.display=''; empty.textContent = error.message || 'Failed to load'; return; }
    if (!data || data.length === 0){ empty.style.display=''; empty.textContent='No pending submissions.'; return; }
    empty.style.display='none';
    for (const r of data){
      const card = document.createElement('div');
      card.className = 'rs-queue-item';
      card.innerHTML = `
        <img loading="lazy" src="${r.image_url}" alt="queued" />
        <div style="text-align:center;word-break:break-word;">${(r.title||'') ? r.title : '&nbsp;'}</div>
      `;
      grid.appendChild(card);
    }
  }

  btn.addEventListener('click', async ()=>{
    const show = drawer.style.display !== 'block';
    drawer.style.display = show ? 'block' : 'none';
    if (show) await loadQueue();
  });
})();

/* ========= “Force decide → next” =========
   Tries to use your real winner logic first.
   Strategies, in order:
   1) Call decideWinner('A'/'B') if it exists (uses same logic your app uses)
   2) Call onPick('A'/'B') if that exists
   3) Click likely vote buttons if they exist in DOM
   4) Fallback: choose side leading in memory (img/vote vars), else 'A'
=========================================================== */
(function(){
  const btn = document.getElementById('rsBtnForce');

  function pickSideHeuristic(){
    try{
      // If you track scores/votes, prefer the leader
      if (typeof window.scoreA !== 'undefined' && typeof window.scoreB !== 'undefined'){
        if (window.scoreA > window.scoreB) return 'A';
        if (window.scoreB > window.scoreA) return 'B';
      }
    }catch(e){}
    return 'A';
  }

  async function forceDecide(){
    btn.disabled = true;
    try{
      const side = pickSideHeuristic();

      // 1) direct winner API
      if (typeof window.decideWinner === 'function'){
        await window.decideWinner(side);
      }
      // 2) common handler name
      else if (typeof window.onPick === 'function'){
        await window.onPick(side);
      }
      // 3) try clicking UI buttons your app already wires
      else {
        const aBtn = document.querySelector('[data-pick="A"], #pickA, .btn-a, .vote-a');
        const bBtn = document.querySelector('[data-pick="B"], #pickB, .btn-b, .vote-b');
        if (side === 'A' && aBtn){ aBtn.click(); }
        else if (side === 'B' && bBtn){ bBtn.click(); }
        else {
          // 4) last resort: try a generic advance function if present
          if (typeof window.advanceAfterChoice === 'function'){
            await window.advanceAfterChoice(side);
          } else {
            console.warn('Force decide: no known hooks found; did nothing.');
          }
        }
      }

      // After deciding, ensure we repaint the new state
      if (typeof fetchState === 'function') await fetchState();
      if (typeof paintImagesForActive === 'function') await paintImagesForActive();
      if (typeof renderBracket === 'function') await renderBracket();
    } catch (e){
      console.error(e);
      alert(e?.message || 'Force decide failed');
    } finally {
      btn.disabled = false;
    }
  }

  btn.addEventListener('click', forceDecide);
})();
</script>
</body>
</html>