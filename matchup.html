<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rage Space ‚Äî Matchup</title>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<style>
:root{ --green:#39ff14; --green-bright:#7dff62; --bg:#000; --ink:#e5e5e5; --card:#0b0b0b; --border:#153b16; --muted:#8aff8a; --maxw:980px; --danger:#ff3b3b; }
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--green);font-family:system-ui,Arial,Helvetica,sans-serif}
.wrap{max-width:var(--maxw);margin:16px auto 64px;padding:0 16px}
.scorebar{display:flex;gap:12px;align-items:center;justify-content:space-between;border:1px solid var(--border);padding:12px;border-radius:12px;background:rgba(7,7,7,.6);flex-wrap:wrap}
.btn{border:1px solid var(--green);color:var(--green);background:transparent;border-radius:10px;padding:8px 12px;cursor:pointer;text-decoration:none;display:inline-block;text-align:center}
.btn:hover{box-shadow:0 0 12px rgba(57,255,20,.18)}
.tiny{display:flex;gap:8px;align-items:center;font-variant-numeric:tabular-nums;font-size:12px;color:var(--muted)}
.clock{font-weight:700;border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge{border:1px solid var(--border);border-radius:8px;padding:2px 8px}
.badge.warn{border-color:#3b1616;color:#ff6b6b}
.badge.ok{border-color:#153b16;color:#8aff8a}
.tile{border:1px solid var(--border);border-radius:14px;overflow:hidden;background:rgba(7,7,7,.6);margin-top:16px;position:relative}
.art{aspect-ratio:4/3;width:100%;height:auto;display:block;object-fit:cover}
.caption{display:block;text-align:center;font-size:12px;color:var(--muted);padding:6px 8px;border-top:1px dashed var(--border)}
.meta{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 12px;border-top:1px solid var(--border)}
.btn.primary.selected{background:rgba(57,255,20,.22);color:var(--ink);box-shadow:0 0 18px rgba(125,255,98,.35), inset 0 0 12px rgba(57,255,20,.15)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:14px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071c07;color:var(--green);border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:none;box-shadow:0 0 18px rgba(57,255,20,.18);z-index:50}
.toast.show{display:block}

/* overlay */
#overlay{position:fixed; inset:0; display:none; z-index:9999; background:rgba(0,0,0,.92)}
#overlay.show{display:block}
.overlay-bg{position:absolute; inset:0; overflow:hidden}
.overlay-art{position:absolute; inset:0; background-size:cover; background-position:center; background-repeat:no-repeat}
.scanlines{position:absolute; inset:0; background:repeating-linear-gradient(to bottom, rgba(0,0,0,.25) 0px, rgba(0,0,0,.25) 2px, transparent 3px, transparent 4px)}
.vignette{position:absolute; inset:-10%; background:radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,.6) 100%)}
.overlay-card{position:relative; max-width:min(820px,92vw); margin:8vh auto 4vh; border:1px solid var(--green); background:rgba(7,7,7,.72); border-radius:18px; padding:22px 18px; box-shadow:0 0 40px rgba(57,255,20,.25)}
.overlay-card h1{margin:0 0 6px; text-align:center; letter-spacing:2px; font-size:clamp(28px,6vw,54px); text-transform:uppercase}
.overlay-card .sub{text-align:center; color:var(--muted); margin-bottom:12px; font-size:clamp(12px,2.4vw,14px)}
.overlay-card .motto{text-align:center; margin-top:8px; color:var(--green-bright); font-weight:700; letter-spacing:.5px}
#overlayClose{position:absolute; right:14px; top:12px; z-index:2; border:1px solid var(--green); background:rgba(0,0,0,.6); color:var(--green); border-radius:10px; padding:6px 10px; cursor:pointer}
#confetti{position:absolute; inset:0; pointer-events:none}

/* bracket */
.bracket{margin-top:20px; border:1px solid var(--border); border-radius:14px; background:rgba(7,7,7,.5); overflow:hidden}
.bracket-head{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--border)}
.bracket-title{font-weight:700; font-size:18px}
.switch{display:flex; align-items:center; gap:8px; color:var(--muted); font-size:13px}
.brow{display:grid; grid-template-columns:auto auto 1fr auto; gap:10px 12px; padding:12px 14px; border-top:1px solid var(--border); cursor:pointer; align-items:center}
.brow:first-child{border-top:0}
.brow.active{outline:2px solid var(--danger); outline-offset:-2px; background:rgba(255,59,59,.07)}
.thumb2{display:flex; gap:8px}
.thumb{width:44px;height:44px;border-radius:10px;overflow:hidden;border:1px solid var(--border); background:#0b0b0b}
.thumb img{width:100%;height:100%;object-fit:cover;display:block}
.bmeta{display:flex; flex-direction:column; gap:4px; min-width:0}
.bline{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
.bbadge{border:1px solid var(--border); border-radius:999px; padding:2px 8px; font-size:12px}
.bpill{color:var(--muted); font-size:13px}
.bscore{font-variant-numeric:tabular-nums; font-size:18px; justify-self:end}
.title{font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
.tabs{display:none}
</style>
</head>
<body>
  <div class="wrap">
    <div class="scorebar">
      <div class="tiny">
        <strong>Decision in</strong>
        <span id="clock" class="clock">Sync‚Ä¶</span>
        <span id="state" class="clock">‚Äî</span>
        <span id="phaseKey" class="clock">phase: ‚Äî</span>
        <span id="loginBadge" class="badge">checking auth‚Ä¶</span>
      </div>
      <div class="row">
        <button id="btnPause" class="btn">‚è∏Ô∏è Pause</button>
        <button id="btnForce" class="btn">üèÅ Force Decide</button>
        <a class="btn" href="./winners.html">üèÅ Winners</a>
      </div>
    </div>

    <!-- Current match -->
    <div class="tile" id="tileA">
      <img id="imgA" class="art" alt="Entry Left"/>
      <div class="caption" id="countA">0 votes</div>
      <div class="meta">
        <span id="labelA">Left</span>
        <button class="btn primary" id="voteA">Vote This</button>
      </div>
    </div>

    <div class="tile" id="tileB">
      <img id="imgB" class="art" alt="Entry Right"/>
      <div class="caption" id="countB">0 votes</div>
      <div class="meta">
        <span id="labelB">Right</span>
        <button class="btn primary" id="voteB">Vote This</button>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="submitBtn" disabled>‚úÖ Submit Vote</button>
    </div>

    <!-- Bracket list -->
    <section class="bracket" id="bracket">
      <div class="bracket-head">
        <div class="bracket-title">Bracket</div>
        <label class="switch">
          <input id="showDone" type="checkbox" />
          <span>Show finished rounds</span>
        </label>
      </div>
      <div id="brows"></div>
    </section>
  </div>

  <div id="toast" class="toast"></div>

  <!-- FINAL OVERLAY -->
  <div id="overlay">
    <canvas id="confetti"></canvas>
    <div class="overlay-bg">
      <div id="overlayArt" class="overlay-art"></div>
      <div class="scanlines"></div>
      <div class="vignette"></div>
    </div>
    <button id="overlayClose" class="btn">‚úï</button>
    <div class="overlay-card" id="overlayCard">
      <h1 id="overlayTitle">CHAMPION</h1>
      <div class="sub" id="overlaySubtitle">Rage Space</div>
      <div class="motto">Glory to the machine. Your art devours the bracket</div>
    </div>
  </div>

<script>
/* ---------- Setup ---------- */
const SUPABASE_URL = "https://tuqvpcevrhciursxrgav.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y";
const EDGE_URL = `${SUPABASE_URL}/functions/v1/global-timer`;
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const clockEl = document.getElementById('clock');
const stateEl = document.getElementById('state');
const phaseBadge = document.getElementById('phaseKey');
const loginBadge = document.getElementById('loginBadge');
const pauseBtn = document.getElementById('btnPause');
const forceBtn = document.getElementById('btnForce');
const toastEl = document.getElementById('toast');
function toast(msg, ms=1400){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),ms); }
const iso = (d)=> new Date(d).toISOString().replace(/\.\d{3}Z$/,'Z');

const imgA  = document.getElementById('imgA');
const imgB  = document.getElementById('imgB');
const labelA = document.getElementById('labelA');
const labelB = document.getElementById('labelB');
const countA = document.getElementById('countA');
const countB = document.getElementById('countB');
const voteA = document.getElementById('voteA');
const voteB = document.getElementById('voteB');
const submitBtn = document.getElementById('submitBtn');

const overlay = document.getElementById('overlay');
const overlayArt = document.getElementById('overlayArt');
const overlayTitle = document.getElementById('overlayTitle');
const overlaySubtitle = document.getElementById('overlaySubtitle');
const overlayClose = document.getElementById('overlayClose');
const confettiCanvas = document.getElementById('confetti');

/* bracket DOM */
const brows = document.getElementById('brows');

/* ---------- State ---------- */
let paused=false, serverPhaseEndISO=null, currentPhaseKey=null, prevPhaseKey=null, periodSec=20, remainingSec=null, lastSyncAt=0, lastCountsAt=0;
let currentUid=null, chosen=null;

/* strict rotation of slots per phase */
const SLOTS = ['sf1','sf2','final'];
let activeSlot='sf1';                 // which slot we are currently viewing/playing
let overlayGateBase=null;             // base ISO allowed to pop champion

// Frozen images per battle "<baseISO>::sf1|sf2|final" ‚Üí {A,B}
const imgCache = new Map();
let lastPaintedBattleKey=null;

/* ---------- Helpers ---------- */
async function getUidOrNull(){ const {data:{session}}=await supabase.auth.getSession(); return session?.user?.id ?? null; }
function paintLoginBadge(){ if(currentUid){loginBadge.textContent='logged in'; loginBadge.classList.add('ok'); loginBadge.classList.remove('warn');} else {loginBadge.textContent='not logged in'; loginBadge.classList.add('warn'); loginBadge.classList.remove('ok');} }

async function callEdge(method='GET', body=null){
  const res = await fetch(EDGE_URL,{method,headers:{'Content-Type':'application/json','Authorization':`Bearer ${SUPABASE_ANON_KEY}`,'apikey':SUPABASE_ANON_KEY},body:body?JSON.stringify(body):null});
  const raw = await res.text(); let j=null; try{ j=JSON.parse(raw);}catch{}
  if(!res.ok) throw new Error((j&&j.error)||raw||'edge error');
  return j?.state || j || {};
}
const normalize=(s)=>({phase_end_at:s.phase_end_at??null, period_sec:s.period_sec??20, paused:!!s.paused, remaining_sec:(typeof s.remaining_sec==='number')?s.remaining_sec:null});

function seedUrlFromKey(baseISO, suffix){ const s=encodeURIComponent(`${baseISO}-${suffix}`); return `https://picsum.photos/seed/${s}/1600/1200`; }
function semiKeysFor(baseISO){ return { sf1:`${baseISO}::sf1`, sf2:`${baseISO}::sf2` }; }
function finalKeyFor(baseISO){ return `${baseISO}::final`; }

/* ---------- Stage helpers ---------- */
async function finalsEntrants(){
  if (!prevPhaseKey) return null;
  const { sf1, sf2 } = semiKeysFor(prevPhaseKey);
  const { data } = await supabase.from('winners').select('phase_key,color').in('phase_key',[sf1,sf2]);
  if (!data || data.length<2) return null;
  const map = Object.fromEntries(data.map(r=>[r.phase_key, r.color]));
  if (!map[sf1] || !map[sf2]) return null;
  const left  = seedUrlFromKey(prevPhaseKey, map[sf1]==='red' ? 'A1' : 'B1');
  const right = seedUrlFromKey(prevPhaseKey, map[sf2]==='red' ? 'A2' : 'B2');
  return {A:left,B:right};
}
async function finalTitle(){
  if (!prevPhaseKey) return 'TBD vs TBD';
  const { sf1, sf2 } = semiKeysFor(prevPhaseKey);
  const { data } = await supabase.from('winners').select('phase_key,color').in('phase_key',[sf1,sf2]);
  const map = Object.fromEntries((data||[]).map(r=>[r.phase_key, r.color]));
  const pick = (slot,c)=> slot==='sf1' ? (c==='red'?'Seed A':'Seed B') : (c==='red'?'Seed C':'Seed D');
  const s1 = map[sf1] ? pick('sf1',map[sf1]) : null;
  const s2 = map[sf2] ? pick('sf2',map[sf2]) : null;
  return (s1 && s2) ? `${s1} vs ${s2}` : 'TBD vs TBD';
}

/* ---------- Painting current images ---------- */
function currentBattleKey(){
  if (!currentPhaseKey) return null;
  if (activeSlot==='final') return finalKeyFor(currentPhaseKey);
  return `${(activeSlot==='sf1'?currentPhaseKey:currentPhaseKey)}::${activeSlot}`;
}
async function paintImages(){
  if (!currentPhaseKey) return;
  const key = currentBattleKey();
  if (!key) return;
  if (key === lastPaintedBattleKey && imgCache.has(key)) return;

  if (imgCache.has(key)){
    const {A,B}=imgCache.get(key); imgA.src=A; imgB.src=B;
  } else {
    if (activeSlot==='sf1'){
      const A = seedUrlFromKey(currentPhaseKey,'A1'), B = seedUrlFromKey(currentPhaseKey,'B1');
      imgCache.set(key,{A,B}); imgA.src=A; imgB.src=B;
    } else if (activeSlot==='sf2'){
      const A = seedUrlFromKey(currentPhaseKey,'A2'), B = seedUrlFromKey(currentPhaseKey,'B2');
      imgCache.set(key,{A,B}); imgA.src=A; imgB.src=B;
    } else {
      const pack = await finalsEntrants();
      if (pack){ imgCache.set(key, pack); imgA.src=pack.A; imgB.src=pack.B; }
      else { imgA.src=''; imgB.src=''; }
    }
  }
  labelA.textContent = (activeSlot==='final'?'Final':activeSlot==='sf1'?'Semi 1':'Semi 2') + ' ‚Äî Left';
  labelB.textContent = (activeSlot==='final'?'Final':activeSlot==='sf1'?'Semi 1':'Semi 2') + ' ‚Äî Right';
  imgA.loading='eager'; imgB.loading='eager'; imgA.decoding='async'; imgB.decoding='async';
  lastPaintedBattleKey=key;
}

/* ---------- Votes ---------- */
const fmtVotes=(n)=>`${n} ${n===1?'vote':'votes'}`;
async function countVotesFor(key){
  const { data, error } = await supabase.from('phase_votes').select('vote').eq('phase_key', key);
  if (error) throw error;
  let r=0,b=0; (data||[]).forEach(row=>{ if(row.vote==='red') r++; else if(row.vote==='blue') b++; });
  return {r,b};
}
async function refreshCounts(){
  try{
    const key=currentBattleKey(); if(!key){ countA.textContent='0 votes'; countB.textContent='0 votes'; return; }
    const {r,b}=await countVotesFor(key);
    countA.textContent=fmtVotes(r); countB.textContent=fmtVotes(b);
    lastCountsAt=Date.now(); updateBracketScores();
  }catch{}
}

/* ---------- Persist winner for just-ended slot ---------- */
async function persistWinnerFor(phaseKeyISO){
  const { r, b } = await countVotesFor(phaseKeyISO);
  const color = (r===b) ? (Math.random()<0.5?'red':'blue') : (r>b?'red':'blue');
  const { error } = await supabase.from('winners').insert({phase_key: phaseKeyISO, color}).select().single();
  if (error){
    const { data } = await supabase.from('winners').select('color').eq('phase_key', phaseKeyISO).limit(1);
    return (data?.[0]?.color||color);
  }
  return color;
}

/* ---------- Champion overlay ---------- */
function startConfetti(){ const ctx=confettiCanvas.getContext('2d'); let raf; const parts=Array.from({length:220},()=>({x:Math.random()*innerWidth,y:-20-Math.random()*innerHeight*0.3,vx:(Math.random()-0.5)*2,vy:1.2+Math.random()*2.6,w:3+Math.floor(Math.random()*7),h:3+Math.floor(Math.random()*7),rot:Math.random()*Math.PI,vr:(Math.random()-0.5)*0.2,color:['#39ff14','#7dff62','#00ffd5','#baffc9','#eaff00'][Math.floor(Math.random()*5)]})); function step(){ confettiCanvas.width=innerWidth; confettiCanvas.height=innerHeight; ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height); parts.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.rot+=p.vr; if(p.y>innerHeight+20){p.y=-10;p.x=Math.random()*innerWidth;} ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.rot);ctx.fillStyle=p.color;ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);ctx.restore();}); raf=requestAnimationFrame(step);} step(); confettiCanvas._stop=()=>{cancelAnimationFrame(raf); const c=confettiCanvas.getContext('2d'); c.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);} }
function stopConfetti(){ confettiCanvas._stop && confettiCanvas._stop(); }
function showChampion(color, finalBaseISO){
  const cached = imgCache.get(finalKeyFor(finalBaseISO)) || {};
  const src = (color==='red') ? (cached.A || imgA.src) : (cached.B || imgB.src);
  overlayArt.style.backgroundImage = `url("${src}")`;
  overlayTitle.textContent = 'CHAMPION';
  overlaySubtitle.textContent = color==='red' ? 'Final: Left prevails' : 'Final: Right prevails';
  overlay.classList.add('show');
  startConfetti();
  setTimeout(()=>{ overlay.classList.remove('show'); stopConfetti(); }, 6000);
}
overlayClose.onclick=()=>{ overlay.classList.remove('show'); stopConfetti(); };

/* ---------- Timer / phase handling ---------- */
let paused=false, serverState=null;
function setStateUI(){ stateEl.textContent = paused ? 'PAUSED' : 'LIVE'; pauseBtn.textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'; phaseBadge.textContent='phase: '+(currentPhaseKey||'‚Äî'); }

async function fetchState(){
  const s = normalize(await callEdge('GET'));
  const prevEnd = serverPhaseEndISO;

  serverPhaseEndISO = s.phase_end_at;
  paused = s.paused;
  periodSec = s.period_sec ?? 20;
  remainingSec = s.remaining_sec;
  lastSyncAt = Date.now();

  currentPhaseKey = serverPhaseEndISO ? iso(serverPhaseEndISO) : null;
  prevPhaseKey = currentPhaseKey && periodSec ? iso(Date.parse(currentPhaseKey) - periodSec*1000) : null;

  setStateUI();

  // PHASE FLIP ‚Üí close out the slot that just ended, then advance the rotation
  if (prevEnd && serverPhaseEndISO && prevEnd !== serverPhaseEndISO){
    const justEndedBase = iso(prevEnd);
    const endedSlot = activeSlot; // the slot we were showing during that phase

    if (endedSlot === 'sf1'){
      await persistWinnerFor(`${justEndedBase}::sf1`);
      activeSlot = 'sf2';
    } else if (endedSlot === 'sf2'){
      await persistWinnerFor(`${justEndedBase}::sf2`);
      activeSlot = 'final';
      overlayGateBase = currentPhaseKey; // allow champion popup for this final
      // pre-seed final images (from winners of prevBase)
      const pack = await finalsEntrants();
      if (pack) imgCache.set(finalKeyFor(currentPhaseKey), pack);
    } else if (endedSlot === 'final'){
      // decide champion for the final that just ended
      const color = await persistWinnerFor(`${justEndedBase}::final`);
      if (overlayGateBase === justEndedBase) showChampion(color, justEndedBase);

      // reset cycle
      activeSlot = 'sf1';
      overlayGateBase = null;
      imgCache.clear();               // fresh images next cycle
      lastPaintedBattleKey=null;
    }
  }

  await paintImages();
  await refreshCounts();
  renderBracket();
}

/* ---------- Bracket (compact & stage-aware) ---------- */
function rowId(slot){ return `row-${slot}`; }
function labelFor(slot){
  if (slot==='sf1') return {round:'QF', title:'Seed A vs Seed B'};
  if (slot==='sf2') return {round:'QF', title:'Seed C vs Seed D'};
  return {round:'Final', title:'TBD vs TBD'};
}
async function thumbsForRow(slot){
  // QFs are always rendered from their own base (sf1 -> prevBase? No: each semi has its own base)
  if (slot==='sf1'){
    const key = `${prevPhaseKey||currentPhaseKey}::sf1`; // show the most recent finished/seeding
    if (imgCache.has(key)) return imgCache.get(key);
    const A = seedUrlFromKey(prevPhaseKey||currentPhaseKey,'A1');
    const B = seedUrlFromKey(prevPhaseKey||currentPhaseKey,'B1');
    const pack={A,B}; imgCache.set(key,pack); return pack;
  }
  if (slot==='sf2'){
    const base = currentPhaseKey; // the second semi runs during the current base after sf1
    const key = `${base}::sf2`;
    if (imgCache.has(key)) return imgCache.get(key);
    const A = seedUrlFromKey(base,'A2'); const B = seedUrlFromKey(base,'B2');
    const pack={A,B}; imgCache.set(key,pack); return pack;
  }
  // final row shows only when two winners exist
  const pack = await finalsEntrants();
  if (!pack) return {A:'',B:''};
  return pack;
}
async function updateBracketScores(){
  const map = {
    sf1: `${prevPhaseKey||currentPhaseKey}::sf1`,
    sf2: `${currentPhaseKey}::sf2`,
    final: `${currentPhaseKey}::final`
  };
  for (const slot of SLOTS){
    const sEl = document.querySelector(`#${rowId(slot)} .bscore`);
    if (!sEl) continue;
    const key = map[slot];
    try{ const {r,b}=await countVotesFor(key); sEl.textContent=`${r} - ${b}`; }
    catch{ sEl.textContent='0 - 0'; }
  }
}
function highlightActiveRow(){
  document.querySelectorAll('.brow').forEach(el=>el.classList.remove('active'));
  const r = document.getElementById(rowId(activeSlot));
  r && r.classList.add('active');
}
function switchTo(slot){
  activeSlot = slot; clearSelection(); lastPaintedBattleKey=null;
  paintImages(); refreshCounts(); highlightActiveRow();
}
async function renderBracket(){
  const finalTitleText = await finalTitle();
  const rows = await Promise.all(SLOTS.map(async slot=>{
    const round = labelFor(slot).round;
    const thumbs = await thumbsForRow(slot);
    const title = (slot==='final') ? finalTitleText : labelFor(slot).title;
    const imgA = thumbs.A ? `<img src="${thumbs.A}" alt="">` : '';
    const imgB = thumbs.B ? `<img src="${thumbs.B}" alt="">` : '';
    return `
      <div class="brow" id="${rowId(slot)}" data-slot="${slot}">
        <div class="bbadge">${round}</div>
        <div class="thumb2"><div class="thumb">${imgA}</div><div class="thumb">${imgB}</div></div>
        <div class="bmeta"><div class="title">${title}</div><div class="bline"><span class="bpill">uses global</span></div></div>
        <div class="bscore">0 - 0</div>
      </div>
    `;
  }));
  brows.innerHTML = rows.join('');
  highlightActiveRow();
  updateBracketScores();
  brows.querySelectorAll('.brow').forEach(r=>r.addEventListener('click',()=>switchTo(r.dataset.slot)));
}

/* ---------- Controls / Voting ---------- */
pauseBtn.onclick = async ()=>{ try{ await callEdge('POST',{action: paused?'resume':'pause'}); await fetchState(); toast('OK'); }catch{ toast('Pause/resume failed'); }};
forceBtn.onclick = async ()=>{ try{ await callEdge('POST',{force:true}); await fetchState(); toast('Forced decision'); }catch{ toast('Force failed'); }};

function clearSelection(){ voteA.classList.remove('selected'); voteB.classList.remove('selected'); chosen=null; submitBtn.textContent='‚úÖ Submit Vote'; submitBtn.disabled=!currentUid; }
voteA.onclick=()=>{ chosen='red'; voteA.classList.add('selected'); voteB.classList.remove('selected'); submitBtn.disabled=!currentUid; };
voteB.onclick=()=>{ chosen='blue'; voteB.classList.add('selected'); voteA.classList.remove('selected'); submitBtn.disabled=!currentUid; };
submitBtn.onclick=async()=>{
  const key=currentBattleKey();
  if (!chosen || !key) return;
  if (!currentUid){ toast('Log in to vote'); return; }
  try{
    const { error } = await supabase.from('phase_votes').upsert(
      { phase_key:key, vote:chosen, user_id: currentUid },
      { onConflict:'phase_key,user_id' }
    );
    if (error) throw error;
    toast('‚úî Vote submitted'); submitBtn.textContent='‚úî Voted'; submitBtn.disabled=true; refreshCounts();
  }catch{ toast('Vote failed'); }
};

/* ---------- Loop ---------- */
let rafId=null;
async function tick(){
  if (paused){
    const sec = (typeof remainingSec==='number' && !Number.isNaN(remainingSec)) ? Number(remainingSec) : 0;
    clockEl.textContent = String(Math.max(0, Math.ceil(sec)));
    if (Date.now()-lastSyncAt > 5000) { try{ await fetchState(); }catch{} }
  } else {
    const rem = serverPhaseEndISO ? Math.max(0, Date.parse(serverPhaseEndISO) - Date.now()) : 0;
    clockEl.textContent = String(Math.ceil(rem/1000));
    if (rem<=0 || Date.now()-lastSyncAt>5000) { try{ await fetchState(); }catch{} }
    if (Date.now()-lastCountsAt>2000) refreshCounts();
  }
  rafId = requestAnimationFrame(tick);
}

/* ---------- Realtime ---------- */
supabase.channel('winners-final-overlay')
  .on('postgres_changes',{event:'INSERT',schema:'public',table:'winners'},(payload)=>{
    const key = payload?.new?.phase_key || '';
    const color = (payload?.new?.color||'').toLowerCase();
    if (!key.endsWith('::final')) return;
    const base = key.split('::')[0];
    if (!overlayGateBase || base !== overlayGateBase) return;
    if (!(color==='red'||color==='blue')) return;
    if (!imgCache.has(finalKeyFor(base))){
      finalsEntrants().then(pack=>{ if (pack) imgCache.set(finalKeyFor(base), pack); showChampion(color, base); });
    } else {
      showChampion(color, base);
    }
  }).subscribe();

supabase.channel('phase-votes-live')
  .on('postgres_changes',{event:'*',schema:'public',table:'phase_votes'}, async (payload)=>{
    const pk = payload?.new?.phase_key || payload?.old?.phase_key;
    if (!pk) return;
    updateBracketScores();
    const want = currentBattleKey();
    if (pk && want && pk===want) await refreshCounts();
  }).subscribe();

/* ---------- Boot ---------- */
(async()=>{
  currentUid = await getUidOrNull(); paintLoginBadge();
  supabase.auth.onAuthStateChange((_evt, session)=>{ currentUid=session?.user?.id ?? null; paintLoginBadge(); submitBtn.disabled=!chosen||!currentUid; });
  await fetchState();
  await paintImages();
  rafId = requestAnimationFrame(tick);
})();
</script>
</body>
</html>