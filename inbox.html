<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space — Direct Messages</title>
  <meta name="color-scheme" content="dark" />
  <style>
    :root{
      --green:#39ff14; --bg:#000; --ink:#e5ffe5; --border:#0f2a0f; --red:#ff0033; --muted:#8aff8a;
    }
    *{ box-sizing:border-box }
    body{
      margin:0; background:var(--bg); color:var(--green);
      font-family:ui-sans-serif,system-ui,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing:antialiased; position:relative; overflow-x:hidden;
    }
    /* CRT scanlines */
    body::before{
      content:""; position:fixed; inset:0; pointer-events:none; z-index:0;
      background:
        repeating-linear-gradient(to bottom,
          rgba(57,255,20,.05) 0px,
          rgba(57,255,20,.05) 2px,
          transparent 5px);
      animation:scan 7s linear infinite;
    }
    @keyframes scan{ from{background-position:0 0} to{background-position:0 100vh} }

    .wrap{ position:relative; z-index:2; }

    .topbar{
      display:flex; align-items:center; gap:.75rem; padding:.7rem 1rem;
      border-bottom:1px solid var(--border); position:sticky; top:0;
      background:#000c; backdrop-filter: blur(6px); z-index:3;
    }
    .back{ text-decoration:none; color:var(--green); border:1px solid var(--border); padding:.4rem .8rem; border-radius:999px; font-weight:800; }
    h1{ margin:0; font-size:1.4rem; text-shadow:0 0 14px var(--red), 0 0 6px rgba(57,255,20,.85); }

    .list{ padding:14px; display:flex; flex-direction:column; gap:12px; }
    .empty{ opacity:.65; text-align:center; margin-top:22vh; }

    a.thread{
      text-decoration:none; color:var(--ink);
      display:flex; gap:12px; align-items:center;
      padding:14px; border-radius:16px; background:linear-gradient(180deg,#0a0a0a,#050505);
      border:1px solid #1a1a1a; box-shadow:0 0 8px rgba(57,255,20,.08) inset;
      position:relative;
    }
    a.thread.unread{
      border-color:#440b0b;
      box-shadow:0 0 18px rgba(255,0,51,.45), 0 0 0 1px rgba(255,0,51,.35) inset;
      outline:1px solid rgba(255,0,51,.65);
    }

    .pfp{ width:64px; height:64px; min-width:64px; border-radius:14px; border:3px solid var(--green); overflow:hidden; background:#0f0f0f; }
    .pfp img{ width:100%; height:100%; object-fit:cover; display:block; }

    .meta{ display:flex; flex-direction:column; gap:6px; flex:1; min-width:0; }
    .row1{ display:flex; align-items:center; gap:10px; }
    .name{ color:var(--green); font-weight:900; font-size:1.05rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .time{ margin-left:auto; color:var(--muted); opacity:.9; font-size:.85rem; white-space:nowrap; }
    .last{ color:var(--ink); opacity:.9; font-size:.95rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .err{
      position:fixed; left:50%; transform:translateX(-50%); bottom:76px; z-index:10;
      background:#170000; color:#ff9b9b; border:1px solid #330; padding:.5rem .75rem; border-radius:8px; display:none;
      max-width:92%;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <a class="back" href="./menu.html">← Back</a>
      <h1>Direct Messages</h1>
    </div>

    <div id="list" class="list"></div>
    <div id="empty" class="empty" style="display:none">No conversations yet.</div>
    <div id="err" class="err"></div>
  </div>

  <script>
    /* ---------- Supabase ---------- */
    const sb = supabase.createClient(
      "https://tuqvpcevrhciursxrgav.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y"
    );

    /* ---------- DOM ---------- */
    const list  = document.getElementById('list');
    const empty = document.getElementById('empty');
    const errEl = document.getElementById('err');

    function showErr(msg){
      errEl.textContent = msg;
      errEl.style.display = 'block';
      clearTimeout(showErr._t);
      showErr._t = setTimeout(()=> errEl.style.display='none', 2600);
    }

    /* ---------- Helpers ---------- */
    const bust = (url, ver=Date.now()) => url ? (url + (url.includes('?')?'&':'?') + 'v=' + ver) : url;

    function lastReadKey(threadId){ return `dm_last_read_${threadId}`; }
    function getLastRead(threadId){
      const v = localStorage.getItem(lastReadKey(threadId));
      return v ? parseInt(v, 10) : 0;
    }
    function setLastRead(threadId, ts){
      try{ localStorage.setItem(lastReadKey(threadId), String(ts||Date.now())); }catch{}
    }

    const fmtTime = (iso)=>{
      if(!iso) return '';
      const d = new Date(iso);
      return d.toLocaleString([], { month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' });
    };

    // Name fallback: username -> display_name -> @user-<id6>
    function nameFromProfile(p, otherId){
      if (p) {
        if (p.username && p.username.trim())     return '@' + p.username.trim();
        if (p.display_name && p.display_name.trim()) return p.display_name.trim();
      }
      return '@user-' + (otherId || '').slice(0,6);
    }

    function escapeHtml(s){
      return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function threadRow(otherProfile, otherId, thread, lastMsg, unread){
      const name = nameFromProfile(otherProfile, otherId);
      const a = document.createElement('a');
      a.href = `./dm.html?thread=${thread.id}`;
      a.className = 'thread' + (unread ? ' unread' : '');

      const ver = otherProfile?.updated_at ? new Date(otherProfile.updated_at).getTime() : Date.now();
      const avatar = otherProfile?.avatar_url ? `<img src="${bust(otherProfile.avatar_url, ver)}" alt="">` : '';

      const lastTextRaw = (lastMsg?.content ?? lastMsg?.body ?? '');
      const lastText = lastTextRaw ? escapeHtml(lastTextRaw) : 'No messages yet';

      a.innerHTML = `
        <div class="pfp">${avatar}</div>
        <div class="meta">
          <div class="row1">
            <div class="name">${name}</div>
            <div class="time">${fmtTime(lastMsg?.created_at || thread.created_at)}</div>
          </div>
          <div class="last">${lastText}</div>
        </div>
      `;

      // When you click in, mark as read immediately so glow clears on return
      a.addEventListener('click', ()=> setLastRead(thread.id, Date.now()));
      return a;
    }

    /* ---------- Load inbox ---------- */
    let me = null;

    async function loadInbox(){
      list.innerHTML = '';
      const { data: { session }, error: sErr } = await sb.auth.getSession();
      if (sErr) { showErr('Auth failed'); return; }
      if (!session) { location.href = './login.html'; return; }
      me = session.user;

      // Only threads I'm in
      const { data: threads, error: tErr } = await sb
        .from('dm_threads')
        .select('id,a,b,created_at,updated_at')
        .or(`a.eq.${me.id},b.eq.${me.id}`)
        .order('updated_at', { ascending:false })
        .order('created_at', { ascending:false });

      if (tErr) { showErr('Failed to load threads'); console.error(tErr); return; }
      if (!threads || threads.length === 0) { empty.style.display = ''; return; }
      empty.style.display = 'none';

      const otherIds = threads.map(t => t.a === me.id ? t.b : t.a);
      const uniqOther = [...new Set(otherIds)];

      // Load profiles for the OTHER users
      let profilesById = {};
      if (uniqOther.length){
        const { data: profiles, error: pErr } = await sb
          .from('profiles')
          .select('id,username,display_name,avatar_url,updated_at')
          .in('id', uniqOther);
        if (pErr) console.warn('profiles error:', pErr);
        profilesById = Object.fromEntries((profiles||[]).map(p => [p.id, p]));
      }

      for (const t of threads){
        const otherId = (t.a === me.id) ? t.b : t.a;

        // Last message in thread (uses 'content', falls back to 'body')
        const { data: last } = await sb
          .from('dm_messages')
          .select('id,content,body,created_at,sender')
          .eq('thread_id', t.id)
          .order('created_at', { ascending:false })
          .limit(1)
          .maybeSingle();

        const lastTs = last?.created_at ? Date.parse(last.created_at) : Date.parse(t.updated_at || t.created_at);
        const lastReadTs = getLastRead(t.id);
        const isUnread = !!(last && last.sender !== me.id && lastTs > lastReadTs);

        list.appendChild(
          threadRow(profilesById[otherId], otherId, t, last, isUnread)
        );

        // Realtime glow when new message arrives from other person
        sb.channel(`dm_thread_${t.id}`)
          .on('postgres_changes',
              { event:'INSERT', schema:'public', table:'dm_messages', filter:`thread_id=eq.${t.id}` },
              (payload)=>{
                const m = payload.new;
                if (m.sender !== me.id){
                  const row = [...list.querySelectorAll('a.thread')]
                    .find(el => el.getAttribute('href')?.includes(`thread=${t.id}`));
                  if (row) row.classList.add('unread');
                }
              }
          ).subscribe();
      }
    }

    document.addEventListener('visibilitychange', ()=>{
      if (document.visibilityState === 'visible') loadInbox();
    });

    document.addEventListener('DOMContentLoaded', loadInbox);
  </script>
</body>
</html>