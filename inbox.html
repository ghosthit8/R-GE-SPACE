<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Rage Space — Inbox</title>
  <meta name="color-scheme" content="dark"/>
  <style>
    :root{ --green:#39ff14; --red:#ff0033; --bg:#000; --ink:#e5ffe5; --muted:#8aff8a; }
    *{ box-sizing:border-box; margin:0; padding:0 }
    html,body{ height:100% }
    body{
      background:#000; color:var(--green);
      font-family:ui-sans-serif,system-ui,Arial,Helvetica,sans-serif;
      -webkit-font-smoothing:antialiased;
    }
    .wrap{ max-width:900px; margin:0 auto; padding:16px }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:16px;
    }
    .me-chip{
      display:inline-flex; align-items:center; gap:10px; padding:8px 12px; border-radius:999px;
      border:2px solid var(--green); box-shadow:0 0 14px rgba(57,255,20,.35);
      text-decoration:none; color:var(--green); background:transparent; font-weight:800;
    }
    .pfp{ width:28px; height:28px; border-radius:50%; border:2px solid var(--green); display:inline-block; overflow:hidden; background:#0a0a0a; }
    .pfp img{ width:100%; height:100%; object-fit:cover; display:block }
    .btn{ appearance:none; border:2px solid var(--green); color:#000; background:var(--green); font-weight:800; padding:10px 14px; border-radius:12px; text-decoration:none; }
    .btn.ghost{ background:transparent; color:var(--green) }

    .list{ display:flex; flex-direction:column; gap:10px; }
    .row{
      display:flex; align-items:center; gap:12px; padding:12px; border:1px solid #103010; border-radius:12px;
      background:linear-gradient(180deg,#090909,#050505);
      text-decoration:none; color:var(--ink);
      transition: transform .06s ease;
    }
    .row:active{ transform:translateY(1px) }
    .who{ color:var(--green); font-weight:900; letter-spacing:.2px }
    .meta{ margin-left:auto; font-size:12px; color:var(--muted) }
    .msg{ color:var(--ink); font-size:14px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:50vw }

    /* red glow for unseen */
    .unseen{
      box-shadow:0 0 14px rgba(255,0,51,.55), inset 0 0 50px rgba(255,0,51,.07);
      border-color:var(--red);
    }
    .badge{
      display:inline-block; min-width:20px; padding:2px 6px; border-radius:999px; margin-left:6px;
      background:#000; border:1px solid currentColor; color:var(--red); font-size:12px; line-height:1; text-align:center;
    }
    .empty{ margin-top:24px; color:var(--muted) }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <a class="btn ghost" href="./menu.html">← Menu</a>
      <a id="meChip" class="me-chip" href="./profile.html">
        <span class="pfp" id="mePfp"></span>
        <span id="meName">…</span>
      </a>
      <a id="logoutBtn" class="btn ghost" href="#">Logout</a>
    </div>

    <h2 style="margin:6px 0 14px; letter-spacing:.25px;">Inbox</h2>
    <div id="list" class="list"></div>
    <p id="empty" class="empty" style="display:none">No messages yet.</p>
  </div>

  <script>
    const sb = supabase.createClient(
      "https://tuqvpcevrhciursxrgav.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y"
    );

    const meName = document.getElementById('meName');
    const mePfp  = document.getElementById('mePfp');
    const listEl = document.getElementById('list');
    const emptyEl= document.getElementById('empty');

    let me = null;

    const bust = (url, ver=Date.now()) => url ? (url + (url.includes('?')?'&':'?') + 'v=' + ver) : url;

    async function getProfile(uid){
      const { data, error } = await sb.from('profiles').select('id,username,display_name,avatar_url,updated_at').eq('id', uid).maybeSingle();
      if(error) { console.warn('profile lookup', error); }
      return data || null;
    }

    function nameFrom(profile){
      return profile?.username || profile?.display_name || 'user';
    }

    function setMyHeader(profile){
      meName.textContent = nameFrom(profile);
      if(profile?.avatar_url){
        mePfp.innerHTML = `<img alt="" src="${bust(profile.avatar_url, profile.updated_at ? new Date(profile.updated_at).getTime() : Date.now())}">`;
      } else {
        mePfp.innerHTML = "";
      }
    }

    function threadKey(tid){ return `dm_last_read_${tid}`; }
    function getLastRead(tid){
      try{ return parseInt(localStorage.getItem(threadKey(tid))||'0',10) || 0; }catch{ return 0; }
    }
    function setLastRead(tid, ts){
      try{ localStorage.setItem(threadKey(tid), String(ts||Date.now())); }catch{}
    }

    async function loadThreads(){
      const { data: threads, error } = await sb
        .from('dm_threads')
        .select('id,a,b,created_at,updated_at')
        .or(`a.eq.${me.id},b.eq.${me.id}`)
        .order('updated_at', { ascending:false })
        .order('created_at', { ascending:false });

      if(error){ console.error(error); return; }

      listEl.innerHTML = '';
      if(!threads || threads.length === 0){
        emptyEl.style.display = '';
        return;
      }
      emptyEl.style.display = 'none';

      for(const t of threads){
        const otherId = (t.a === me.id) ? t.b : t.a;

        // fetch last message
        const { data:lastMsg } = await sb
          .from('dm_messages')
          .select('id,sender,content,created_at')
          .eq('thread_id', t.id)
          .order('created_at', { ascending:false })
          .limit(1)
          .maybeSingle();

        // fetch other profile
        const other = await getProfile(otherId);
        const otherName = nameFrom(other);
        const ver = other?.updated_at ? new Date(other.updated_at).getTime() : Date.now();
        const avatar = other?.avatar_url ? `<img alt="" src="${bust(other.avatar_url, ver)}">` : '';

        // unseen?
        const lastRead = getLastRead(t.id);
        const lastTs = lastMsg ? new Date(lastMsg.created_at).getTime() : new Date(t.updated_at || t.created_at).getTime();
        const isFromOther = lastMsg ? (lastMsg.sender !== me.id) : false;
        const unseen = isFromOther && lastTs > lastRead;

        // row
        const a = document.createElement('a');
        a.className = 'row' + (unseen ? ' unseen' : '');
        a.href = `./dm.html?thread=${t.id}`;
        a.innerHTML = `
          <span class="pfp">${avatar}</span>
          <div style="min-width:0">
            <div class="who">${otherName}${unseen?'<span class="badge">new</span>':''}</div>
            <div class="msg">${lastMsg?.content ? escapeHtml(lastMsg.content) : '— no messages yet —'}</div>
          </div>
          <div class="meta">${timeAgo(lastMsg?.created_at || t.updated_at || t.created_at)}</div>
        `;
        // mark read when clicked
        a.addEventListener('click', ()=> setLastRead(t.id, Date.now()));
        listEl.appendChild(a);
      }
    }

    function escapeHtml(s){
      return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function timeAgo(iso){
      if(!iso) return '';
      const d = new Date(iso).getTime(), now = Date.now();
      const s = Math.max(1, Math.floor((now - d)/1000));
      const units = [
        ['y', 31536000],
        ['mo', 2592000],
        ['d', 86400],
        ['h', 3600],
        ['m', 60],
      ];
      for(const [u, sec] of units){
        if(s >= sec) return Math.floor(s/sec) + u;
      }
      return s + 's';
    }

    async function boot(){
      const { data:{ session } } = await sb.auth.getSession();
      if(!session){ location.href='./login.html'; return; }
      me = session.user;

      // header: pull my profile (to avoid showing email)
      const myProfile = await getProfile(me.id);
      setMyHeader(myProfile);

      // logout
      document.getElementById('logoutBtn').onclick = async (e)=>{
        e.preventDefault();
        await sb.auth.signOut();
        location.href='./index.html';
      };

      await loadThreads();

      // realtime: bump list on new messages
      sb.channel('dm_inbox_rt')
        .on('postgres_changes', { event: '*', schema:'public', table:'dm_messages' }, loadThreads)
        .subscribe();
    }

    document.addEventListener('DOMContentLoaded', boot);
  </script>
</body>
</html>