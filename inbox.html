<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rage Space ‚Äî Inbox</title>
  <meta name="color-scheme" content="dark" />

  <!-- If you have a shared stylesheet, keep it + bump ?v= when you change CSS -->
  <link rel="stylesheet" href="./style.css?v=4" />

  <style>
    :root{ --green:#39ff14; --ink:#e5ffe5; --card:#0a0a0a; --border:#103010; --red:#ff0033; }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{ margin:0; background:#000; color:var(--green); font-family:ui-sans-serif,system-ui,Arial,Helvetica,sans-serif; }

    header{
      position:sticky; top:0; z-index:10; background:rgba(0,0,0,.7); backdrop-filter:blur(6px);
      border-bottom:1px solid var(--border); padding:12px 16px; display:flex; align-items:center; gap:10px;
    }
    a.back{
      color:var(--green); text-decoration:none; border:1px solid var(--green);
      padding:6px 12px; border-radius:999px; font-weight:800;
    }

    .wrap{ max-width:940px; margin:0 auto; padding:16px; }
    .thread{
      display:flex; gap:12px; padding:14px;
      background:linear-gradient(180deg,#0a0a0a,#050505);
      border:1px solid var(--border); border-radius:12px;
      margin:10px 0; text-decoration:none; color:var(--ink); align-items:center;
      transition:border-color .2s ease, box-shadow .2s ease, transform .08s ease;
      position:relative;
    }
    .thread:active{ transform:translateY(1px) }
    .thread:hover{ outline:2px solid var(--green); }

    .pfp{ width:48px; height:48px; border-radius:12px; background:#111; border:2px solid var(--green); overflow:hidden; flex:0 0 auto; }
    .pfp img{ width:100%; height:100%; object-fit:cover; display:block; }

    .meta{ display:flex; flex-direction:column; min-width:0 }
    .name{ color:var(--green); font-weight:800; }
    .last{ color:var(--ink); opacity:.85; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100%; }

    .empty{ color:var(--ink); opacity:.7; text-align:center; padding:40px 0; }

    /* üî¥ Unread flicker ‚Äî inline so it won‚Äôt be stale-cached */
    @keyframes redPulse {
      0%, 100% { box-shadow: 0 0 0 rgba(255,0,51,0), inset 0 0 0 rgba(255,0,51,0); }
      50%      { box-shadow: 0 0 14px rgba(255,0,51,.75), 0 0 34px rgba(255,0,51,.35);
                 outline: 2px solid rgba(255,0,51,.55); }
    }
    .thread.unread{
      border-color: var(--red);
      animation: redPulse 1.4s ease-in-out infinite;
      will-change: box-shadow, outline;
    }
    @media (prefers-reduced-motion: reduce){
      .thread.unread{ animation:none; box-shadow:0 0 10px rgba(255,0,51,.6); }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <header>
    <!-- Per your requirement: ‚ÄúHome‚Äù ‚Üí ‚ÄúBack‚Äù and go to profile.html -->
    <a class="back" href="./profile.html">‚Üê Back</a>
    <h1 style="margin:0;font-size:18px;letter-spacing:.5px;">Direct Messages</h1>
  </header>

  <main class="wrap">
    <div id="list"></div>
    <div id="empty" class="empty" style="display:none;">No conversations yet. Find a profile and hit <b>Message privately</b>.</div>
  </main>

  <script>
    const sb = supabase.createClient(
      "https://tuqvpcevrhciursxrgav.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXZwY2V2cmhjaXVyc3hyZ2F2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDA0NDQsImV4cCI6MjA3MjA3NjQ0NH0.JbIWJmioBNB_hN9nrLXX83u4OazV49UokvTjNB6xa_Y"
    );

    const list  = document.getElementById('list');
    const empty = document.getElementById('empty');
    let me = null;

    function lastReadKey(threadId){ return `dm_last_read_${threadId}`; }
    function getLastRead(threadId){
      const v = localStorage.getItem(lastReadKey(threadId));
      return v ? parseInt(v, 10) : 0;
    }

    function threadRow(other, thread, lastMsg, unread){
      const a = document.createElement('a');
      a.href = `./dm.html?thread=${thread.id}`;
      a.className = 'thread' + (unread ? ' unread' : '');
      a.innerHTML = `
        <div class="pfp">${other?.avatar_url ? `<img src="${other.avatar_url}" alt="">` : ''}</div>
        <div class="meta">
          <div class="name">${other?.display_name?.trim()
            || (other?.username ? '@'+other.username.trim() : '@user-' + (other?.id||'').slice(0,6))}</div>
          <div class="last">${lastMsg?.body ? lastMsg.body : 'No messages yet'}</div>
        </div>
      `;
      return a;
    }

    async function loadInbox(){
      list.innerHTML = '';
      const { data: { session } } = await sb.auth.getSession();
      if(!session){ location.href = './login.html'; return; }
      me = session.user;

      // 1) My threads (RLS should scope these)
      const { data: threads, error: tErr } = await sb
        .from('dm_threads')
        .select('id,a,b,created_at')
        .order('created_at', { ascending:false });

      if(tErr){ console.error(tErr); return; }

      if(!threads || threads.length===0){ empty.style.display = ''; return; }
      empty.style.display = 'none';

      // 2) Others‚Äô profiles
      const otherIds = threads.map(t => t.a === me.id ? t.b : t.a);
      const uniqIds = [...new Set(otherIds)];
      const { data: others, error: oErr } = await sb
        .from('profiles')
        .select('id,username,display_name,avatar_url')
        .in('id', uniqIds);

      if(oErr){ console.warn(oErr); }

      const byId = Object.fromEntries((others||[]).map(u => [u.id, u]));

      // 3) Last msg per thread + unread calc
      for(const t of threads){
        const otherId = t.a === me.id ? t.b : t.a;

        const { data: last } = await sb
          .from('dm_messages')
          .select('id,body,created_at,sender')
          .eq('thread_id', t.id)
          .order('created_at', { ascending:false })
          .limit(1)
          .maybeSingle();

        const lastTs = last?.created_at ? Date.parse(last.created_at) : 0;
        const lastReadTs = getLastRead(t.id);
        const isUnread = !!(last && last.sender !== me.id && lastTs > lastReadTs);

        list.appendChild(threadRow(byId[otherId], t, last, isUnread));

        // Realtime updates for each thread (so glow flips on without reload)
        sb.channel(`dm_thread_${t.id}`)
          .on('postgres_changes',
              { event:'INSERT', schema:'public', table:'dm_messages', filter:`thread_id=eq.${t.id}` },
              (payload)=>{
                const newMsg = payload.new;
                // Only mark unread if it's from the other user
                if(newMsg.sender !== me.id){
                  // find the row and add .unread
                  const row = [...list.querySelectorAll('a.thread')]
                    .find(el => el.getAttribute('href')?.includes(`thread=${t.id}`));
                  if(row) row.classList.add('unread');
                }
              }
          ).subscribe();
      }
    }

    document.addEventListener('DOMContentLoaded', loadInbox);
  </script>
</body>
</html>